<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>docker入门学习</title>
    <url>/2020/01/25/docker-new/</url>
    <content><![CDATA[<p>docker入门</p>
<a id="more"></a>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>  作于2020年春节大年初一晚,此时疫情真的是猛于虎,为了避免给我媳妇她们医院带来不必要的麻烦,老实在家呆着学学新知识,提升自我.  </p>
<blockquote>
<h1 id="Talk-is-cheap-show-me-the-code"><a href="#Talk-is-cheap-show-me-the-code" class="headerlink" title="Talk is cheap, show me the code"></a>Talk is cheap, show me the code</h1></blockquote>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><blockquote>
<p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现,基于 Linux 内核的<br>   cgroup,namespace,以及 AUFS 类的 Union FS 等技术,对进程进行封装隔离,属于操作<br>   系统层面的虚拟化技术  </p>
</blockquote>
<p>   个人理解就是一种虚拟化技术,类似之前接触过的lvm(linux virtual machine),但是有很大的不同,lvm是有一套完整的系统,虚拟出一套硬件系统和操作系统,然后在该系统之上又有很多的应用;而容器技术里面的应用直接是运行在容器宿主的内核之上,也没有虚拟除一套硬件,一套操作系统;所以容器很轻便小巧.<br>   ps: 从以上描述可以看出,容器技术更适用于持续集成和devOps,有点 <code>java--Complie Once,Run Anywhere</code> 的意思,只需要打包一次,在任何地方,任何系统之上都能使用,不存在之前 <code>各种环境</code> (开发环境,测试环境,灰度环境,正式环境)导致的[这段代码在我机器上好好的啊,怎么可能有问题]</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol>
<li><p>注册docker hub 账号  </p>
</li>
<li><p>在<a href="https://docs.docker.com/" target="_blank" rel="noopener">docker</a>官方文档上找到对应操作系统的下载地址<img src="https://i.ibb.co/jw20qkm/docker-com.png" alt=""><br>ps: 文件还是有点大,建议使用迅雷等p2p工具下载.  </p>
</li>
<li><p>本人使用<code>windows专业版系统</code>,选择<code>docker desktop for windows</code>按照官网提示下载,完成之后不着急安装,此时需要先启动<code>hyper-v</code>,<code>docker desktop</code>是依赖<code>hyper-v</code>的,开启<code>hype-v</code>之后需要重启电脑,重启之后安装<code>docker desktop</code>,安装过程省略,下一步下一步即可.<br>ps: 如果你是<code>windows 家庭版</code>,请参考<a href="https://www.jianshu.com/p/1329954aa329/" target="_blank" rel="noopener">这篇文章</a>  </p>
</li>
<li><p>启动<code>docker desktop</code>,在系统托盘图标<code>右键-&gt;setting</code>,找到<code>resources-&gt;file sharing</code>,选择你要共享的盘符,因为<code>docker desktop</code>默认是使用<code>hyper-v</code>虚拟机,而<code>hyper-v</code>虚拟机默认的镜像地址都是在<code>C盘</code>,也就是系统盘,这会导致<code>c盘</code>不够用,可以直接在<code>resources-&gt;advanced</code>下面找到<code>disak image location</code>修改镜像位置,本人是没有修改,这里本人是开启了共享盘符,把之后镜像使用的存储空间映射到本地其他磁盘上,这样解决了大部分存储空间的问题,镜像存储就不管了    </p>
</li>
</ol>
<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><ol>
<li><p>打开<code>power shell</code>,这里最好是不要使用其他命令终端,本人之前学习时候使用cmd,使用cmd是有坑的,后面会讲到,输入<code>docker login</code>,按照提示输入之前在<code>docker hub</code>上注册的用户名,密码,第一次需要输入,后续可以不用,也可使用图像化界面登录,右键<code>docker desktop</code>系统托盘图标-&gt;login.  </p>
</li>
<li><p>登录之后我们就可以是用<code>docker search</code>命令来搜索我们感兴趣的仓库了,比如我们安装一个mysql吧,<code>docker search mysql</code>,可以看到有很多的<code>mysql</code>镜像,还有<code>star数</code>和<code>official</code><br>ps: 根据是否是官方提供,可将镜像资源分为两类.一种是类似 <code>mysql</code> 这样的镜像,被称为基础镜像或根镜像.这些基础镜像由 Docker 公司创建、验证、支持、提供.这样的镜像往往使用单个单词作为名字.还有一种类型,比如 <code>bitnami/mysql</code> 镜像,它是由 Docker 的用户创建并维护的,往往带有用户名称前缀.  </p>
</li>
<li><p>使用<code>docker pull</code>拉去镜像,具体命令如下  </p>
<blockquote>
<p>docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]   </p>
</blockquote>
<p>具体选项可以通过<code>docker pull --help</code> 来查看,  </p>
<ul>
<li>docker registry地址: 默认是docker hub,一般不需要指定</li>
<li>仓库名: 前文提到镜像名称分为两段,<code>&lt;username&gt;/&lt;soft name&gt;</code>如果不指定默认是library,即docker官方的镜像.</li>
<li>tag: 标签,如果不指定默认为latest,当然可以指定需要的版本,查询tag目前本人没有找到相应的命令,只能去<a href="https://hub.docker.com/" target="_blank" rel="noopener">docker hub</a>搜索镜像然后查看tag    </li>
</ul>
<p>综上所述,此时只需使用<code>docker pull mysql</code>就可以了  </p>
<ol start="4">
<li><p>可以是用<code>docker image ls</code>或者<code>docker images</code> 查看本地镜像<img src="https://i.ibb.co/myY1D6q/docker-images.png" alt=""><br>此时可以看到镜像的大小和在<code>docker hub</code>大小是不一样的,这是因为,在<code>docker hub</code>显示的是压缩大小,<code>docker hub</code>作为一个中央镜像仓库,关心的是流量大小,而不是体积大小,所以会尽可能的压缩镜像体积;而且在这里,显示的大小可能和实际占用磁盘空间大小还不一样,这是因为,镜像是有很多文件层组成,而文件层之间又存在继承,复用的关系,如果不同的镜像使用相同的基础层,那么只需要保存一份该基础层就可以了,不同镜像的其他层可以直接引用该基础层,可以使用<code>docker system df -v</code>来查看具体的占用情况,同时可以使用<code>docker system prune</code>来清理磁盘空间.<br><code>docker image ls</code> 支持通配符,如 <code>docker images my*</code> 可以将所有my开头的镜像都列出<br><code>docker image ls -q</code> 可以只显示镜像的 <code>ID</code><br>此外还支持 <code>-f(--filter)</code> 过滤模式, 比如: <code>docker images -f since=mysql</code> 会列出在 <code>mysql</code>之后的所有镜像,将 <code>since</code> 换成 <code>before</code> 可以列出之前的镜像  </p>
</li>
<li><p>启动容器,每一个容器都是一个镜像实例,这个就像<code>java里面的oop思想</code>一样,一个镜像就是一个类,一个类的对象对应一个容器,java 里面使用<code>new</code>关键字实例化对象,这里我们使用<code>docker run</code>来启动一个容器,具体命令参数:  </p>
<blockquote>
<p>docker run [OPTIONS] IMAGE [COMMAND] [ARG…]   </p>
</blockquote>
</li>
</ol>
<p>此处常用的 <code>options</code> 有 <code>-p</code> 指定端口号, <code>-P</code> 指定端口号映射为本机随机端口号; <code>-e</code> 指定容器内部的环境变量;<code>-d</code> 指定为后台启动;<code>-i</code> 保持stdin标准的输入流打开状态,即使没有链接; <code>-t</code> 分配一个伪终端, <code>-v</code> 指定文件映射,即讲本地的一个目录或者文件映射到容器内部;具体启动命令:  </p>
<blockquote>
<p>docker run -d -p 3305:3306 –privileged=true -e MYSQL_ROOT_PASSWORD=xxxx –name   mysqltest -v /f/mysql/data:/var/lib/mysql -v /f/mysql/conf/my.cnf:/etc/mysql/my.cnf<br>-v //f/mysql/mysql-files:/var/lib/mysql-files/ mysql:latest –character-set-server=utf8mb4 –collation-server=utf8mb4_unicode_ci  </p>
</blockquote>
<p>解释一下,此时我们就把容器内部的3306端口映射为宿主机的3305端口,并且设置了mysql的配置,数据存储位置,并且进行了一系列的mysql参数设置,指定了 <code>msyql root</code> 的密码为xxx,–privileged是让容器内部的用户获取宿主机特殊权限,此处一定要把文件映射在你已经共享的盘符,不然会失败  </p>
<ol start="6">
<li>查看容器状态, <code>docker container ls -a</code> 或 <code>docker ps -a</code> 可以看到容器的状态,映射端口,名字等;<br>使用 <code>docker stop &lt;container name\id&gt;</code> 停止容器, 使用 <code>docker start &lt;container name\id&gt;</code> 再次启动容器,注意第一次启动容器使用 <code>docker  run</code> 命令,该命令会创建并启动一个容器, 之后并不需要在run,只需要执行start就可以了,此外 <code>docker run</code> 执行时,如果指定镜像不存在,该命令会自动拉去默认仓库所匹配的镜像  </li>
</ol>
</li>
</ol>
<ol start="7">
<li>删除镜像和容器<br>删除镜像使用 <code>docker image rm</code> 或 <code>docker rmi</code> 加上镜像的 <code>ID</code> 来删除镜像<br>删除容器使用 <code>docker container rm</code> 或 <code>docker rm</code> 加上容器 <code>ID</code> 删除容器,可以添加 <code>-f</code> 强制删除一个正在运行的容器;<br>此外如果只是想清理未被容器使用的镜像可以使用 <code>docker image prune</code><br>同理,可以使用  <code>docker container prune</code> 清理未运行的容器<br>如果需要删除的容器或者镜像太多,手动一个个输入就显得有点智障了,此时可以使用 <code>docker image ls -q</code> 来配合批量删除,比如:<br><code>docker rmi $(docker image ls -q -f since=mysql)</code><br>此时就会将mysql之前所有的镜像都删除<br>ps: 此处有之前说的 <code>cmd</code> 的坑,使用 <code>cmd</code> 会报错,改用 <code>power shell</code> 就不会</li>
</ol>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>基础入门就这些,后续根据自身所学内容,会陆陆续续的记录更多的东西,比如如何创建一个docker容器啊,导入导出镜像啊,私有仓库的搭建等等.  </p>
<blockquote>
<p>不积跬步，无以至千里；不积小流，无以成江海</p>
</blockquote>
<hr>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo+github pages建立静态blog</title>
    <url>/2020/01/14/first/</url>
    <content><![CDATA[<blockquote>
<p>好记性不如烂笔头</p>
</blockquote>
<p>记录一下使用hexo + github pages搭建博客的过程,以及过程中遇到的坑;同时也给阅读这篇文章,想要搭建博客的人一点帮助</p>
<a id="more"></a>
<h1 id="为什么搞独立blog"><a href="#为什么搞独立blog" class="headerlink" title="为什么搞独立blog"></a>为什么搞独立blog</h1><p><code>市面上blog service多如牛毛为啥非要搞自己的,因为独立的才是自己的</code></p>
<h1 id="为什么使用gihub-pages"><a href="#为什么使用gihub-pages" class="headerlink" title="为什么使用gihub pages"></a>为什么使用gihub pages</h1><p><code>因为不用买服务器,免费而且稳定,也无需域名,只需要你有github账号就能用</code></p>
<blockquote>
<h1 id="Talk-is-cheap-show-me-the-code"><a href="#Talk-is-cheap-show-me-the-code" class="headerlink" title="Talk is cheap, show me the code"></a>Talk is cheap, show me the code</h1></blockquote>
<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><ol>
<li><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">git</a>根据自己电脑下载相应版本,本人是win10电脑使用git bash.</li>
<li>安装完成打开<code>git bash</code>, 输入<code>git --version</code>测试是否安装成功</li>
<li>注册<a href="https://github.com/" target="_blank" rel="noopener">github</a>账号(全球最大的同性交友网站,你值得拥有).</li>
<li>新建<code>&lt;username&gt;.github.io</code>仓库.</li>
</ol>
<h1 id="node"><a href="#node" class="headerlink" title="node"></a>node</h1><ol>
<li><a href="http://nodejs.cn/download/]" target="_blank" rel="noopener">node</a>根据自己电脑下载相应版本</li>
<li>安装完成之后,在之前的<code>git bash</code>输入<code>node --version</code>测试是否安装成功</li>
</ol>
<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><ol>
<li><p>安装好 Node.js 后，通过 npm 安装 Hexo</p>
<blockquote>
<p>npm install hexo-cli -g</p>
</blockquote>
<p> ps: 可能安装失败,如果失败,安装cnpm,然后在安装hexo;或者挂代理,走梯子</p>
<blockquote>
<p>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p>
</blockquote>
</li>
<li><p>安装 Hexo 完成后,执行</p>
<blockquote>
<p>hexo init &lt;folder&gt;<br>cd &lt;folder&gt;<br>npm install  </p>
</blockquote>
<p> 执行完成之后目录会像</p>
<blockquote>
<p>├── _config.yml<br> ├── node_modules<br> │   ├── hexo<br> │   ├── hexo-generator-archive<br> │   ├── hexo-generator-category<br> │   ├── hexo-generator-index<br> │   ├── hexo-generator-tag<br> │   ├── hexo-renderer-ejs<br> │   ├── hexo-renderer-marked<br> │   ├── hexo-renderer-stylus<br> │   └── hexo-server<br> ├── package.json<br> ├── scaffolds<br> │   ├── draft.md<br> │   ├── page.md<br> │   └── post.md<br> ├── source<br> │   └── _posts<br> └── themes  </p>
<pre><code>└── landscape  </code></pre></blockquote>
<p> ps: 简单说明一下目录作用   </p>
<blockquote>
<p> _config.yml  配置文件,网站的标题,作者,主题配置等<br> node_modules hexo的模块,较少关心<br> package.json 项目描述文件,不用关心<br> scaffolds  模版配置,较少关心<br> source–&gt;_post  主要存放我们写的文章<br> themes  <a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo主题</a>,文件夹名称对应为主题名称  </p>
</blockquote>
</li>
<li><p>配置_config.yml</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: Hexo #标题</span><br><span class="line">subtitle: #副标题</span><br><span class="line">description: #描述</span><br><span class="line">author: #你的名字</span><br><span class="line">language: zh #网站使用的语言,注意使用主题下面的语言(themes--&gt;&lt;要使用的主题&gt;--&gt;languages)不然会出现未知结果</span><br><span class="line">timezone: Asia&#x2F;Shanghai #网站时区 </span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">url: https:&#x2F;&#x2F;dengbojing.com #地址(如果未申请域名则不需要填写)</span><br><span class="line">root: &#x2F; #根目录</span><br><span class="line">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F; #文章的永久链接格式</span><br><span class="line">permalink_defaults: #</span><br><span class="line">    trailing_index: true # Set to false to remove trailing &#39;index.html&#39; from permalinks</span><br><span class="line">    trailing_html: true # Set to false to remove trailing &#39;.html&#39; from permalinks</span><br><span class="line"></span><br><span class="line"># Directory</span><br><span class="line">source_dir: source #资源文件夹</span><br><span class="line">public_dir: public #由资源文件夹生成而来</span><br><span class="line">tag_dir: tags #标签文件夹,默认是没有的需要使用hexo new page tags 自行创建</span><br><span class="line">archive_dir: archives #归档文件夹</span><br><span class="line">category_dir: categories #分类文件夹,默认是没有的需要使用hexo new page tags 自行创建</span><br><span class="line">code_dir: downloads&#x2F;code #Include code 文件夹</span><br><span class="line">i18n_dir: :lang #国际化（i18n）文件夹</span><br><span class="line">skip_render: #跳过指定文件的解析</span><br><span class="line"></span><br><span class="line"># Writing</span><br><span class="line">new_post_name: title.md # 新文章的文件名称</span><br><span class="line">default_layout: post #预设布局</span><br><span class="line">titlecase: false # 把标题转换为单词首字母大写</span><br><span class="line">external_link: </span><br><span class="line">    enable: true # 在新标签中打开链接</span><br><span class="line">    field: site</span><br><span class="line">    exclude: &#39;&#39; #排除文件</span><br><span class="line">filename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写</span><br><span class="line">render_drafts: false #显示草稿</span><br><span class="line">post_asset_folder: false #启动 Asset 文件夹，为 true 时，每次建立文件时，Hexo 会自动建立一个与文章同名的文件夹</span><br><span class="line">relative_link: false #把链接改为与根目录的相对位址</span><br><span class="line">future: true #显示未来的文章</span><br><span class="line">highlight: #代码块高亮,很多主题要求此项为false</span><br><span class="line">    enable: true</span><br><span class="line">    line_number: true</span><br><span class="line">    auto_detect: true</span><br><span class="line">    tab_replace:</span><br><span class="line"></span><br><span class="line"># Category &amp; Tag</span><br><span class="line">default_category: uncategorized #默认分类</span><br><span class="line">category_map: #分类别名</span><br><span class="line">tag_map: #标签别名</span><br><span class="line"></span><br><span class="line"># Date &#x2F; Time format</span><br><span class="line">date_format: YYYY-MM-DD #日期格式</span><br><span class="line">time_format: HH:mm:ss #时间格式</span><br><span class="line"></span><br><span class="line"># Pagination</span><br><span class="line">per_page: 10 #每页显示的文章量 (0关闭分页功能)</span><br><span class="line">pagination_dir: page #分页目录</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">theme: next #当前主题名称(本人使用的非默认主题)</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">deploy: #部署</span><br><span class="line">    type: git</span><br><span class="line">    repo: https:&#x2F;&#x2F;github.com&#x2F;username&#x2F;username.github.io.git #仓库地址</span><br><span class="line">    branch: master #分支名称</span><br></pre></td></tr></table></figure></li>
<li><p>打开看看, 在<code>git bash</code>中使用 <code>hexo g</code> 命令生成文章,<code>hexo s</code>命令启动服务,下面提示访问<a href="http://localhost:4000" target="_blank" rel="noopener">localhost:4000</a>,访问一下看到使用默认主题的网站  </p>
</li>
</ol>
<h1 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h1><p>  使用<code>hexo new post &lt;filename&gt;</code> 创建自己的第一篇文章<br>  找到source–&gt;_post,打开<code>&lt;filename&gt;.md</code><br>  <strong><em>更多<a href="https://hexo.io/zh-cn/docs/writing" target="_blank" rel="noopener">写作</a>用法</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 使用hexo+github pages建立静态blog</span><br><span class="line">date: 2020-01-14 19:32:51</span><br><span class="line">tags: [git,hexo]</span><br><span class="line">categories: hexo</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>  在date下面添加分类和标签,可选<br>  在—下面写正文内容,可以使用<code>&lt;!--more--&gt;</code>分割  </p>
<blockquote>
<p>比如:   </p>
</blockquote>
<pre><code>简介  
&lt;!--more--&gt;
正文  </code></pre><h1 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h1><p>hexo g生成<br>hexo s启动<br>打开浏览器,输入<a href="localhost:4000">localhost:4000</a>看看吧  </p>
<h1 id="部署到服务器"><a href="#部署到服务器" class="headerlink" title="部署到服务器"></a>部署到服务器</h1><p>  安装一键部署</p>
<blockquote>
<p>npm install hexo-deployer-git –save  </p>
</blockquote>
<p>  执行 <code>hexo clean</code>(可选,正常情况不需要)<br>  <code>hexo d</code> 部署到<code>&lt;username&gt;.github.io</code></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>  使用过程中遇到很多问题,目前都没有解决,<br>  比如有些主题莫名看不到tegs和categories仓库,最后选来选去只能使用next主题<br>  还有写modules(比如七牛云)安装之后即使你不启用你也得写配置  </p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
