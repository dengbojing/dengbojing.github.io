<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Effective-java-第四章学习笔记</title>
    <url>/2021/04/07/Effective-java-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>第三章: 类和接口</p>
<a id="more"></a>

<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>这章主要讲了类和接口的设计原则,如何设计除更健壮,更灵活的类和接口.</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="使类和成员的访问最小化以及在公有类中使用访问方法而非公有域"><a href="#使类和成员的访问最小化以及在公有类中使用访问方法而非公有域" class="headerlink" title="使类和成员的访问最小化以及在公有类中使用访问方法而非公有域"></a>使类和成员的访问最小化以及在公有类中使用访问方法而非公有域</h2><p>前面两条实质上讲的是一件事,就是不要暴露类的内部成员,如果是公有类(一般情况我们写的都是<code>public</code>的类)一定不能暴露内部的成员,而是使用<code>getter</code>和<code>setter</code>.<br>尽可能的降低内部成员的可访问性. 这么做的好处就是<code>封装</code>性比较强, 也灵活很多,如果将来想在类的成员上做限制,直接在<code>getter</code>或者<code>setter</code>上做改变就可以, 外部调用者完全感受不到变化.</p>
<h2 id="如果编写一个不可变的类"><a href="#如果编写一个不可变的类" class="headerlink" title="如果编写一个不可变的类"></a>如果编写一个不可变的类</h2><ol>
<li>不要提供任何会修改对象状态的方法–比如<code>setter</code></li>
<li>保证类不会被扩展–使用<code>final</code>修饰符或者<code>private</code>的构造器.</li>
<li>将所有的域(类的成员)都设置成<code>private final</code>的.</li>
<li>确保任何可变组件的互斥访问–就是如果类的成员是一个对象引用, 则保证这个引用不会被外部获取到.</li>
</ol>
<blockquote>
<p><code>functional</code>: 不改变当前实例, 而是创建一个返回一个新的实例的方法. 这种方法被称为<code>functional</code>. 这种方法的方法名都使用介词.</p>
</blockquote>
<h3 id="不可变对象的优点"><a href="#不可变对象的优点" class="headerlink" title="不可变对象的优点:"></a>不可变对象的优点:</h3><ol>
<li>不可变对象是线程安全的, 不要求同步.</li>
<li>不可变对象可以自由的共享, 甚至可以共享他们的内部信息.</li>
<li>不可变对象可以为其他对象提供构件.</li>
<li>不可变对象提供了原子性.</li>
</ol>
<h3 id="不可变对象的缺点"><a href="#不可变对象的缺点" class="headerlink" title="不可变对象的缺点"></a>不可变对象的缺点</h3><p>每一个不同的值都需要一个对象, 如果创建不可变对象代价太高, 那么可能会导致程序性能下降. 一般不可变对象都提供一个对应的可变的配套类,比如<code>String</code>和<code>StringBuilder</code>. </p>
<h2 id="组合-复合-优于继承"><a href="#组合-复合-优于继承" class="headerlink" title="组合(复合)优于继承"></a>组合(复合)优于继承</h2><ol>
<li>继承打破了封装性.子类依赖父类其中特定的功能细节,如果将来父类改变了,那么子类也会跟着发生相应的变化,往往这些变化不是子类自己能控制的. 除非父类是专门用来被继承的或者有很好的说明该如何继承该类, 否则最好使用组合.</li>
<li>如果A和B两者直接存在<code>is-a</code>的关系才应该使用继承, 在实现继承时候, 要反复的确定 B 在任何时候都是一个 A 类型. 如果不是, B 仅仅是使用了 A 的一个功能, 那么就应该使用组合模式. </li>
</ol>
<h2 id="要么设计继承并提供文档-要么禁止继承"><a href="#要么设计继承并提供文档-要么禁止继承" class="headerlink" title="要么设计继承并提供文档, 要么禁止继承"></a>要么设计继承并提供文档, 要么禁止继承</h2><p>这条其实是对于上面那条的补充说明, 上一条说如果继承了一个不是用来被继承的类,是一件很危险的事情, 可能导致封装性被破坏, 在设计一个被继承的类时, 要有良好的说明</p>
<ol>
<li>该类必须有说明可以被重写的方法的<code>自用性</code>–即类必须在文档中说明,在哪些情况下它会调用被重写的方法.</li>
<li>对于为了继承而设计的类, 必须在发布之前先编写子类对其进行测试.</li>
<li>构造器不可以调用可以被重写的方法.</li>
<li><code>clone</code>和<code>readObject</code> 方法也不能调用可以被重写方法.</li>
</ol>
<h2 id="接口优于抽象类"><a href="#接口优于抽象类" class="headerlink" title="接口优于抽象类"></a>接口优于抽象类</h2><p>如果是对实现类的规范和约束则应该使用抽象类, 如果想实现多继承则应该使用接口. 接口的可扩展性要优于继承.</p>
<h2 id="接口的使用"><a href="#接口的使用" class="headerlink" title="接口的使用"></a>接口的使用</h2><ol>
<li>为后代设计接口.</li>
<li>接口只用于定义类型.</li>
<li>不要使用常量接口. </li>
</ol>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>整章对于在写代码设计类的层次接口非常有用, 但是由于使用<code>spring</code>框架, 很多事情<code>spring</code>都帮你做了, 这些设计原则用到的机会不是非常多, 导致里面有很多东西看了似懂非懂, 所以以后还是要离开<code>spring</code>框架单独做一些非<code>web</code>项目, 这样才能有较深的感悟.</p>
]]></content>
      <tags>
        <tag>java, 读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective-java-第三章学习笔记</title>
    <url>/2021/03/08/Effective-java-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>第三章: 重写Object类中的几个方法</p>
<a id="more"></a>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>这一章主要讲的是Object类中的几个方法该如何重写.实际上本章内容没有在开发实践中并不会出现,一般开发人员都用<code>lombok</code>或者其他工具类实现了Object中的方法,很少遇到自己重写的情况,而且在正常逻辑上也不会违背文中所说的注意点.</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="重写equals方法"><a href="#重写equals方法" class="headerlink" title="重写equals方法"></a>重写equals方法</h2><h3 id="在一下3种情况不应该重写equals"><a href="#在一下3种情况不应该重写equals" class="headerlink" title="在一下3种情况不应该重写equals"></a>在一下3种情况不应该重写equals</h3><ol>
<li>该类不是一个值类,是代表活动实体的类,比如<code>Thread</code>.</li>
<li>该类没必要提供逻辑相等,比如单例类,只会产生一个实例,<code>Object</code>类提供的地址相等的<code>equals</code>方法已经足够;再比如一些工具类<code>xxxUtil</code>,<code>xxxxBuilder</code>等,实际上这些类有时候无法实例化,所以没必要重写<code>equals</code>方法</li>
<li>该类是私有的或者包级私有的,<strong>可以确保<code>equals</code>方法不会被调用.(这句才是重点)</strong></li>
</ol>
<h3 id="重写equals时遵循的规范"><a href="#重写equals时遵循的规范" class="headerlink" title="重写equals时遵循的规范"></a>重写equals时遵循的规范</h3><ol>
<li><code>自反性(reflexive)</code>: 对于任何非<code>null</code>的引用值<code>x</code>, <code>x.equals(x)</code>必须返回<code>true</code>.</li>
<li><code>对称性(symmetric)</code>: 对于任何非<code>null</code>的引用值<code>x</code>和<code>y</code>, 当且仅当<code>y.equals(x)</code>返回<code>true</code>, <code>x.equals(y)</code>必须返回<code>true</code>.</li>
<li><code>传递性(transitive)</code>: 对于任何非<code>null</code>的引用值<code>x,y,z</code>, 如果<code>x.equals(y)</code>返回<code>true</code>,<code>y.equals(z)</code>返回<code>true</code>, 那么<code>x.equalis(z)</code>也返回<code>true</code></li>
<li><code>一致性(consistent)</code>: 对于任何非<code>null</code>的引用值<code>x,y</code>,只要对象中的信息没有被修改过,那么多次调用<code>x.equals(y)</code>的结果必然一致.</li>
<li>任何对象<code>equals(null)</code>必然返回false.</li>
</ol>
<p>以上规范,看起来挺复杂,实际上属于一种自然而然的做法,在重写<code>equals</code>的时候,很自然的就做到了.最好的方法就是使用第三方库来重写<code>equals</code>省事,还不会出错,除非你有非常特别的理由要自己手动重写.</p>
<h3 id="重写equals时注意事项"><a href="#重写equals时注意事项" class="headerlink" title="重写equals时注意事项"></a>重写equals时注意事项</h3><ol>
<li>不要依赖不可靠资源,比如<code>java.net.URL</code>中主机<code>ip</code>地址的比较,可能会存在<code>host</code>不变但是<code>ip</code>变了.</li>
<li>优先比较最有可能不一致的字段,或者开销比较低的字段,最理想是二者兼备,有这些字段组成关键字段.</li>
<li>重写<code>equals</code>时总是重写<code>hashCode</code>方法.</li>
<li>不要让<code>equals</code>过于智能.</li>
</ol>
<h3 id="重写equals方法的步骤"><a href="#重写equals方法的步骤" class="headerlink" title="重写equals方法的步骤"></a>重写equals方法的步骤</h3><ol>
<li>使用==操作符检查对象引用是否相等. 如果是,那么是同一个对象,直接返回<code>true</code>.</li>
<li>使用<code>instanceOf</code>检查参数类型是否正确.</li>
<li>类型转换.(如果是<code>jdk 14</code>以上可以和上一步合并: <code>if(o instanceof X x){}</code>)</li>
<li>对该类型中的关键字段进行比较.如果是除浮点数之外的基本类型,直接用==判断,如果是对象递归使用<code>equals</code>,如果是浮点数(<code>float,double</code>)使用<code>Float.compare(param1,param2), Double.compare(param1,param2)</code>,原因是<code>float</code>和<code>double</code>中存在<code>Float.NaN,-0.0f</code> 这样的常量.</li>
</ol>
<p><strong>总结: 总之不要轻易的自己重写<code>equals</code>方法,在多数情况下并不需要,如果需要请使用第三方,如果还不满足在自己动手写.</strong></p>
<hr>
<h2 id="重写equals方法时重写hasCode方法"><a href="#重写equals方法时重写hasCode方法" class="headerlink" title="重写equals方法时重写hasCode方法"></a>重写equals方法时重写hasCode方法</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>如果两个对象<code>equals</code>, 那么他们必然具有相同的<code>hashCode</code>.  </li>
</ol>
<p><strong>为什么?</strong><br><strong>因为在使用<code>hashMap</code>等集合时, 如果相等的对象具有不同的<code>hashCode</code>,可能会放在不同的<code>bucket</code>中,这样导致<code>get</code>逻辑上相等的对象时, 会出现获取不到对象.</strong><br>2. 如果两个对象不<code>equals</code>, 但是他们可能具有相同的<code>hashCode</code>, 但是最好不要, 因为这样<code>HashMap</code>等依赖<code>hashCode</code>方法的集合类会变的性能非常低下,最好是不同的对象具有不同的<code>hashCode</code></p>
<h3 id="重写步骤"><a href="#重写步骤" class="headerlink" title="重写步骤"></a>重写步骤</h3><ol>
<li>定义一个<code>result</code>存储第一个关键字段的<code>hashCode</code>.</li>
<li>关键字段的<code>hashCode</code>的计算:<br> a. 若果字段是基本类型,则调用对应的包装类型的<code>hashCode(value)</code>方法,如: <code>Integer.hashCode(code)</code>.<br> b. 如果字段是对象引用,并且<code>equals</code>中使用到这个字段时, 则同样的递归的调用该字段的<code>hashCode</code>方法. 如果需要更复杂的比较, 则可以为这个字段计算一个<code>范式</code>,然后针对这个范式计算<code>hashCode</code>. 如果该字段是<code>null</code>则返回<code>0</code><br> c. 如果字段是一个数组,则逐个计算数组中的元素的<code>hashCode</code>,如果数组不重要,返回一个常量,但最好不是<code>0</code>.</li>
<li>根据前两步骤计算,合并除最后的<code>hashCode</code></li>
<li>完整示例: <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = Short.hashCode(param);</span><br><span class="line">    result = <span class="number">31</span> * result + Integer.hashCode(param1);</span><br><span class="line">    result = <span class="number">31</span> * result + Double.hashCode(param2);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用乘法使得<code>hashCode</code>依赖字段顺序,设想一下如果不用乘法那么<code>abc</code>和<code>bac</code>将会拥有相同的<code>hashCode</code>,这显然是不对的.<br>使用31这个数字书中给出的原因是: 因为它是一个奇素数,习惯上使用,可以使用移位和减法来优化乘法<code>31 * i == (i &lt;&lt; 5) - i</code>,而且虚拟机自动完成这一优化;如果想知道更多具体内容请参考<a href="https://stackoverflow.com/questions/299304/why-does-javas-hashcode-in-string-use-31-as-a-multiplier" target="_blank" rel="noopener">stackoverflow上的回答</a></p>
</blockquote>
</li>
</ol>
<hr>
<h2 id="重写toString方法"><a href="#重写toString方法" class="headerlink" title="重写toString方法"></a>重写toString方法</h2><p>该条主要作用是在日志或者输出对象时候,比较容易的读懂对象中的信息,书上说的有点啰嗦,最简单的方法是使用三方<code>json</code>库将对象直接按<code>json</code>输出.不建议自己手写,字段多了容易遗漏外加出错.</p>
<hr>
<h2 id="重写clone方法"><a href="#重写clone方法" class="headerlink" title="重写clone方法"></a>重写clone方法</h2><h3 id="通用约定-非必须"><a href="#通用约定-非必须" class="headerlink" title="通用约定(非必须)"></a>通用约定(非必须)</h3><ol>
<li>x.clone() != x;</li>
<li>x.clone().getClass() == x.getClass();</li>
<li>x.clone().equals(x);</li>
</ol>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol>
<li>调用<code>super.clone()</code>, 然后转换类型.</li>
<li>如果该类包含数组引用类型的字段, 并且是非<code>final</code>的, 那么调用该字段的<code>clone()</code>方法.</li>
<li>如果该类包含引用类型中的字段还包含其他引用类型,那么递归调用,进行深拷贝.</li>
<li>使用<code>构造拷贝器</code>–一个接收自身类型为参数的构造函数. 或者使用构造器静态工厂方法.</li>
</ol>
<blockquote>
<p>总结: 实际生产过程中, 很少遇到需要调用<code>clone</code>方法来获取对象.</p>
</blockquote>
<hr>
<h2 id="考虑实现comparable接口"><a href="#考虑实现comparable接口" class="headerlink" title="考虑实现comparable接口"></a>考虑实现comparable接口</h2><p>如果是在编写一个值类(value class)并且可能排序敏感,那么建议你实现<code>comparable</code>接口,这样当这个类的实例添加到集合里面的时候,便于搜索,分类,排序.  </p>
<h3 id="通用约定"><a href="#通用约定" class="headerlink" title="通用约定"></a>通用约定</h3><ol>
<li><code>sgn(x.compareTo(y)) == -sgn(y.compareTo(x))</code>,其中<code>sgn</code>为<code>signum</code>函数,根据表达式的值,返回<code>-1,0或者1</code>.</li>
<li>如果<code>x.compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0</code> 则 <code>x.compareTo(z) &gt; 0</code>.</li>
<li>如果<code>x.compareTo(y) == 9</code> 那么有<code>x.compareTo(z) == y.compareTo(z)</code>. </li>
<li>如果<code>x.compareTo(y) == 0</code> 那么他们最好是相等, 如果不等请注明.</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现该方法时,最好不要使用<code>&lt;, &gt;</code>符号.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(PhoneNumber pn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = Short.compare(<span class="keyword">this</span>.areaCode, pn.areaCode);</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">0</span>)&#123;</span><br><span class="line">        result = Short.compare(<span class="keyword">this</span>.prefix, pn.prefix);</span><br><span class="line">        <span class="keyword">if</span>(result == <span class="number">0</span>)&#123;</span><br><span class="line">            result = Short.compare(<span class="keyword">this</span>.lineNum, pn.lineNum);</span><br><span class="line">        &#125;</span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者使用<code>java 8</code>中<code>Comparator</code>中的函数式接口实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;PhoneNumber&gt; COMPARATOR = comparingInt(pn -&gt; pn.araeCode)</span><br><span class="line">                                                                     .thenComparingInt(pn -&gt; pn.prefix)</span><br><span class="line">                                                                     .thenCOmparingInt(pn -&gt; pn.lineNum);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(PhoneNumber pn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.COMPARATOR.compare(<span class="keyword">this</span>, pn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>实际开发过程中很少用到该章节知识, <code>equals, hasCode, toString</code>等方法都是用第三方类库实现, <code>comparable</code>接口, 在流式处理集合的时候可以手动指定比较器. 总之, 该章节内容,理论大于实践, 只有在很少的情况用到, 自己有特殊的需求时才会用到. </p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java, 读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective_java_第二章学习笔记</title>
    <url>/2021/03/03/Effective-java-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>第二章: 创建和销毁对像</p>
<a id="more"></a>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>第一章主要讲除了用构造函数之外,如何创建一个对象,以及他们之间的利弊</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><ol>
<li><p>使用静态工厂方法创建对象.<br> 在对象方法内部,或者使用一个单独的工具类来维护一些静态的创建该类的对象的方法.<br> 工具类(<strong>书中术语叫做伴生类</strong>)命名方式一般在该类的后面加<code>s</code>, 比如<code>Collection</code> 和 <code>Collections</code> , <code>Collector</code> 和 <code>Collectors</code><br> 工厂方法的命名方式一般有:<br> <code>from</code> 类型转换方法, 从一个对象中获取我们想要的类的对象,通常只有一个参数. 如:</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NewsBody newsbody = NewsBody.from(news);</span><br></pre></td></tr></table></figure>

<p> <code>of</code> 聚合方法,将多个参数聚合在一起, 如:  </p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NewsBody newsbody = NewsBody.of(news.getTitle(),news.getAuthor(),news.getReleaseDate());</span><br></pre></td></tr></table></figure>
<p> <code>valueOf</code> 功能和上面两个类似, 只是相对来说更加啰嗦, 如:</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NewsBody newsBody = NewsBody.valueOf(news);</span><br></pre></td></tr></table></figure>

<p> <code>instance</code> or <code>getInstance</code> 根据给定的参数(可选)来创建对象,但是不能保证该对象一定和参数所描述的对象一致, 如:  </p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NewsBody newsBody = NewsBody.instance(news); <span class="comment">// 可能newsbody中的author字段或者其他字段与参数news中的不一致</span></span><br></pre></td></tr></table></figure>
<p> <code>create</code> or <code>newInstance</code> 根据参数每次都返回一个新的对象, 如: </p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NewsBody newsBody = NewsBody.create(news);</span><br></pre></td></tr></table></figure>
<p> <code>get</code><em>Type</em> 功能和<code>getInstance</code>相同,只是该方法处于工具类中, 如<code>java nio2</code>中:  </p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileStore fs = Files.getFileStore(path);</span><br></pre></td></tr></table></figure>
<p> <code>news</code><em>Type</em> 功能和<code>newInstance</code>相同, 只是该方法处于工具类中, 如: </p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader br = Files.newBufferedReader(path);</span><br></pre></td></tr></table></figure>

<p> 静态工厂的优点:  </p>
<ul>
<li><p>除了上述通用的命名方式之外, 可以起一个见名知意的方法, 书中举例为<code>BigInteger</code>中获取素数的方法.</p>
</li>
<li><p>第二个优点是可以控制返回的实例,可以在第一次创建时候缓存起来,以便之后使用,经典案例就是<code>单例模式</code>和<code>享元模式(String采用的模式)</code>. 伪代码: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Elvis <span class="title">getInstance</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> INSTANCE;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSth</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>INSTANCE</code>是静态的, 所以在类加载时就会创建类的实例, 天然避免了多线程并发问题, 使用静态工厂方法获取该实例, 则每次都获取相同的实例.</p>
</li>
<li><p>第三个优点就是多态. 这个是面向对象三大特性中的重要特性. 使用静态工厂方法, 你可以返回任意一个子类的对象.书中讲述了<code>Collections</code>的由来, 但是在<code>java 8</code>之后, 接口是可以包含静态方法的,所以<code>伴生类</code>存在的理由就很薄弱.  </p>
</li>
<li><p>第四个优点是可以根据参数的不同, 静态工厂方法返不同类型的对象.(这一点理解比较模糊,感觉和上一条重复).</p>
</li>
<li><p>第五个优点在编写静态工厂方法时候, 方法返回对象所属的类, 不一定存在. 还是利用多态的特性. 书中举例<code>SPI(Service Provider Interface)</code>机制, 在编写<code>Driver.getConnection()</code> 具体的<code>Connection</code>实现类不一定存在, 由各大数据库厂商自己提供实现.  </p>
<p>静态工厂的缺点: </p>
</li>
<li><p>必须提供一个<code>public</code>或者<code>protected</code>的构造函数, 否则无法子类化. </p>
</li>
<li><p>第二个缺点是不好找到, 如果是在该类内部还好, 如果是工具类, 那么就不容易被发现. </p>
<p>扩展:  </p>
</li>
<li><p><code>SPI</code>主要是使用<code>ServiceLoader</code>加载位于<code>META-INF/services</code>下面配置的具体的实现类来完成服务. 具体角色如下:  </p>
<ul>
<li><p><code>Service Provider Interface</code> 服务提供者接口, 通常一种约定, 约定了实现了该接口的类会提供哪种服务.</p>
</li>
<li><p><code>Service Providers</code> 服务的具体提供者, 实现了<code>Service Provider Interface</code>.  并将该类全限定名称写在<code>META-INF/services</code>目录下以服务提供者接口命名的文件中. </p>
</li>
<li><p><code>ServiceLoader</code> 用来加载<code>META-INF/services</code>下所有配置的服务具体提供者的类. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServiceLoader&lt;T&gt; serviceLoader = ServiceLoader.load(服务提供者<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>遇见多参数构造函数时,考虑使用<code>Builder</code>模式.<br> 如果参数过多可以使用<code>重叠构造器</code>, 即构造器套构造器这种, 或者使用<code>javaBean</code>, 即<code>setXxx()</code>, 这两种方式来创建对象.<br> 第一种方法, 代码臃肿不好维护, 而且可读性也差, 如果参数多了就会不知道构造器里面参数是干什么的, 一般有思想的程序员都不会写出来这种代码.<br> 第二种方法我们在编码过程中经常使用,如: <code>news.setAuthor(&quot;dengbojing&quot;)</code>, <code>news.setTitle(&quot;xxxx&quot;)</code>, <code>news.setReleaseDate(new LocalDate())</code>, <code>news.setContent(&quot;xxxx&quot;)</code> 等等, 该方法弊端就是会出现在构造过程中出现对象状态不一致, 因为构造过程分为几个步骤(分别设置所有属性).<br> 此时使用<code>Builder</code>模式就很容易避免上述错误, 在<code>jdk</code>中其实有很多地方都是使用这种方法, 比如: </p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> httpClient = HttpClient.newBuilder()</span><br><span class="line">                .authenticator(Authenticator.getDefault())</span><br><span class="line">                .connectTimeout(Duration.ofSeconds(<span class="number">10</span>))</span><br><span class="line">                .cookieHandler(CookieHandler.getDefault())</span><br><span class="line">                .executor(Executors.newFixedThreadPool(<span class="number">2</span>))</span><br><span class="line">                .followRedirects(HttpClient.Redirect.NEVER)</span><br><span class="line">                .priority(<span class="number">1</span>)</span><br><span class="line">                .proxy(ProxySelector.getDefault())</span><br><span class="line">                .sslContext(SSLContext.getDefault())</span><br><span class="line">                .sslParameters(<span class="keyword">new</span> SSLParameters())</span><br><span class="line">                .version(HttpClient.Version.HTTP_2)</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure>
<p> 有现成<code>lombok</code>插件可以通过<code>@Builder</code>注解实现<code>Builder</code>模式, 方便快捷.<br> 简而言之, 就是如果类里面有很多参数时候, 使用<code>Builder</code> 就是一个很不错的额选择. </p>
</li>
<li><p>用私有构造器或者枚举类型来强化单例模式<br> 单例模式,老生常谈的话题, 具体衍生有<code>饱汉模式</code>, <code>饿汉模式</code>(翻译过来), <code>双重检测</code>等等专业名词,<br> 总结一句话: 单元素的枚举类型经常成为单例模式的最佳实践.  </p>
</li>
<li><p>通过<code>private</code>构造器来增强不可实例化的类<br> 该条主要针对工具类,包含一些列静态参数或者方法,实例化这些类无意义,所以应该采用私有的构造函数.</p>
</li>
<li><p>使用依赖注入代替硬编码<br> 依赖注入指的是在构造函数或者静态工厂方法中,传入参数来注入所需要的资源(如: <code>this.resource = recource</code>).其中需要注入的资源具有不可变特性.<br> 需要引用底层资源的类不适合使用静态工具类和单例类来实现. 因为这两种方式都不能主动实例化对象, 每次获取的都是同一个底层资源, 所以不适合.<br> 也不适合直接在这种类(需要依赖底层资源)中实例化需要的资源, 应该将这些资源或者资源工厂方法传递到构造函数或者静态工厂方法中, 通过这些来创建这种类</p>
</li>
</ol>
<ol start="6">
<li><p>避免创建不需要的对象</p>
<p> <code>String</code> 对象, 这种频繁使用的对象, 则应该避免创建而是直接使用字符串池中的对象.  简而言之就是不要显示创建.<br> 优先使用基本类型, 要避免自动拆箱装箱. </p>
</li>
</ol>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>剩下几条不是很重要,消除过期引用, 这个在源码里面可以看到, 就是将对象引用等于<code>null</code>; 不使用<code>finalizer</code>方法,这个方法从来都没用过,只在面试题见过; 使用<code>try-with-resource</code> 一般都会使用这种方式. </p>
]]></content>
      <categories>
        <category>java,读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java_11_new_http</title>
    <url>/2020/12/10/java-11-new-http/</url>
    <content><![CDATA[<p><code>java.net.http</code>模块使用</p>
<a id="more"></a>


<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>写代码的时候难免会远程调用别人的api,之前用<code>httpclient</code>,在接着是<code>okhttp</code>,也都是跟着项目上用的,其实<code>java 9</code>就出现了一个http模块,只是当时是孵化版本,<code>java 11</code>正式推出了.</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="主要类和接口"><a href="#主要类和接口" class="headerlink" title="主要类和接口"></a>主要类和接口</h2><ul>
<li>类<ul>
<li><code>java.net.http.HttpClient</code></li>
<li><code>java.net.http.HttpHeaders</code></li>
<li><code>java.net.http.HttpRequest</code></li>
<li><code>java.net.http.HttpRequest.BodyPublishers</code></li>
<li><code>java.net.http.HttpRequest.BodyHanler</code></li>
<li><code>java.net.http.HttpRequest.BodySubscribers</code></li>
</ul>
</li>
<li>接口<ul>
<li><code>java.net.http.HttpClient.Builder</code></li>
<li><code>java.net.http.HttpRequest.BodyPublisher</code></li>
<li><code>java.net.http.HttpRequest.Builder</code></li>
<li><code>java.net.http.HttpResponse&lt;T&gt;</code></li>
<li><code>java.net.http.HttpResponse.BodyHandler&lt;T&gt;</code></li>
<li><code>java.net.http.HttpResponse.BodySubscriber&lt;T&gt;</code></li>
<li><code>java.net.http.HttpResponse.PushPromiseHandler&lt;T&gt;</code></li>
<li><code>java.net.http.HttpResponse.ResponseInfo</code></li>
<li><code>java.net.http.WebSocket</code></li>
<li><code>java.net.http.WebSocket.Builder</code></li>
<li><code>java.net.http.WebSocket.Listener</code></li>
</ul>
</li>
</ul>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ol>
<li><p><code>jdk 9</code>之后都是使用模块化组织代码,所以创建一个模块化的项目让后引入<code>java.net.http</code>模块. </p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> com.dbj.httpClient&#123;</span><br><span class="line">    <span class="keyword">requires</span> java.net.http</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建<code>httpClient</code>  </p>
<blockquote>
<p>使用<code>builder</code>模式创建对象, 基本上该包下面所有的对象都使用<code>builder</code>模式创建对象, 这么做的好处参见<code>effective java</code>一书</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> httpClient = HttpClient.newBuilder()</span><br><span class="line">            .authenticator(<span class="keyword">new</span> BasicAuthenticator(<span class="string">"user"</span>, <span class="string">"password"</span>))</span><br><span class="line">            <span class="comment">//.authenticator(Authenticator.getDefault()</span></span><br><span class="line">            .connectTimeout(Duration.ofSeconds(<span class="number">10</span>))</span><br><span class="line">            .cookieHandler(CookieHandler.getDefault())</span><br><span class="line">            .executor(Executors.newFixedThreadPool(<span class="number">2</span>))</span><br><span class="line">            .followRedirects(HttpClient.Redirect.NEVER)</span><br><span class="line">            .priority(<span class="number">1</span>)</span><br><span class="line">            .proxy(ProxySelector.getDefault())</span><br><span class="line">            .sslContext(SSLContext.getDefault())</span><br><span class="line">            .sslParameters(<span class="keyword">new</span> SSLParameters())</span><br><span class="line">            .version(HttpClient.Version.HTTP_2)</span><br><span class="line">            .build();</span><br></pre></td></tr></table></figure>
<p> or  </p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> httpClient = HttpClient.newHttpClient();</span><br></pre></td></tr></table></figure>
<p> equivalent  </p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> httpCLient = HttpClient.newBuilder().build();</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>httpClient</code> 类似<code>String</code> 设计模式是不变的,所以没有提供方法改变创建时候的参数.  </li>
<li>如果使用<code>http2</code>创建链接,但是服务端不支持,那么会自动降级成为<code>http1.1</code>,如果没有指定,默认也是使用<code>http2</code>  </li>
<li><code>excutor()</code> 在使用异步请求时候使用,默认是使用线程池技术</li>
<li><code>connectionTimeout()</code> 默认没有超时时间  </li>
<li><code>priority()</code> 优先级,范围[1-256],不在此范围会抛出异常  </li>
<li><code>connectTimeout()</code> 链接超时设置,在设定的时间内没有连接上则抛出<code>HttpConnectTimeoutException</code>  </li>
<li><code>executor()</code> 用于异步任务执行,如果未指定,则会为每个<code>HttpClient</code>实例创建一个.</li>
<li><code>followRedirects()</code> 当服务器返回<code>30x</code>时,是否跳转,默认不跳转</li>
<li><code>authenticator()</code> 验证参数,<code>Authenticator.getDefault()</code>获取当前验证规则,可以使用<code>BasicAuthenticator</code>来传递用户名密码,也可以继承<code>Authenticator</code>实现自己的验证规则.  </li>
<li><code>proxy()</code> 是否使用代理. </li>
</ul>
</li>
<li><p>创建<code>HttpRequest</code> </p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> httpRequset = HttpRequest.newBuilder(URI.create(<span class="string">""</span>))</span><br><span class="line">            .header(<span class="string">"Content-Type"</span>,<span class="string">"application/json"</span>)</span><br><span class="line">            .header(<span class="string">"token"</span>,<span class="string">"faeaafwefeawgaer"</span>)</span><br><span class="line">            .timeout(Duration.of(<span class="number">10</span>, ChronoUnit.SECONDS))</span><br><span class="line">            .expectContinue(<span class="keyword">true</span>)</span><br><span class="line">            .POST(HttpRequest.BodyPublishers.ofString(<span class="string">""</span>))</span><br><span class="line">            .version(HttpClient.Version.HTTP_2)</span><br><span class="line">            .build();</span><br></pre></td></tr></table></figure>
<ul>
<li><code>uri()</code> 可以在<code>newBuidler()</code> 中指定请求地址,也可以调用<code>uri()</code>方法指定请求地址.两者效果是一样的  </li>
<li><code>header()</code> 效果与<code>setHeader()</code>相同,另有<code>headers()</code>批量设置请求头, 请求头键值对必须严格按照<a href="https://tools.ietf.org/html/rfc7230#section-3.2" target="_blank" rel="noopener">RFC7230-section-3.2</a>约定,否则抛出异常.</li>
<li><code>timeout()</code> 请求超时时间设置,超过设定时间未收到响应则抛出异常,如不限制会永远阻塞(等待)</li>
<li><code>POST()</code> <code>GET()</code> <code>DELETE()</code> <code>PUT()</code> 请求方法,或者使用<code>mehtod()</code>设置请求方法<br> 使用前后端分离时候往往前端会发送一次<code>options</code>请求来判断后端是否支持跨域,此时就可以使用<code>method(&quot;OPTIONS&quot;,BodyPublishers.noBody())</code><br> <code>BodyPublishers</code> 用于构建<code>BodyPublisher</code>的工具类,包含了一系列实用的构建请求体的方法,其中<code>BodyPublishers</code> 主要是调用<code>RequestPublishers</code> 来完成创建,<code>RequestPublishers</code> 中包含了很多<code>BodyPublisher</code>接口的实现</li>
</ul>
</li>
<li><p><code>HttpResponse</code><br> 同步请求</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> httpResponse = httpClient.send(requset,BodyHandlers.ofString());</span><br></pre></td></tr></table></figure>
<p> 异步请求  </p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> httpResponse = httpClient.sendAsync(httpRequest, HttpResponse.BodyHandlers.ofString())</span><br><span class="line">            .thenApply(stringHttpResponse -&gt; &#123;</span><br><span class="line">                System.out.println(stringHttpResponse.statusCode());</span><br><span class="line">                <span class="keyword">return</span> stringHttpResponse;</span><br><span class="line">            &#125;)</span><br><span class="line">            .thenApply(HttpResponse::body)</span><br><span class="line">            .thenAccept(System.out::println);</span><br></pre></td></tr></table></figure>
<p> or 批量请求接口</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> client = HttpClient.newHttpClient();</span><br><span class="line"></span><br><span class="line">List&lt;HttpRequest&gt; requests = paths.stream()</span><br><span class="line">    .map(path -&gt; <span class="string">"https://localhost:8443"</span> + path)</span><br><span class="line">    .map(URI::create)</span><br><span class="line">    .map(uri -&gt; HttpRequest.newBuilder(uri).build())</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;?&gt;[] responses = requests.stream()</span><br><span class="line">    .map(request -&gt; client.sendAsync(request, BodyHandlers.ofString())</span><br><span class="line">        .thenApply(HttpResponse::body)</span><br><span class="line">        .exceptionally(e -&gt; <span class="string">"Error: "</span> + e.getMessage())</span><br><span class="line">        .thenAccept(System.out::println))</span><br><span class="line">    .toArray(CompletableFuture&lt;?&gt;[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>异步请求返回一个<code>CompletableFuture&lt;HttpResponse&lt;T&gt;&gt;</code>,当有响应返回时,该对象后续回调将会被调用.异步请求使用创建<code>httpClient</code>时指定的<code>executor</code>来执行异步请求.</p>
</li>
<li><p><code>HttpResponse</code>为一个接口, 不能直接创建, 所有实例都是<code>httpClient</code>请求返回, 接口提供方法如下:</p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>T</td>
<td><code>body()</code></td>
<td>返回响应体</td>
</tr>
<tr>
<td>HttpHeaders</td>
<td><code>headers()</code></td>
<td>返回响应投</td>
</tr>
<tr>
<td>int</td>
<td><code>statusCode()</code></td>
<td>返回的状态码</td>
</tr>
<tr>
<td>HttpRequset</td>
<td><code>request()</code></td>
<td>返回对应的请求体</td>
</tr>
<tr>
<td>URI</td>
<td><code>uri()</code></td>
<td>返回请求地址</td>
</tr>
<tr>
<td>HttpClient.Version</td>
<td><code>version()</code></td>
<td>返回http请求协议版本</td>
</tr>
</tbody></table>
</li>
<li><p><code>BodyHandlers</code> 用于构建<code>BodyHandler</code>的工厂类.</p>
</li>
</ul>
</li>
</ol>
<h2 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h2><ol>
<li><p>JSON请求  </p>
<p> 发送请求时秩序指定<code>Content-Type</code>为<code>application/json</code>, 然后将对象转换为<code>json</code>字符串</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> httpRequest = HttpRequest.newBuilder(URI.create(<span class="string">""</span>))</span><br><span class="line">                .header(<span class="string">"content-type"</span>,<span class="string">"application/json"</span>)</span><br><span class="line">                .GET()</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure>

<p> 接受响应时,自定义<code>BodyHandler</code>将返回的<code>json</code>字符串转换为对象</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonHandler</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">HttpResponse</span>.<span class="title">BodyHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Gson gson;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonHandler</span><span class="params">(Class&lt;T&gt; type, Gson gson)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.gson = gson;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> HttpResponse.<span class="function">BodySubscriber&lt;T&gt; <span class="title">apply</span><span class="params">(HttpResponse.ResponseInfo responseInfo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  HttpResponse.BodySubscribers.mapping(HttpResponse.BodySubscribers.ofByteArray(),bytes -&gt; gson.fromJson(<span class="keyword">new</span> String(bytes),<span class="keyword">this</span>.type));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonHandlers</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">JsonHandlers</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">JsonHandler&lt;T&gt; <span class="title">ofType</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> of(<span class="keyword">new</span> Gson(), type);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">JsonHandler&lt;T&gt; <span class="title">of</span><span class="params">(Gson gson, Class&lt;T&gt; type)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JsonHandler&lt;T&gt;( type,gson);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 使用<code>client</code>发送请求,并接收响应.  </p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> client = HttpClient.newHttpClient(URI.create(<span class="string">"Http://localhost:8080"</span>));</span><br><span class="line"><span class="keyword">var</span> response = client.send(request, JsonHandler.JsonHandlers.ofType(UserBody<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line"><span class="keyword">var</span> userBody = response.body();</span><br></pre></td></tr></table></figure>
<p> // or  使用异步响应</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> task = client.sendAsync(request, JsonHandler.JsonHandlers.ofType(UserBody<span class="class">.<span class="keyword">class</span>))</span></span><br><span class="line">            .thenApply(HttpResponse::body)</span><br><span class="line">            .thenApply(UserBody::getName)</span><br><span class="line">            .thenAccept(System.out::println);</span><br><span class="line">task.get();<span class="comment">//测试方便输出结果.</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>x-www-form-urlencoded</code> 请求  </p>
<p> 这种请求类型是<code>form</code>表单的默认请求类型,另一种就是可以上传文件的<code>form-data</code>了,但是没有现成的类或者方法支持<code>x-www-form-urlencoded</code>请求,不过该请求投类型很好分析  </p>
<ul>
<li><p>将<code>form</code>表单里面的<code>name</code>和<code>value</code>用<code>=</code>链接,在把他们用<code>&amp;</code>符号链接起来,如果包含空格替换为<code>+</code>,如果有特殊符号,则转换为<code>ASCII HEX</code>值;如果包含中文字符,则转成<code>ASCII HEX</code>后在百分号编码.  </p>
</li>
<li><p>百分号编码: 汉字在<code>utf-8</code>字符集里面是占3个字节的,所以转换成16进制字符串就是占6个字节,每两个字节前面加一个百分号,就变成9个字节传递.  </p>
</li>
<li><p>如果是<code>GET</code>请求,那直接在<code>url</code>后<code>?</code>拼接.</p>
</li>
<li><p>如果是<code>POST</code>请求, 那就把拼接好的字符串放在<code>body</code>里面.</p>
</li>
<li><p>简单点就是用现成的库<code>urlencoded</code>, 这种库应该是大部分语言都自带的. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> HttpRequest.<span class="function">BodyPublisher <span class="title">ofXForm</span><span class="params">(Map&lt;Object,Object&gt; map)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    map.forEach((key, value) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (builder.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            builder.append(<span class="string">"&amp;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        builder.append(URLEncoder.encode(key.toString(), StandardCharsets.UTF_8));</span><br><span class="line">        builder.append(<span class="string">"="</span>);</span><br><span class="line">        builder.append(URLEncoder.encode(value.toString(), StandardCharsets.UTF_8));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> HttpRequest.BodyPublishers.ofString(builder.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>文件上传下载  </p>
<ul>
<li><p>下载  </p>
<p>下载很简单直接,有现成的方法可以使用.  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> client = HttpClient.newHttpClient();</span><br><span class="line"><span class="keyword">var</span> request = HttpRequest.newBuilder(URI.create(url)).build();</span><br><span class="line"><span class="keyword">var</span> file = Paths.get(<span class="string">"1.png"</span>);</span><br><span class="line"><span class="keyword">var</span> response = client.send(request,BodyHandlers.ofFile(file));</span><br></pre></td></tr></table></figure>
<p>该方法适合知道文件名称时使用.<br>or </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> client = HttpClient.newHttpClient();</span><br><span class="line"><span class="keyword">var</span> request = HttpRequset.newBuilder(URI.create(url)).build();</span><br><span class="line"><span class="keyword">var</span> file = Paths.get(<span class="string">"/usr/local/file"</span>);</span><br><span class="line"><span class="keyword">var</span> response = client.send(requset,BodyHandlers.ofFileDownload(file));</span><br></pre></td></tr></table></figure>
<p><code>ofFileDownload</code>属于比较常见的下载方式.  </p>
</li>
<li><p>上传</p>
<p>上传没有现成的方法,所以需要我们自定义一个<code>BodyPublishers.ofFile()</code>方法,然后请求头为<code>mutipart/form-data</code>发送请求  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> HttpRequest.<span class="function">BodyPublisher <span class="title">ofFile</span><span class="params">(Map&lt;Object,Object&gt; data,String boundary)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> byteArrays = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">byte</span>[]&gt;();</span><br><span class="line">    <span class="keyword">byte</span>[] separator = (<span class="string">"--"</span> + boundary + <span class="string">"\r\nContent-Disposition: form-data; name="</span>)</span><br><span class="line">            .getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : data.entrySet()) &#123;</span><br><span class="line">        byteArrays.add(separator);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() <span class="keyword">instanceof</span> Path) &#123;</span><br><span class="line">            <span class="keyword">var</span> path = (Path) entry.getValue();</span><br><span class="line">            String mimeType = Files.probeContentType(path);</span><br><span class="line">            byteArrays.add((<span class="string">"\""</span> + entry.getKey() + <span class="string">"\"; filename=\""</span> + path.getFileName()</span><br><span class="line">                    + <span class="string">"\"\r\nContent-Type: "</span> + mimeType + <span class="string">"\r\n\r\n"</span>).getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            byteArrays.add(Files.readAllBytes(path));</span><br><span class="line">            byteArrays.add(<span class="string">"\r\n"</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            byteArrays.add((<span class="string">"\""</span> + entry.getKey() + <span class="string">"\"\r\n\r\n"</span> + entry.getValue() + <span class="string">"\r\n"</span>)</span><br><span class="line">                    .getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    byteArrays.add((<span class="string">"--"</span> + boundary + <span class="string">"--"</span>).getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    <span class="keyword">return</span> HttpRequest.BodyPublishers.ofByteArrays(byteArrays);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Object,Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">data.put(<span class="string">"apikey"</span>, virusTotalApiKey);</span><br><span class="line">data.put(<span class="string">"file"</span>, localFile);</span><br><span class="line">String boundary = <span class="keyword">new</span> BigInteger(<span class="number">256</span>, <span class="keyword">new</span> Random()).toString();</span><br><span class="line"></span><br><span class="line">request = HttpRequest.newBuilder()</span><br><span class="line">          .header(<span class="string">"Content-Type"</span>, <span class="string">"multipart/form-data;boundary="</span> + boundary)</span><br><span class="line">          .POST(ofMimeMultipartData(data, boundary))</span><br><span class="line">          .uri(URI.create(url))</span><br><span class="line">          .build();</span><br><span class="line">HttpResponse&lt;String&gt; response = client.send(request, BodyHandlers.ofString());</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="高阶使用"><a href="#高阶使用" class="headerlink" title="高阶使用"></a>高阶使用</h2><ol>
<li><p>HTTP2 server push </p>
</li>
<li><p>WebSocket  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WebSocket webSocket = HttpClient.newHttpClient().newWebSocketBuilder().buildAsync(<span class="keyword">new</span> URI(<span class="string">"ws://localhost:8081/platform/device/gps"</span>), <span class="keyword">new</span> WebSocket.Listener() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> CompletionStage&lt;?&gt; onText(WebSocket webSocket,</span><br><span class="line">                                          CharSequence data, <span class="keyword">boolean</span> last) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             System.out.println(<span class="string">"onText: "</span> + data);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> WebSocket.Listener.<span class="keyword">super</span>.onText(webSocket, data, last);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(WebSocket webSocket)</span> </span>&#123;</span><br><span class="line">             System.out.println(<span class="string">"onOpen"</span>);</span><br><span class="line">             WebSocket.Listener.<span class="keyword">super</span>.onOpen(webSocket);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> CompletionStage&lt;?&gt; onClose(WebSocket webSocket, <span class="keyword">int</span> statusCode,</span><br><span class="line">                                           String reason) &#123;</span><br><span class="line">             System.out.println(<span class="string">"onClose: "</span> + statusCode + <span class="string">" "</span> + reason);</span><br><span class="line">             <span class="keyword">return</span> WebSocket.Listener.<span class="keyword">super</span>.onClose(webSocket, statusCode, reason);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;).join();</span><br><span class="line">     Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">     Message message = <span class="keyword">new</span> Message();</span><br><span class="line">     message.setFrom(<span class="string">"dbj"</span>);</span><br><span class="line">     message.setContent(<span class="string">"client data send"</span>);</span><br><span class="line">     message.setTo(<span class="string">"some one"</span>);</span><br><span class="line">     webSocket.sendText(gson.toJson(message),<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>其中<code>super.OnXxxx()</code>为固定句式, 其实就是调用<code>websocket.requset(1)</code>.固定调用.   </p>
</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java11</tag>
      </tags>
  </entry>
  <entry>
    <title>微信图片转换</title>
    <url>/2020/10/22/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>PC端微信图片转换</p>
<a id="more"></a>

<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>最近孩子去上早教班,老师在早教群里发了很多孩子的图片,我就想着把这些图片存起来,但是老师发一张我存一张这种模式对程序员来说是一种侮辱,所以我就想是不是存在了微信文件夹下面,一看果不其然,只是格式不是<code>jpg,png,gif</code>等,是<code>dat</code>格式,经过一番百度(ps:微信是国内的东西,所以还是百多搜索比较靠谱)终于找到了解码方法.特此记录.</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="微信文件目录"><a href="#微信文件目录" class="headerlink" title="微信文件目录"></a>微信文件目录</h2><p>微信的图片文件地址这个不难找,具体目录为${wechatFilesDir}/{your_wechat_id}/FileStroage/image,占位符代表微信文件存储目录(微信设置-&gt;文件管理)和自己微信的微信号.</p>
<h2 id="所需图片知识"><a href="#所需图片知识" class="headerlink" title="所需图片知识"></a>所需图片知识</h2><ul>
<li><p>jpg/jpeg<br>标识头: <code>0xff</code> <code>0xd8</code>  </p>
</li>
<li><p>png<br>标识头: <code>0x89</code> <code>0x50</code>  </p>
</li>
<li><p>gif<br>标识头: <code>0x47</code> <code>0x49</code></p>
</li>
</ul>
<p>当然还有其他的图片格式可以自行谷歌.</p>
<h2 id="微信-bat文件加密方式"><a href="#微信-bat文件加密方式" class="headerlink" title="微信.bat文件加密方式"></a>微信.bat文件加密方式</h2><p>定义一个key值,将图片转换为二进制流,然后每一位与这个key值进行异或(xor),得到新的byte值,然后写入.<br>所以我们反解就很明显了,假设图片为<code>jpg</code>,我们已知jpg图片前两位为<code>0xff</code>,<code>0xd8</code>,用<em>16进制</em>方式打开<code>.bat</code>文件,得到前两位为<code>x</code>,<code>x1</code>.只需<code>x^0xff</code>==<code>x^0xd8</code> 成立(因为<code>x=key^0xff</code>,<code>x1=key^0xd8</code>),那么这个图片就是jpg.  </p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>仅仅是一个示例,实际开发应当更严谨处理异常以及分支.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> base = <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">int</span> next = <span class="number">0xd8</span>;</span><br><span class="line">    <span class="keyword">int</span> pngBase = <span class="number">0x89</span>;</span><br><span class="line">    <span class="keyword">int</span> pngNext = <span class="number">0x50</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] bs = Files.readAllBytes(Paths.get(<span class="string">"D:\\WebChat\\WeChat Files\\wxid_sxelod34kou321\\FileStorage\\Image\\2020-06\\0ce7898a35eb2a7ac9045480419e5902.dat"</span>));</span><br><span class="line">    <span class="keyword">int</span> firstByte = bs[<span class="number">0</span>] &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">int</span> secondByte = bs[<span class="number">1</span>] &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">int</span> key = base ^ firstByte;</span><br><span class="line">    String suffix = <span class="string">".jpg"</span>;</span><br><span class="line">    <span class="keyword">if</span>((pngBase ^ firstByte) == (pngNext ^ secondByte))&#123;</span><br><span class="line">        key = pngBase ^ firstByte;</span><br><span class="line">        suffix = <span class="string">".png"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>(OutputStream os = Files.newOutputStream(Paths.get(<span class="string">"D:\\123"</span>+suffix),StandardOpenOption.CREATE))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">byte</span> b : bs)&#123;</span><br><span class="line">            os.write(b ^ key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>通过对比发现一个问题,<code>key</code>值在我公司电脑和家里电脑完全相同.也就是说这个算<code>key</code>的过程应该是拿微信里面的一个固定信息算出来的.这个等在后面在研究一下具体是怎么算的.</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Naming Convention--命名规范</title>
    <url>/2020/09/21/Naming-Convention-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p>译文: <a href="https://blog.usejournal.com/clean-code-best-practice-for-naming-part-1-f67ebe8c0894" target="_blank" rel="noopener">Clean Code (Best practice for naming) Part 1</a></p>
<a id="more"></a>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>  在代码开发过程中好的变量命名习惯是非常重要的,如果是i,j,k,l的命名,我相信不用同组小伙伴打死你,几个月以后的自己都想打死自己.所以,一个好的命名规范尤为重要,不仅要让编译器看懂,阅读代码的人更要是见名知意.</p>
<hr>
<h1 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h1><p>  <a href="https://blog.usejournal.com/clean-code-best-practice-for-naming-part-1-f67ebe8c0894" target="_blank" rel="noopener">原文地址</a>  </p>
<p>  在你写代码时候,你觉得你是为谁在写?第一想法是我写代码是为了编译器能编译.想法是对的,编译器应该能’看懂’你得代码并且能编译执行这些代码.那有没有其他的读者阅读你的代码呢?在专业的开发中,你开发代码并不是隔离式的,你处在一个团队里面,并且团队里面可能有很多其他成员,所以你写的代码应该能让这些团队成员看懂.大概率会发生你需要重新审视这些代码来了解这些代码是什么,怎么工作的,为什么会这么写.大概率会发生在将来你无法回答这些问题的时候正好有其他人需要你这段代码.四个不同的组,最后面的3个组有共同点是非常重要的.所以我们需要确保我们写出的代码能被人类读懂.这就是代码整洁之道.只有遵循这些准则,才能确保你写的代码能被将来阅读它的人看懂,或者你的同组小伙伴code review的时候看懂,或者你自己将来做bug fix是看懂,或者你得交接人能添加一个新的功能.  </p>
<hr>
<h1 id="怎么样才是整洁的代码"><a href="#怎么样才是整洁的代码" class="headerlink" title="怎么样才是整洁的代码"></a>怎么样才是整洁的代码</h1><ul>
<li>代码能被机器编译以及能被人类看懂</li>
<li>代码名称简单易懂</li>
<li>格式一致,格式影响代码的可读性</li>
<li>容易改善,比凌乱的代码容易修复</li>
<li>能清晰的表达出其意图.写代码的人能明白这段代码是做什么的</li>
</ul>
<p>如下代码,该方法名称不够整洁规范,以至于无法说明方法的意图,这种情况你就需要一行一行的阅读代码才能了解他是做是你么的: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun s(arr: IntArray) &#123;</span><br><span class="line">	val n &#x3D; arr.size</span><br><span class="line">	for(i in 0 until n-1) &#123;</span><br><span class="line">		for (j in 0 until n-i-1)</span><br><span class="line">			if (arr[j] &gt; arr[j+1] &#123;</span><br><span class="line">				val temp &#x3D; arr[j]</span><br><span class="line">				arr[j] &#x3D; arr[j+1]</span><br><span class="line">				arr[j] &#x3D; temp</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整洁规范的代码: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun buuleSort(array: IntArray) &#123;</span><br><span class="line">	for (index in 0 until arraySize - 1) &#123;</span><br><span class="line">        for (pointerIndex in 0 until arraySize - index - 1)</span><br><span class="line">            if (array[pointerIndex] &gt; array[pointerIndex + 1]) &#123;</span><br><span class="line">                val temp &#x3D; array[pointerIndex]</span><br><span class="line">                array[pointerIndex] &#x3D; array[pointerIndex + 1]</span><br><span class="line">                array[pointerIndex + 1] &#x3D; temp</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样你能一眼就看出来这个方法的意图,对,就是冒泡排序.</p>
<hr>
<h1 id="类命名规范"><a href="#类命名规范" class="headerlink" title="类命名规范"></a>类命名规范</h1><ul>
<li>类名应该使用名词. $#x1F47D</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Performer</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Performance</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>避免动词形式的类名.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Perform</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Performed</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Performing</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用形容词前缀表示时态.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActivePerformance</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PastPerformer</span> </span>&#123;&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<ul>
<li><p>类名不能仅使用形容词.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Huge</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Small</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fast</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slow</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用形容词前缀加名词作为类名.</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallPerformance</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PastPerformer</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>避免使用模糊前缀.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPerformer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APerformer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThePerformer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThisPerformer</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>避免使用单个字母作为类名.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">L</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>避免使用单字母前缀类名.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPerformer</span>() </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TPerformer</span>() </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>避免使用<strong>首字母缩写词</strong>大写.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTTPAPIPerformer</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在单词连接处首字母大写(驼峰命名).</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpApiPerformer</span> </span>&#123;&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<ul>
<li>避免使用缩略词.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Perf</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>避免使用复数作为类名.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">performers</span> </span>&#123;&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<ul>
<li>使用复数作为集合类的类名.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Currencies</span> </span>&#123;</span><br><span class="line">...<span class="comment">// contain map of Currencies, and romat price for each currency</span></span><br><span class="line"></span><br><span class="line">	val currencyMap = mapOf(</span><br><span class="line">		Pair(RUSSIAN_RUBLE, <span class="string">"\u20BD"</span>),</span><br><span class="line">		Pair(UNITED_STATES_DOLLAR, <span class="string">"\$"</span>)</span><br><span class="line">	)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="整洁规范的方法名称"><a href="#整洁规范的方法名称" class="headerlink" title="整洁规范的方法名称"></a>整洁规范的方法名称</h1><ul>
<li>使用一般现在时作为方法名称.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">open</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">perform</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">close</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validate</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>避免使用动名词(现在进行时).</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">performing</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validating</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">opening</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closing</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>避免使用一般过去时.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">performed</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">opened</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closed</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validated</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>is</code>作为动名词前缀.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isRunning</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isClosing</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isServint</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>has</code>作为一般过去时前缀.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasPerformed</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasOpened</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasClosed</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasValidated</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在应用系统中保持所有的命名标准和转换一致.</li>
<li>如果语言支持驼峰命名,则应该使用驼峰命名.<br>驼峰命名的准确率比下划线命名准去率要高(高出51.5%的几率)  </li>
</ul>
<hr>
<h1 id="整洁规范的变量命名"><a href="#整洁规范的变量命名" class="headerlink" title="整洁规范的变量命名"></a>整洁规范的变量命名</h1><ul>
<li>使用单数名词作为原始类型和对象类型的变量名]</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br></pre></td></tr></table></figure>

<ul>
<li>使用复数名字作为数组和集合的变量名</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] names = <span class="keyword">new</span> String[](<span class="string">"Alex"</span>, <span class="string">"Ali"</span>, <span class="string">"Aesop"</span>&#125;;</span><br><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>避免使用<strong>动词</strong>作为原始类型的变量名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> create = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> perform = <span class="number">12</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<strong>名词</strong>作为原始类型的变量名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> performanceCode = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">boolean</span> creationEnabled = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>避免使用单个单词作为变量名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> s = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用有意义的变量名</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">9</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>避免使用容易引起混淆的缩写和简写.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String dbsqlSelAllNames = <span class="string">"select * from names"</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用大写分割变量名,并将简写展开</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String dbSqlSelectAllNames = <span class="string">"select * from names"</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要使用无用的复杂前缀,如<strong>匈牙利前缀</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String f_strFirstName = <span class="string">"Jefferson"</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>避免使用数据类型最为变量名后缀</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String lastNameString = <span class="string">"Amaya"</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="整洁规范的参数名"><a href="#整洁规范的参数名" class="headerlink" title="整洁规范的参数名"></a>整洁规范的参数名</h1><ul>
<li>命名参数包含单个值时,使用单数名词</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>命名参数包含多个值时,使用复数名词</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(List&lt;Integer&gt; values)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> values.stream().collect(Collectors.summarizingInt(Integer::intValue)).getSum();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>避免使用单个字母作为参数名称</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i+j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>避免使用简写作为参数名</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(String FSP)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数首字母不应该大写</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">random</span><span class="params">(<span class="keyword">int</span> SeedGenerator)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>避免使用难懂的前缀</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persistName</span><span class="params">(String sName)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="整洁规范的常量名"><a href="#整洁规范的常量名" class="headerlink" title="整洁规范的常量名"></a>整洁规范的常量名</h1><ul>
<li>常量名所有的字母都应该大写.</li>
<li>使用单数名词作为原始类型常量命名.</li>
<li>使用复数名词作为集合常量命名.</li>
<li>避免使用单字母和简写.</li>
<li>确保<strong>首字母缩写词</strong>之间的分割.</li>
</ul>
<hr>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这些规范是根据语言来定,对于其他语言可能有所变化</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>how_to_write_good_tests</title>
    <url>/2020/06/04/how-to-write-good-tests/</url>
    <content><![CDATA[<p>译文: <a href="https://github.com/mockito/mockito/wiki/How-to-write-good-tests" target="_blank" rel="noopener">How to write good tests</a></p>
<a id="more"></a>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>  代码测试是一件非常重要的工作,在之前的工作中总是找各种借口(时间不够,写起来太繁琐,有些场景无法测试)等等原因做的不够完善.有时甚至不做,无心之中发现一篇非常好的代码测试文章.花些时间来翻译一下,提高一下英文水平,顺便也学习一下正经的代码测试该是什么样的.</p>
<hr>
<h1 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h1><p>  <a href="https://github.com/mockito/mockito/wiki/How-to-write-good-tests" target="_blank" rel="noopener">原文地址</a></p>
<p>  为我们的软件定制一个测试用例是件好事,但是实际上,一个<strong>好的</strong>的测试用例也是非常重要的.</p>
<p>  遵循一些固有的原则来热爱测试代码 </p>
<hr>
<h2 id="保持测试代码简洁和可读"><a href="#保持测试代码简洁和可读" class="headerlink" title="保持测试代码简洁和可读"></a>保持测试代码简洁和可读</h2><p>  要做到这一点,需要像对生产代码那样进行<em>无情的重构</em>.否则,让事情发展下去测试代码就会变成恐怖的<code>祖传代码</code>.如果测试代码不能轻松重构,那么意味着生产代码也不能重构,从而导致<code>祖传代码</code>.<strong>总是要勇于重构.</strong>  </p>
<hr>
<h2 id="避免编码重复"><a href="#避免编码重复" class="headerlink" title="避免编码重复"></a>避免编码重复</h2><p>  例如, 测试代码与parser使用完全相同的<code>正则表达式</code>来生成内容.  </p>
<p>  通常来说人们不愿意重复测试与代码的逻辑,所以在测试中重复<code>正则表达式</code>或者其他代码是不可取的.设想以下测试情况,输入/输出结果<code>(f(input)-&gt;(output))</code>,例如,如果代码要处理模版,不要添加固定值,相反,应该根据计算结果添加值. </p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// use</span></span><br><span class="line">Assertions.assertThat(processTemplate(<span class="string">"param1"</span>, <span class="string">"param2"</span>)).isEqualTo(<span class="string">"this is 'param1', and this is 'param2'"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// instead of</span></span><br><span class="line">Assertions.assertThat(processTemplate(<span class="string">"param1"</span>, <span class="string">"param2"</span>)).isEqualTo(String.format(<span class="string">"this is '%s', and this is '%s'"</span>, param1, param2));</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="覆盖尽可能多的情况-来显示正向的用例-特别是错误的代码位置"><a href="#覆盖尽可能多的情况-来显示正向的用例-特别是错误的代码位置" class="headerlink" title="覆盖尽可能多的情况,来显示正向的用例,特别是错误的代码位置"></a>覆盖尽可能多的情况,来显示正向的用例,特别是错误的代码位置</h2><p>  通常使用<code>测试驱动开发(TDD--Test Dirven Development)</code>是最佳的实践方式. 使用<code>TDD</code>人们能在设计阶段就找出什么地方会被破坏. 不要认为为一个小的代码片段编写简单的测试不值得，你永远不知道什么时候、因为什么而修改这段代码.</p>
<p>  可与使用PIT(<a href="http://pitest.org/" target="_blank" rel="noopener">突变检测系统</a>)来对测试代码的有效性进行检测. </p>
<hr>
<h2 id="不要Mock一个你不拥有的类型"><a href="#不要Mock一个你不拥有的类型" class="headerlink" title="不要Mock一个你不拥有的类型"></a>不要Mock一个你不拥有的类型</h2><p>  这并非一条硬性规定,但是如果不遵循该条规定会有影响(很可能会有). </p>
<blockquote>
<p><code>TDD</code>的设计方面和测试方面同样重要.在模拟外部API时,无法使用测试来驱动设计,该API属于其他人;因此第三方也将可以更改API的方法签名和行为. </p>
</blockquote>
<ol>
<li><p>设想一下代码mocks了一个第三方库,在更新了第三方库之后,三方库的逻辑可能改变了一点,但是测试代码依然能够执行成功,因为他被mock了.所以在这之后,所有的事情看起来很美好,构建也成功了,但是软件部署到正式环境–爆炸! </p>
</li>
<li><p>这也可能导致当前的设计和第三方库不够松耦合. </p>
</li>
<li><p>另一个问是第三方库可能非常复杂需要mock许多东西才能运行,这就导致了大量的特定测试和复杂的测试装置, 而这本身就损害了简洁性和可读性的目标.或者由于模拟外部系统的复杂性而没有充分覆盖代码的测试. </p>
<p>相反,最常见的方式是创建一个第三方库的<code>warpper</code>来包装他们,不过应该注意<code>抽象泄漏</code>(<a href="https://zhuanlan.zhihu.com/p/26803553" target="_blank" rel="noopener">什么是abstraction leakage?</a>)的风险,因为太多的底层API,概念或者异常超过了<code>warpper</code>的边界.为了验证第三方提供API的可用性,请使用<code>集成测试</code>,并尽可能的是它们简洁可读. </p>
<p>下面是其他人在mock了非他所有的类型库遇到的痛苦和总结的经验: </p>
</li>
</ol>
<ul>
<li><a href="http://davesquared.net/2011/04/dont-mock-types-you-dont-own.html" target="_blank" rel="noopener">http://davesquared.net/2011/04/dont-mock-types-you-dont-own.html</a></li>
<li><a href="http://www.markhneedham.com/blog/2009/12/13/tdd-only-mock-types-you-own" target="_blank" rel="noopener">http://www.markhneedham.com/blog/2009/12/13/tdd-only-mock-types-you-own</a></li>
<li><a href="http://blog.8thlight.com/eric-smith/2011/10/27/thats-not-yours.html" target="_blank" rel="noopener">http://blog.8thlight.com/eric-smith/2011/10/27/thats-not-yours.html</a></li>
<li><a href="http://stackoverflow.com/questions/1906344/should-you-only-mock-types-you-own" target="_blank" rel="noopener">http://stackoverflow.com/questions/1906344/should-you-only-mock-types-you-own</a></li>
</ul>
<hr>
<h2 id="反模式-Mock一切"><a href="#反模式-Mock一切" class="headerlink" title="反模式: Mock一切"></a>反模式: Mock一切</h2><p>  如果所有的代码都mock了,那么我们怎么测试业务代码?不要害怕不使用Mock的方法. </p>
<hr>
<h2 id="不要Mock值对象"><a href="#不要Mock值对象" class="headerlink" title="不要Mock值对象"></a>不要Mock值对象</h2><p>  为什么会有人要这么做呢? </p>
<blockquote>
<p>因为实例化一个对象非常痛苦? =&gt; 不是一个很好的理由</p>
</blockquote>
<p>  如果创建一个对象非常困难,那么这是代码需要严重重构的一个信号.一种可行的方法就是为你的<code>值对象</code>构造一个<code>builder</code>(构造者模式)–有很多工具可以使用比如<code>IDE 插件</code>,<code>Lombok</code>等等. 还可以在测试环境中创建有意义的工厂方法.<br>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerCreations</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Customer <span class="title">customer_with_a_single_item_in_the_basket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// long init sequence</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  <a href="https://github.com/mockito" target="_blank" rel="noopener"><code>Mockito</code></a>更加关注对象交互,这也是<code>面向对象</code>的重要要素. </p>
<hr>
<h2 id="原文-推荐阅读Growing-Object-Oriented-Software-Guided-by-Tests"><a href="#原文-推荐阅读Growing-Object-Oriented-Software-Guided-by-Tests" class="headerlink" title="(原文)推荐阅读Growing Object Oriented Software Guided by Tests"></a>(原文)推荐阅读<a href="https://book.douban.com/subject/4156589/" target="_blank" rel="noopener"><code>Growing Object Oriented Software Guided by Tests</code></a></h2><p>必读,这本书阐释了功能完整的应用程序在从无到有过程中, 开发的许多方面以及如何在项目生命周期的各个阶段实现测试.</p>
<p>如果遇到一些不理解不确定的事情,可以发邮件给作者.</p>
]]></content>
      <tags>
        <tag>mockito</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-network</title>
    <url>/2020/03/13/docker-network/</url>
    <content><![CDATA[<p>docker-network学习</p>
<a id="more"></a>

<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>阶段性的记录一下docker学习,docker-network里面还有很多问题很搞明白,亟待解决.</p>
<blockquote>
<p>以下操作都是基于<code>docker desktop for windows</code>的<code>linux container</code>模式下</p>
</blockquote>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ol>
<li><p><code>docker</code> 官方有5种网络模式,<code>none,bridge,macvlan,host,overlay</code>.  </p>
<p> 1.1 <code>none</code> 模式,参数 <code>--network=none</code>,无网络模式,这种模式一般很少用,官方说法是和自定义网络驱动时使用.  </p>
<p> 1.2 <code>birdge</code> 模式,参数 <code>--network ${bridge_name}</code>.该模式是默认模式,在安装<code>docker</code>会创建一个默认的<code>docker0</code>的linux网桥,如果启动容器时不指定网络,就会默认连接到<code>docker0</code>网桥   </p>
<blockquote>
<p><code>docker desktop for windows</code>看不见<code>docker0</code>,这是因为,<code>docker desktop for windows</code>实际上是把Docker装在Hyper-v虚拟机上,打开Hyper-v虚拟机管理,可以看到<code>DockerDesktopVM</code>这个虚拟机,Docker实际是运行在这个里面,而<code>docker0</code>就在这个里面,但是你如果连接这个虚拟机,发现连接不上.  </p>
</blockquote>
<p> 1.3 <code>host</code> 模式,参数<code>--network=host</code>,该模式下,容器和宿主机共用一个网络,在指定<code>--privileged=true</code> 时候,如果你不小心修改了网络参数,那么就会造成不必要的麻烦,所以一般不推荐这中做法,上面说到<code>docker desktop for windows</code> 无法查看虚拟机里面的<code>docker0</code>网桥,此时如果你以<code>--network=host</code>启动一个容器,此时你就可以执行<code>ifconfig</code>看到<code>docker0</code>网桥.    </p>
<blockquote>
<p>另一个查看方式<code>docker run -it --rm --privileged --pid=host justincormack/nsenter1</code>,启动之后,执行 <code>ifconfig</code>,指定 <code>--pid=host</code> 参数就是说,让当前启动的容器可以看到宿主机上所有的进程.  </p>
</blockquote>
<p> 1.4 <code>overlay</code> 模式, 参数 <code>network=container:${conatiner_id}</code>,该模式下,容器1和容器2共用一个网络.  </p>
<p> 1.5 <code>macvlan</code> 指定网络的mac地址.</p>
</li>
</ol>
<h1 id="实战bridge模式"><a href="#实战bridge模式" class="headerlink" title="实战bridge模式"></a>实战<code>bridge</code>模式</h1><ol>
<li><p><code>docker network ls</code>查看网络,<br><img src="https://i.loli.net/2020/08/04/otAxfl6vescaw5j.png" alt="docker-network-ls.png"><br>可以看到上面讲到的3种类型的网络,至于<code>overlay</code>呢,是需要依赖别的容器,所以取决与别的容器的网络模式,主要学习一下桥接模式的内容.  </p>
</li>
<li><p><code>bridge</code> 网桥模式的原理, 当创建一个容器的时候,<code>Docker</code> 会创建两个网络模块,一个是在容器里面叫<code>eth0</code>, 另一个则在宿主机里面,名字为<code>vethxxxx</code>,<code>Docker</code> 这个网络模块桥街道容器里面的<code>eth0</code>.<br> 2.1 首先我们以<code>bridge</code>启动一个<code>ubuntu</code> 容器,执行: <code>docker run  -ti --rm ubuntu:14.04 bash</code>, 启动一个一次性容器并进入<br> 2.2  在容器中执行<code>ifconfig</code>, 看到如下图所示:<br> <img src="https://i.loli.net/2020/08/04/VYBJ4Imwhkv6Xcj.png" alt="Docker-ifconfig.png"><br> <code>lo</code>: loopback 回环网络接口,也就是执行<code>localhost</code>或者<code>127.0.0.1</code>时候会走这个网络接口<br> <code>eth0</code>: 所有来自外部的流量都会通过这个网络接口  </p>
<p> 2.2 新开一个终端窗口,执行<code>docker run -it --rm --privileged --pid=host justincormack/nsenter1</code> , 进入容器之后,执行<code>ifconfig</code> 可以看到如图所示:<br> <img src="https://i.loli.net/2020/08/04/uMSpOI8qr3cR7VH.png" alt="docker-host-ifconfig.png"><br> 其中一个<code>vethxxx</code>是桥接到上面<code>ubuntu</code> 容器的网络接口,另一个是当前这个容器的网络接口(因为当前网络没有指定网络模式,所以以默认桥接模式启动,所以也会给当前容器创建一个网络接口).  </p>
</li>
<li><p>自定义网桥,之前使用<code>docker-compose</code> 创建了一个<code>compose</code>, 里面包含了一个<code>gateway</code>和一个<code>zookeeper</code>, 里面还定义了一个<code>network</code> ,让两个容器能够以容器名称相互访问, 了解了<code>docker network</code>之后,其实里面<code>network</code> 节点就是创建了一个<code>bridge</code> 网桥, 此时容器就可以通过名称相互访问, 官方名称叫 <code>automatic service discovery</code> 服务自动发现(瞎鸡巴翻译的).<br> 3.1 执行<code>docker network create -d bridge my-network</code>创建一个<code>bridge</code> 类型网络, 执行<code>docker inspect my-network</code> 看一下里面都有什么,  如图:<br> <img src="https://i.loli.net/2020/08/04/5F4cn2ah6VtJs9H.png" alt="docker-network-inspect-my-network.png"><br> 可以看到,子网掩码是<code>172,19.0.0/16</code>,网关是<code>172,19.0.1</code>,可以使用<code>--subnet=192.168.0.0/16</code> 来指定子网掩码,另外还可以使用<code>--gateway=192.168.0.1</code> 指定网关, <code>--ip-range=192.168.2.0/25</code>指定ip范围  </p>
<p> 3.2 最好是指定子网掩码,免得网络冲突.如果不指定网关,会从地址范围内自动选择一个出来作为网关,目前测试结论默认是xxx.xxx.xxx.1.  </p>
</li>
<li><p>使用<code>docker run --network=my-network</code> 来启动一个容器,执行ifconfig:<br><img src="https://i.loli.net/2020/08/04/uUfES7oBhPpYskj.png" alt="docker-run-network-my-network.png"><br>可以看到此时ip地址为我们创建的桥接网络借口的ip地址范围  </p>
</li>
<li><p>一个容器可以同时连接两个网络,使用<code>docker network connect ${networkid|networkname} ${containerid|containername}</code>, 如图:<br><img src="https://i.loli.net/2020/08/04/9aZx65RWMFXbq1Y.png" alt="docker-network-connect.png"><br>会有两个网络接口一个<code>eth0</code>,另一个<code>eth1</code>, 这样该容器就可以同时访问两个网路  </p>
</li>
<li><p><code>docker network disconnect ${networkid|networkname} ${containerid|containername}</code> 取消容器和网络的链接  </p>
</li>
<li><p><code>--icc</code>高级参数, 如果网络该参数为禁止,则两个容器之间是无法访问的.  </p>
</li>
</ol>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>网络这块真的是比较重要,也比较难的一块,还可以创建<code>overlay</code>类型的网络,有待研究.官方说法生产环境最好不要使用默认的<code>docker0</code>网桥,所以使用<code>docker-compose</code>管理容器还是一个比较好的方式.或者努力学习k8s吧.</p>
<blockquote>
<p>积土成山,风雨兴焉;积水成,渊蛟龙生</p>
</blockquote>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-compose</title>
    <url>/2020/02/11/docker-compose/</url>
    <content><![CDATA[<p>what? 扫把独立日? </p>
<a id="more"></a>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>使用gradle插件构建镜像和docker-compose连接容器</p>
<blockquote>
<h1 id="Talk-is-cheap-show-me-the-code"><a href="#Talk-is-cheap-show-me-the-code" class="headerlink" title="Talk is cheap, show me the code"></a>Talk is cheap, show me the code</h1></blockquote>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>打开docker远程访问端口,<code>docker desktop for windows</code> GUI 界面有一个<code>expose daemon on tcp://localhost:2375</code>, 只需要勾选,然后重启就行;当然这个是提供一个loopback的访问,实际上你并没有真正的暴露一个局域网或者广域网访问的端口,不过对于<code>docker-gradle</code> 使用已经足够,如果非要提供一个远程访问端口请参考<a href="https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-docker/configure-docker-daemon" target="_blank" rel="noopener">微软文档</a>.<br>操作很简单就是在 <code>C:\ProgramData\Docker\config\daemon.json</code> 添加一行<code>&quot;hosts&quot;: [&quot;tcp://0.0.0.0:2375&quot;]</code>(ps:需要关闭<code>expose daemon on tcp://localhost:2375</code>), 这里需要注意的就是你 <code>docker desktop for windows</code> 是以windows container启动的而不是linux container 方式启动, 不然不起作用, 如果非要以linux container方式启动并且提供外网访问, 也不是没有办法具体操作参考<a href="https://github.com/docker/for-win/issues/314" target="_blank" rel="noopener">这个issue</a>(ps:未实验)</p>
<h1 id="Gradle插件构建镜像"><a href="#Gradle插件构建镜像" class="headerlink" title="Gradle插件构建镜像"></a>Gradle插件构建镜像</h1><ol>
<li><p>在 <code>build.gradle</code> 中添加 <code>docker-plugin</code> 插件,然后编写脚本具体文档参考<a href="https://bmuschko.github.io/gradle-docker-plugin/#remote_api_plugin" target="_blank" rel="noopener">这里</a>, 最终 <code>build.gradle</code> 就是像下面这样:  </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    ...</span><br><span class="line">    id &#39;com.bmuschko.docker-spring-boot-application&#39; version &#39;6.1.3&#39;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">dependencies&#123;...&#125;</span><br><span class="line">docker &#123;</span><br><span class="line">    springBootApplication &#123;</span><br><span class="line">        baseImage &#x3D; &#39;openjdk:11&#39;</span><br><span class="line">        ports &#x3D; [8090]</span><br><span class="line">        maintainer &#x3D; &#39;dengbojing@qq.com&#39;</span><br><span class="line">        images &#x3D; [&#39;dengbojing&#x2F;gateway:v3&#39;]</span><br><span class="line">        jvmArgs &#x3D; [&#39;-Dspring.profiles.active&#x3D;production&#39;, &#39;-Xmx2048m&#39;]</span><br><span class="line">        mainClassName &#x3D; &#39;com.yichen.ServiceGatewayApplication&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>baseImage</code> 基于哪个基础镜像构建.<br> <code>ports</code> 需要暴露的端口.<br> <code>maintainer</code> 对应 <code>dockerfile</code> 中已经废弃的 <code>maintainer</code> 命令, 添加一些元信息.<br> <code>images</code>  构建出来的额镜像名称.<br> <code>jvmArgs</code> 对应 <code>dockerfile</code> <code>ENTRYPOINT</code> 命令中的启动参数.<br> <code>mainClassName</code>  对应 <code>dockerfile</code> <code>ENTRYPOINT</code> 命令中的启动类.    </p>
</li>
<li><p>执行 <code>gradle dockerBuildImage</code>, 该命令就会使用 <code>docker -H tcp://127.0.0.1:2375 build</code> 来构建镜像, 所以要先开启 <code>2375端口</code>;<br>当然该插件也能提供远程构建,具体请看<a href="https://bmuschko.github.io/gradle-docker-plugin/#remote_api_plugin" target="_blank" rel="noopener">官方文档</a>;<br>如果使用开发工具可以在开发工具<code>gradle</code>插件里面找到对应的执行的<code>task</code>;<br>然后会在 <code>${classpath}/build/docker</code> 下面看到生成的 <code>dockerfile</code>,这里并不是打 <code>jar</code> 包的方式, 而是用完整的<code>lib</code> 和 <code>classes</code> 制作镜像,然后用<code>java -cp</code> 指定设置 <code>classpath</code> 然后启动脚本写的 <code>mianClass</code>;<br>此时执行 <code>docker images</code> 就可以看到制作的镜像.  </p>
</li>
<li><p>插件提供了4个 <code>task</code>, 分别是 <code>dockerPushImage</code>–推送镜像到镜像仓库,需要指定用户名密码,具体参看<a href="https://bmuschko.github.io/gradle-docker-plugin/#remote_api_plugin" target="_blank" rel="noopener">官方文档</a> , <code>dockerBuildImage</code>–构建镜像 , <code>dockerCreateDockerfile</code>–创建<code>dockerfile</code> , <code>dockerSyncBuildContext</code>–将代码同步到<code>docker context</code> , 前面的 <code>task</code> 总是依赖后面的 <code>task</code>.</p>
</li>
</ol>
<h1 id="Docker-compose介绍-amp-简单使用"><a href="#Docker-compose介绍-amp-简单使用" class="headerlink" title="Docker-compose介绍 &amp; 简单使用"></a>Docker-compose介绍 &amp; 简单使用</h1><ol>
<li><p><code>docker-compose</code> 是官方提供的编排项目工具, 主要是应对<strong><em>单机</em></strong>多容器之间连接通信.</p>
</li>
<li><p>使用 <code>docker-compose.yml</code> 作为模版文件  </p>
</li>
<li><p>模版文件开头使用 <code>version</code> 来指定 <code>docker-compose</code> 文件格式,目前最新版本为3.7,具体对照关系可以参考<a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener">这里</a>  </p>
</li>
<li><p>一个简单的 <code>docker-compose.yml</code> 示例:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span> </span><br><span class="line">    <span class="attr">web:</span> </span><br><span class="line">        <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">dengbojing/gateway:v4</span></span><br><span class="line">        <span class="attr">ports:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">"8090:8090"</span></span><br><span class="line">        <span class="attr">networks:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">gateway</span></span><br><span class="line">    <span class="attr">zookeeper:</span> </span><br><span class="line">        <span class="attr">image:</span> <span class="string">zookeeper</span></span><br><span class="line">        <span class="attr">networks:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">gateway</span></span><br><span class="line"><span class="attr">networks:</span> </span><br><span class="line">    <span class="attr">gateway:</span></span><br></pre></td></tr></table></figure>
<p><code>version</code>: compose的版本号,具体对应关系可以查看<a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener">文档</a><br><code>services</code>: 需要启动的服务,一个服务对应一个容器,也就是说在执行该文件之后,会多出两个容器<br><code>web</code>,<code>zookeeper</code>: 服务名称, 最终创建的容器名称会以启动时候指定的 <code>${project_name}</code> 加上服务的名称为完整的容器名称<br><code>build</code>: 指定构建的 <code>docker-context</code> 和 <code>dockerfile</code>, 此处都在当前目录; 详细指定格式为:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">build:</span> </span><br><span class="line">    <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">dockfile:</span> <span class="string">./dockerfile</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>
<p>ps: 这里可以指定 <code>docker-gradle</code>生成的 <code>dockerfile</code> 作为构建脚本.<br><code>image:</code> 指定构建完成之后的镜像名称,也就说执行完该文件会多一个以 <code>dengbojing/gateway:v4</code> 为名称的镜像; 下面的<code>image</code>为以<code>zookeeper</code>镜像为基础创建一个容器;<br><code>ports</code>: 对外暴露的端口  </p>
</li>
<li><p><code>networks</code>: 定义一个网络, 然后在 <code>services</code> 中使用, 此时 <code>web</code> 服务容器就可以通过下面的服务名–<code>zookeeper</code> 来访问下面的服务容器, 例:  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">zookeeper:</span></span><br><span class="line">      <span class="attr">connect-string:</span> <span class="string">zookeeper:2181</span></span><br></pre></td></tr></table></figure>
<p>ps: <code>gateway</code> 项目为<code>spring-cloud-gateway</code> 项目, 使用了 <code>zookeeper</code> 作为注册中心和配置中心, 所以需要访问 <code>zookeeper</code>.  </p>
</li>
<li><p>写到这里,简单的使用 <code>docker-compose</code> 就完成了, 不难发现对于微服务来说这种方式是非常有用的, 我们可以把我们几个服务包装成一个 <code>docker-compose</code> 项目,然后进行部署,它还支持从一个镜像启动多个容器实例–毕竟容器实例就是类的对象,有对个对象当然是没问题的; 这样以来那么一个文件里面就可以包含多个相同功能的服务,一个注册中心,一个配置中心,完美实现了集群功能.<br>当然在实际生产过程中,注册中心和配置中心肯定在不同的服务器上, 所以这种方式有一定的局限性.</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>简单的学习了一下 <code>docker-compose</code> , 其中有很多配置和命令之后实战的时候才会真的用到. 怎么说呢:    </p>
<blockquote>
<p>路漫漫其修远兮, 吾将上下而求索</p>
</blockquote>
</li>
</ol>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>springboot</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>dockerfile构建自己的应用</title>
    <url>/2020/02/01/dockerfile/</url>
    <content><![CDATA[<p>使用docker构建自己的应用</p>
<a id="more"></a>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>  自从docker入门以后,一发不可收拾,越学习越感觉有趣,本文记录一下在学习dockerfile构建自己应用遇到的坑以及学习心得  </p>
<blockquote>
<h1 id="Talk-is-cheap-show-me-the-code"><a href="#Talk-is-cheap-show-me-the-code" class="headerlink" title="Talk is cheap, show me the code"></a>Talk is cheap, show me the code</h1></blockquote>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>  使用gradle+jdk11编译及打包springboot项目,然后使用docker制作镜像  </p>
<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><p>  springboot,作为现在最流行的微服务基础框架,我相信大家已经非常非常熟悉了,即使没有使用过,肯定听说过.一般比较通用的创建方式是使用springboot官网提供的<a href="https://start.spring.io/" target="_blank" rel="noopener">创建工具</a>进行创建,如果你使用intellij idea那么也可以在创建的时候使用spring initializr,这个和使用官方提供的创建工具是一回事  </p>
<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><ol>
<li><p>FROM<br>该指令是dockerfile的起始命令,是必须的,而且必须是第一个,作用是以一个镜像为基础,在该镜像上进行定制.  </p>
<blockquote>
<p><code>FROM [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</code><br><code>FROM [--platform=&lt;platform&gt;] &lt;image&gt; [AS &lt;name&gt;]</code><br><code>FROM [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]</code>  </p>
</blockquote>
</li>
<li><p>ARG<br>该指令是声明一个变量: </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ARG &lt;name&gt;[&#x3D;&lt;default value&gt;]</span><br></pre></td></tr></table></figure>
<p> 如果想覆盖默认值,可以在执行 <code>docker build</code> 命令时候指定 <code>--build-arg &lt;name&gt;=&lt;value&gt;</code></p>
</li>
</ol>
<pre><code>ps:在FROM之前声明的ARG在构建阶段之外，因此，FROM之后的任何指令都不能使用它。要使用在第一个FROM之前声明的ARG的默认值，请使用ARG指令，且在构建阶段内部不带值  
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ARG VERSION&#x3D;latest  </span><br><span class="line">FROM busybox:$VERSION  </span><br><span class="line">ARG VERSION  </span><br><span class="line">RUN echo $VERSION &gt; image_version</span><br></pre></td></tr></table></figure></code></pre><ol start="3">
<li><p>LABEL<br>该指令添加 <code>metadata</code> 到镜像之中,格式为键值对,如: </p>
<blockquote>
<p><code>LABEL maintainer=&quot;dengbojing@qq.com&quot;</code></p>
</blockquote>
<p>   ps: 这里正好用 <code>maintainer</code> 字段来说明一下,官方已经将<code>MAINTAINER</code> 这个命令废弃,改用 <code>LABEL</code> 代替   </p>
</li>
<li><p>RUN<br>该指令有两种格式  </p>
<ul>
<li><p>shell格式, <code>RUN &lt;command&gt;</code> command将会在shell中执行,对于linux系统shell为/bin/bash, 对于windows系统shell为 cmd /S /D   </p>
</li>
<li><p>exec格式, <code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> , 注意该指令不会进行shell处理,比如 <code>RUN [&quot;echo&quot;, &quot;$home&quot;]</code> 是不会对 <code>$home</code> 处理的,你需要自己指定shell,<code>RUN [&quot;sh&quot;, &quot;-c&quot;, &quot;echo $home&quot;]</code>.   </p>
<p>该命令执行一次会产生一层layer,所以应该尽量合并 <code>RUN</code> 后面 <code>command</code> 比如:  </p>
<blockquote>
<p>RUN &amp;&amp; apt-get update <br>  &amp;&amp; apt-get install -y $buildDeps  </p>
</blockquote>
</li>
</ul>
</li>
<li><p>CMD<br>该指令主要作用是为容器提供一个默认的执行命令,三种格式:  </p>
<ul>
<li><p>exec格式, <code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code> ,该格式是官方推荐首选格式,同样该格式也不会进行shell处理.  </p>
</li>
<li><p>参数格式: <code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code>, 该格式需要指定 <code>ENTRYPOINT</code> ,作为 <code>ENTRYPOINT</code> 的参数  </p>
</li>
<li><p>shell格式, <code>CMD command param1 param2</code>   </p>
<p>ps: 该指令在文件中只有一个,如果有多个那么只有最后一个 <code>CMD</code> 才会起作用,如果在<code>docker run</code> 后面指定了其他命令或者参数会覆盖 <code>CMD</code> 后面的命令或者参数</p>
</li>
</ul>
</li>
<li><p>ENTRYPOINT<br>该指令主要作用是为容器提供一个每次都执行的命令,该命令有两种格式:  </p>
<blockquote>
<p>exec格式: <code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> ,官方推荐<br>shell格式: <code>ENTRYPOINT command param1 param2</code>  </p>
</blockquote>
<p> ps: 同 <code>CMD</code> 指令如果有多个 <code>ENTRYPOINT</code> 也只有最有一个起作用,如果想覆盖默认的<code>ENTRYPOINT</code> 可以使用: <code>docker run --entrypoint</code>;不同点在于,该指令可以直接在 <code>docker run</code> 后面跟参数,而 <code>CMD</code> 指令不可以.  </p>
</li>
<li><p>COPY<br>顾名思义,该指令主要作用就是–复制,两种格式:  </p>
<blockquote>
<p><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code><br><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</code>  </p>
</blockquote>
<p>   ps: 1. 该指令的 <code>--chown</code> 只有linux才有,windows和linux权限管理不一样;另外该指令还支持通配符  </p>
<pre><code>2. 该指令只会cp源目标下文件.  
3. 如果目标目录没有/, 则会将目标地址当成一个文件  
4. 如果目标目录不存在, 则会创建目标目录的所有层级的目录   </code></pre></li>
</ol>
<ol start="8">
<li><p>EXPOSE<br>该指令暴露一个容器内部端口到外部,格式为:  </p>
<blockquote>
<p><code>EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</code><br>   ps: 该指令并非真正暴露一个端口供外部使用,只是一种说明,说明容器内部哪些端口可以被访问,在启动时候需要使用 <code>docker run -p &lt;out port&gt;:&lt;expose port&gt;</code>   </p>
</blockquote>
</li>
</ol>
<ol start="9">
<li>WORKDIR<br>该指令指定工作目录,相当于<code>shell</code>命令里面的 <code>cd</code>,指定工作目录之后,后续的<code>COPY</code>,  <code>RUN</code>, <code>CMD</code>, <code>ENTRYPOINT</code> 等命令都是在当前目录下完成  </li>
</ol>
<h1 id="USAGE-amp-CONTEXT"><a href="#USAGE-amp-CONTEXT" class="headerlink" title="USAGE  &amp;  CONTEXT"></a>USAGE  &amp;  CONTEXT</h1><p>  当执行 <code>docker build</code> 的时候需要一个 <code>Dockerfile</code> 文件和一个 <code>context</code>, <code>context</code> 的涵义是指包含一些列文件的<code>PATH</code>或者<code>URL</code>,这里的 <code>PATH</code> 代表了文件系统的目录, <code>URL</code> 则代表了 <code>Git</code> 仓库地址.  </p>
<p>  这里文件系统的目录是包含下面的子目录以及子目录中的文件,也就是 <code>whole directory</code> 都会被作为上下文发送给 <code>docker daemon</code>.  </p>
<p>  <code>docker build</code> 构建的时候不是在CLI(命令行界面)构建而是把 <code>当前目录</code> 作为 <code>context</code> 发送给 <code>docker daemon</code>, 也就是docker的守护进程,所以说不能发送过大的目录,特别是不要在根目录执行 <code>docker build</code>, 官方推荐是使用一个空目录作为 <code>context</code> 来存放 <code>Dockerfile</code> ,仅仅添加 <code>Dockerfile</code> 需要的文件.  </p>
<p>  这里遇到一些问题,执行 <code>docker build</code> 命令的时候会将当前目录作为 <code>context</code> 发送给守护进程, 但是 <code>Dockerfile</code> 不能直接使用这些文件,官方说明为:  </p>
<blockquote>
<p>To use a file in the build context, the Dockerfile refers to the file specified in an instruction, for example, a COPY instruction  </p>
</blockquote>
<p>  翻译过来就是–<code>要使用 context 中使用某个文件, Dockerfile 指定一个命令来引用这个文件,例如: COPY 命令</code>, 换句话说,就是这些文件发送给守护进程,但是不能直接使用,得通过命令来使用(后面会说明碰到的问题).  </p>
<h1 id="制作"><a href="#制作" class="headerlink" title="制作"></a>制作</h1><h2 id="学习了dockerfile和指令之后-我想到应该有两种方式制作镜像"><a href="#学习了dockerfile和指令之后-我想到应该有两种方式制作镜像" class="headerlink" title="学习了dockerfile和指令之后,我想到应该有两种方式制作镜像"></a>学习了dockerfile和指令之后,我想到应该有两种方式制作镜像</h2><ul>
<li><p>方法一: 使用gradle构建项目,然后在使用dockerfile把jar包制作成镜像: 这种方法简单,但是感觉没什么意义啊,不过随后我还真的在<a href="https://spring.io/guides/gs/spring-boot-docker/" target="_blank" rel="noopener">springboot官方指导</a>下找到了这个方法.  </p>
<ol>
<li><p>第一步,执行gradle构建项目gradle build -x test  </p>
</li>
<li><p>第二步,编写dockerfile  </p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM openjdk:11</span><br><span class="line">LABEL maintainer&#x3D;&quot;dengbojing@qq.com&quot;  </span><br><span class="line">ARG JAR_FILE&#x3D;build&#x2F;libs&#x2F;*.jar</span><br><span class="line">COPY $&#123;JAR_FILE&#125; app.jar</span><br><span class="line">EXPOSE 8090</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;&#x2F;app.jar&quot;]</span><br></pre></td></tr></table></figure></li>
<li><p><code>docker build -t dengbojing/gateway .</code> 点代表把当前目录作为<code>context</code>发送给<code>dockerdeamon</code></p>
</li>
</ol>
</li>
<li><p>方法二: 把方法一的第一步放在Dockerfile里面,这样就少执行一步命令,</p>
<ol>
<li><p>进入项目目录,新建一个空白的 <code>Dockerfile</code> 文件,填写如下内容:  </p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM openjdk:11  </span><br><span class="line">LABEL maintainer&#x3D;&quot;dengbojing@qq.com&quot;  </span><br><span class="line">COPY . .</span><br><span class="line">RUN .&#x2F;gradlew build -x test  </span><br><span class="line">EXPOSE 8090  </span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;build&#x2F;libs&#x2F;service-gateway-0.0.1-SNAPSHOT.jar&quot;]</span><br></pre></td></tr></table></figure>

<p>   ps: 第一次写命令时候不了解 <code>Dockerfile</code> 和 <code>context</code> 的工作原理,觉得将当前工作目录发送给<code>docker daemon</code> 就能直接使用了,没有写<code>COPY . .</code>, 结果就是怎么都运行不过去,找不到<code>gradlew</code> 文件.后面 <code>Google</code> 之,看到这种写法,一脸懵,后来请教群里大神,加上仔细阅读文档,最终解惑.  </p>
</li>
<li><p>这种方法有一个弊端,就是构建之后的镜像会比较大,因为 <code>gradle</code> 构建项目阶段所需要的额外的文件最终也被添加到镜像中了, 所以官方提供了多阶段构建. 例: </p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM openjdk:11 AS build  </span><br><span class="line">LABEL maintainer&#x3D;&quot;dengbojing@qq.com&quot;  </span><br><span class="line">COPY . .</span><br><span class="line">RUN .&#x2F;gradlew build -x test  </span><br><span class="line"></span><br><span class="line">FROM openjdk:11 AS final</span><br><span class="line">WORKDIR &#x2F;app</span><br><span class="line">COPY --from&#x3D;build build&#x2F;libs&#x2F;service-gateway-0.0.1-SNAPSHOT.jar app.jar</span><br><span class="line">EXPOSE 8090  </span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;app.jar&quot;]</span><br></pre></td></tr></table></figure>

<p>   可以对比一下两种不同方式构建的镜像最后的大小, 如下图: <img src="https://i.loli.net/2020/08/04/6MwQ8Vtqpye1Wdn.png" alt="compare-v1-v2.png"><br>   可以看到,v1是通过非多阶段构建的,构建之后有1.16g大小,而通过多阶段构建,抛弃了 <code>gradle</code> 文件,只留下需要的项目jar包, 只有652M,好处显而易见.<br>   ps: 如果还想那个精简,那么可以使用 <code>jre</code> 而非 <code>jdk</code>; 我这里是使用的自己的一个<code>spring-cloud-gateway</code>项目进行学习的.  </p>
</li>
</ol>
</li>
<li><p>方法三: 以上的方法,是我直观能想到的方法,但是通过学习,找到了更简便的方法,那就是 <code>gradle插件</code> ,编写 <code>gradle构建脚本</code> ,生成 <code>docker</code> 镜像, 具体文档, 点击<a href="https://bmuschko.github.io/gradle-docker-plugin/#spring_boot_application_plugin" target="_blank" rel="noopener">这里</a>  </p>
</li>
</ul>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>  目前方法三还处于理论阶段,文档是看懂了,但是没有实质性的操作过.而且在项目构建过程中涉及到网络通信, <code>spring-cloud</code> 所有的项目都应该在注册中心注册, 我采用的 <code>zookeeper</code> 作为注册中心和配置中心, 这就涉及到了两个容器之间相互通信, 目前还没有学会, 目前做法是在宿主机启动 <code>zookeeper</code>, 然后找到 <code>docker</code> 虚拟网卡, 找到宿主机相对于 <code>docker</code> 的 <code>ip address</code> , 将镜像里面的 zk 地址改为宿主机相对于容器的ip, 这种方法很不容器化, 所以接着学习, 学会很容器化的方式方法.  </p>
<blockquote>
<p>骐骥一跃,不能十步;驽马十驾,功在不舍.</p>
</blockquote>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>springboot</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>docker入门学习</title>
    <url>/2020/01/25/docker-new/</url>
    <content><![CDATA[<p>docker入门</p>
<a id="more"></a>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>  作于2020年春节大年初一晚,此时疫情真的是猛于虎,为了避免给我媳妇她们医院带来不必要的麻烦,老实在家呆着学学新知识,提升自我.  </p>
<blockquote>
<h1 id="Talk-is-cheap-show-me-the-code"><a href="#Talk-is-cheap-show-me-the-code" class="headerlink" title="Talk is cheap, show me the code"></a>Talk is cheap, show me the code</h1></blockquote>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><blockquote>
<p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现,基于 Linux 内核的<br>   cgroup,namespace,以及 AUFS 类的 Union FS 等技术,对进程进行封装隔离,属于操作<br>   系统层面的虚拟化技术  </p>
</blockquote>
<p>   个人理解就是一种虚拟化技术,类似之前接触过的lvm(linux virtual machine),但是有很大的不同,lvm是有一套完整的系统,虚拟出一套硬件系统和操作系统,然后在该系统之上又有很多的应用;而容器技术里面的应用直接是运行在容器宿主的内核之上,也没有虚拟除一套硬件,一套操作系统;所以容器很轻便小巧.<br>   ps: 从以上描述可以看出,容器技术更适用于持续集成和devOps,有点 <code>java--Complie Once,Run Anywhere</code> 的意思,只需要打包一次,在任何地方,任何系统之上都能使用,不存在之前 <code>各种环境</code> (开发环境,测试环境,灰度环境,正式环境)导致的[这段代码在我机器上好好的啊,怎么可能有问题]</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol>
<li><p>注册docker hub 账号  </p>
</li>
<li><p>在<a href="https://docs.docker.com/" target="_blank" rel="noopener">docker</a>官方文档上找到对应操作系统的<img src="https://i.loli.net/2020/08/04/Gg3EerLRHzWOyb4.png" alt="docker.com.png"><br>ps: 文件还是有点大,建议使用迅雷等p2p工具下载.  </p>
</li>
<li><p>本人使用<code>windows专业版系统</code>,选择<code>docker desktop for windows</code>按照官网提示下载,完成之后不着急安装,此时需要先启动<code>hyper-v</code>,<code>docker desktop</code>是依赖<code>hyper-v</code>的,开启<code>hype-v</code>之后需要重启电脑,重启之后安装<code>docker desktop</code>,安装过程省略,下一步下一步即可.<br>ps: 如果你是<code>windows 家庭版</code>,请参考<a href="https://www.jianshu.com/p/1329954aa329/" target="_blank" rel="noopener">这篇文章</a>  </p>
</li>
<li><p>启动<code>docker desktop</code>,在系统托盘图标<code>右键-&gt;setting</code>,找到<code>resources-&gt;file sharing</code>,选择你要共享的盘符,因为<code>docker desktop</code>默认是使用<code>hyper-v</code>虚拟机,而<code>hyper-v</code>虚拟机默认的镜像地址都是在<code>C盘</code>,也就是系统盘,这会导致<code>c盘</code>不够用,可以直接在<code>resources-&gt;advanced</code>下面找到<code>disak image location</code>修改镜像位置,本人是没有修改,这里本人是开启了共享盘符,把之后镜像使用的存储空间映射到本地其他磁盘上,这样解决了大部分存储空间的问题,镜像存储就不管了    </p>
</li>
</ol>
<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><ol>
<li><p>打开<code>power shell</code>,这里最好是不要使用其他命令终端,本人之前学习时候使用cmd,使用cmd是有坑的,后面会讲到,输入<code>docker login</code>,按照提示输入之前在<code>docker hub</code>上注册的用户名,密码,第一次需要输入,后续可以不用,也可使用图像化界面登录,右键<code>docker desktop</code>系统托盘图标-&gt;login.  </p>
</li>
<li><p>登录之后我们就可以是用<code>docker search</code>命令来搜索我们感兴趣的仓库了,比如我们安装一个mysql吧,<code>docker search mysql</code>,可以看到有很多的<code>mysql</code>镜像,还有<code>star数</code>和<code>official</code><br>ps: 根据是否是官方提供,可将镜像资源分为两类.一种是类似 <code>mysql</code> 这样的镜像,被称为基础镜像或根镜像.这些基础镜像由 Docker 公司创建、验证、支持、提供.这样的镜像往往使用单个单词作为名字.还有一种类型,比如 <code>bitnami/mysql</code> 镜像,它是由 Docker 的用户创建并维护的,往往带有用户名称前缀.  </p>
</li>
<li><p>使用<code>docker pull</code>拉去镜像,具体命令如下  </p>
<blockquote>
<p>docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]   </p>
</blockquote>
</li>
</ol>
<pre><code>具体选项可以通过`docker pull --help` 来查看,  

- docker registry地址: 默认是docker hub,一般不需要指定
- 仓库名: 前文提到镜像名称分为两段,`&lt;username&gt;/&lt;soft name&gt;`如果不指定默认是library,即docker官方的镜像.
- tag: 标签,如果不指定默认为latest,当然可以指定需要的版本,查询tag目前本人没有找到相应的命令,只能去[docker hub](https://hub.docker.com/)搜索镜像然后查看tag    

综上所述,此时只需使用`docker pull mysql`就可以了  </code></pre><ol start="4">
<li><p>可以是用<code>docker image ls</code>或者<code>docker images</code> 查看本地镜像<img src="https://i.loli.net/2020/08/04/dIoT2zwKU4BSQV6.png" alt="docker-images.png"><br>此时可以看到镜像的大小和在<code>docker hub</code>大小是不一样的,这是因为,在<code>docker hub</code>显示的是压缩大小,<code>docker hub</code>作为一个中央镜像仓库,关心的是流量大小,而不是体积大小,所以会尽可能的压缩镜像体积;而且在这里,显示的大小可能和实际占用磁盘空间大小还不一样,这是因为,镜像是有很多文件层组成,而文件层之间又存在继承,复用的关系,如果不同的镜像使用相同的基础层,那么只需要保存一份该基础层就可以了,不同镜像的其他层可以直接引用该基础层,可以使用<code>docker system df -v</code>来查看具体的占用情况,同时可以使用<code>docker system prune</code>来清理磁盘空间.<br><code>docker image ls</code> 支持通配符,如 <code>docker images my*</code> 可以将所有my开头的镜像都列出<br><code>docker image ls -q</code> 可以只显示镜像的 <code>ID</code><br>此外还支持 <code>-f(--filter)</code> 过滤模式, 比如: <code>docker images -f since=mysql</code> 会列出在 <code>mysql</code>之后的所有镜像,将 <code>since</code> 换成 <code>before</code> 可以列出之前的镜像  </p>
</li>
<li><p>启动容器,每一个容器都是一个镜像实例,这个就像<code>java里面的oop思想</code>一样,一个镜像就是一个类,一个类的对象对应一个容器,java 里面使用<code>new</code>关键字实例化对象,这里我们使用<code>docker run</code>来启动一个容器,具体命令参数:  </p>
<blockquote>
<p>docker run [OPTIONS] IMAGE [COMMAND] [ARG…]   </p>
</blockquote>
<p>此处常用的 <code>options</code> 有 <code>-p</code> 指定端口号, <code>-P</code> 指定端口号映射为本机随机端口号; <code>-e</code> 指定容器内部的环境变量;<code>-d</code> 指定为后台启动;<code>-i</code> 保持stdin标准的输入流打开状态,即使没有链接; <code>-t</code> 分配一个伪终端, <code>-v</code> 指定文件映射,即讲本地的一个目录或者文件映射到容器内部;具体启动命令:  </p>
<blockquote>
<p>docker run -d -p 3305:3306 –privileged=true -e MYSQL_ROOT_PASSWORD=xxxx –name   mysqltest -v /f/mysql/data:/var/lib/mysql -v /f/mysql/conf/my.cnf:/etc/mysql/my.cnf -v //f/mysql/mysql-files:/var/lib mysql-files/ mysql:latest –character-set-server=utf8mb4 –collation-server=utf8mb4_unicode_ci  </p>
</blockquote>
<p>解释一下,此时我们就把容器内部的3306端口映射为宿主机的3305端口,并且设置了mysql的配置,数据存储位置,并且进行了一系列的mysql参数设置,指定了 <code>msyql root</code> 的密码为xxx,–privileged是让容器内部的用户获取宿主机特殊权限,此处一定要把文件映射在你已经共享的盘符,不然会失败  </p>
</li>
<li><p>查看容器状态, <code>docker container ls -a</code> 或 <code>docker ps -a</code> 可以看到容器的状态,映射端口,名字等;<br>使用 <code>docker stop &lt;container name\id&gt;</code> 停止容器, 使用 <code>docker start &lt;container name\id&gt;</code> 再次启动容器,注意第一次启动容器使用 <code>docker  run</code> 命令,该命令会创建并启动一个容器, 之后并不需要在run,只需要执行start就可以了,此外 <code>docker run</code> 执行时,如果指定镜像不存在,该命令会自动拉去默认仓库所匹配的镜像  </p>
</li>
</ol>
<ol start="7">
<li>删除镜像和容器<br>删除镜像使用 <code>docker image rm</code> 或 <code>docker rmi</code> 加上镜像的 <code>ID</code> 来删除镜像<br>删除容器使用 <code>docker container rm</code> 或 <code>docker rm</code> 加上容器 <code>ID</code> 删除容器,可以添加 <code>-f</code> 强制删除一个正在运行的容器;<br>此外如果只是想清理未被容器使用的镜像可以使用 <code>docker image prune</code><br>同理,可以使用  <code>docker container prune</code> 清理未运行的容器<br>如果需要删除的容器或者镜像太多,手动一个个输入就显得有点智障了,此时可以使用 <code>docker image ls -q</code> 来配合批量删除,比如:<br><code>docker rmi $(docker image ls -q -f since=mysql)</code><br>此时就会将mysql之前所有的镜像都删除<br>ps: 此处有之前说的 <code>cmd</code> 的坑,使用 <code>cmd</code> 会报错,改用 <code>power shell</code> 就不会</li>
</ol>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>基础入门就这些,后续根据自身所学内容,会陆陆续续的记录更多的东西,比如如何创建一个docker容器啊,导入导出镜像啊,私有仓库的搭建等等.  </p>
<blockquote>
<p>不积跬步，无以至千里；不积小流，无以成江海</p>
</blockquote>
<hr>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo+github pages建立静态blog</title>
    <url>/2020/01/14/first/</url>
    <content><![CDATA[<blockquote>
<p>好记性不如烂笔头</p>
</blockquote>
<p>记录一下使用hexo + github pages搭建博客的过程,以及过程中遇到的坑;同时也给阅读这篇文章,想要搭建博客的人一点帮助</p>
<a id="more"></a>
<h1 id="为什么搞独立blog"><a href="#为什么搞独立blog" class="headerlink" title="为什么搞独立blog"></a>为什么搞独立blog</h1><p><code>市面上blog service多如牛毛为啥非要搞自己的,因为独立的才是自己的</code></p>
<h1 id="为什么使用gihub-pages"><a href="#为什么使用gihub-pages" class="headerlink" title="为什么使用gihub pages"></a>为什么使用gihub pages</h1><p><code>因为不用买服务器,免费而且稳定,也无需域名,只需要你有github账号就能用</code></p>
<blockquote>
<h1 id="Talk-is-cheap-show-me-the-code"><a href="#Talk-is-cheap-show-me-the-code" class="headerlink" title="Talk is cheap, show me the code"></a>Talk is cheap, show me the code</h1></blockquote>
<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><ol>
<li><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">git</a>根据自己电脑下载相应版本,本人是win10电脑使用git bash.</li>
<li>安装完成打开<code>git bash</code>, 输入<code>git --version</code>测试是否安装成功</li>
<li>注册<a href="https://github.com/" target="_blank" rel="noopener">github</a>账号(全球最大的同性交友网站,你值得拥有).</li>
<li>新建<code>&lt;username&gt;.github.io</code>仓库.</li>
</ol>
<h1 id="node"><a href="#node" class="headerlink" title="node"></a>node</h1><ol>
<li><a href="http://nodejs.cn/download/]" target="_blank" rel="noopener">node</a>根据自己电脑下载相应版本</li>
<li>安装完成之后,在之前的<code>git bash</code>输入<code>node --version</code>测试是否安装成功</li>
</ol>
<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><ol>
<li><p>安装好 Node.js 后，通过 npm 安装 Hexo</p>
<blockquote>
<p>npm install hexo-cli -g</p>
</blockquote>
<p> ps: 可能安装失败,如果失败,安装cnpm,然后在安装hexo;或者挂代理,走梯子</p>
<blockquote>
<p>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p>
</blockquote>
</li>
<li><p>安装 Hexo 完成后,执行</p>
<blockquote>
<p>hexo init &lt;folder&gt;<br>cd &lt;folder&gt;<br>npm install  </p>
</blockquote>
<p> 执行完成之后目录会像</p>
<blockquote>
<p>├── _config.yml<br> ├── node_modules<br> │   ├── hexo<br> │   ├── hexo-generator-archive<br> │   ├── hexo-generator-category<br> │   ├── hexo-generator-index<br> │   ├── hexo-generator-tag<br> │   ├── hexo-renderer-ejs<br> │   ├── hexo-renderer-marked<br> │   ├── hexo-renderer-stylus<br> │   └── hexo-server<br> ├── package.json<br> ├── scaffolds<br> │   ├── draft.md<br> │   ├── page.md<br> │   └── post.md<br> ├── source<br> │   └── _posts<br> └── themes  </p>
<pre><code>└── landscape  </code></pre></blockquote>
<p> ps: 简单说明一下目录作用   </p>
<blockquote>
<p> _config.yml  配置文件,网站的标题,作者,主题配置等<br> node_modules hexo的模块,较少关心<br> package.json 项目描述文件,不用关心<br> scaffolds  模版配置,较少关心<br> source–&gt;_post  主要存放我们写的文章<br> themes  <a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo主题</a>,文件夹名称对应为主题名称  </p>
</blockquote>
</li>
<li><p>配置_config.yml</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: Hexo #标题</span><br><span class="line">subtitle: #副标题</span><br><span class="line">description: #描述</span><br><span class="line">author: #你的名字</span><br><span class="line">language: zh #网站使用的语言,注意使用主题下面的语言(themes--&gt;&lt;要使用的主题&gt;--&gt;languages)不然会出现未知结果</span><br><span class="line">timezone: Asia&#x2F;Shanghai #网站时区 </span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">url: https:&#x2F;&#x2F;dengbojing.com #地址(如果未申请域名则不需要填写)</span><br><span class="line">root: &#x2F; #根目录</span><br><span class="line">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F; #文章的永久链接格式</span><br><span class="line">permalink_defaults: #</span><br><span class="line">    trailing_index: true # Set to false to remove trailing &#39;index.html&#39; from permalinks</span><br><span class="line">    trailing_html: true # Set to false to remove trailing &#39;.html&#39; from permalinks</span><br><span class="line"></span><br><span class="line"># Directory</span><br><span class="line">source_dir: source #资源文件夹</span><br><span class="line">public_dir: public #由资源文件夹生成而来</span><br><span class="line">tag_dir: tags #标签文件夹,默认是没有的需要使用hexo new page tags 自行创建</span><br><span class="line">archive_dir: archives #归档文件夹</span><br><span class="line">category_dir: categories #分类文件夹,默认是没有的需要使用hexo new page tags 自行创建</span><br><span class="line">code_dir: downloads&#x2F;code #Include code 文件夹</span><br><span class="line">i18n_dir: :lang #国际化（i18n）文件夹</span><br><span class="line">skip_render: #跳过指定文件的解析</span><br><span class="line"></span><br><span class="line"># Writing</span><br><span class="line">new_post_name: title.md # 新文章的文件名称</span><br><span class="line">default_layout: post #预设布局</span><br><span class="line">titlecase: false # 把标题转换为单词首字母大写</span><br><span class="line">external_link: </span><br><span class="line">    enable: true # 在新标签中打开链接</span><br><span class="line">    field: site</span><br><span class="line">    exclude: &#39;&#39; #排除文件</span><br><span class="line">filename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写</span><br><span class="line">render_drafts: false #显示草稿</span><br><span class="line">post_asset_folder: false #启动 Asset 文件夹，为 true 时，每次建立文件时，Hexo 会自动建立一个与文章同名的文件夹</span><br><span class="line">relative_link: false #把链接改为与根目录的相对位址</span><br><span class="line">future: true #显示未来的文章</span><br><span class="line">highlight: #代码块高亮,很多主题要求此项为false</span><br><span class="line">    enable: true</span><br><span class="line">    line_number: true</span><br><span class="line">    auto_detect: true</span><br><span class="line">    tab_replace:</span><br><span class="line"></span><br><span class="line"># Category &amp; Tag</span><br><span class="line">default_category: uncategorized #默认分类</span><br><span class="line">category_map: #分类别名</span><br><span class="line">tag_map: #标签别名</span><br><span class="line"></span><br><span class="line"># Date &#x2F; Time format</span><br><span class="line">date_format: YYYY-MM-DD #日期格式</span><br><span class="line">time_format: HH:mm:ss #时间格式</span><br><span class="line"></span><br><span class="line"># Pagination</span><br><span class="line">per_page: 10 #每页显示的文章量 (0关闭分页功能)</span><br><span class="line">pagination_dir: page #分页目录</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">theme: next #当前主题名称(本人使用的非默认主题)</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">deploy: #部署</span><br><span class="line">    type: git</span><br><span class="line">    repo: https:&#x2F;&#x2F;github.com&#x2F;username&#x2F;username.github.io.git #仓库地址</span><br><span class="line">    branch: master #分支名称</span><br></pre></td></tr></table></figure></li>
<li><p>打开看看, 在<code>git bash</code>中使用 <code>hexo g</code> 命令生成文章,<code>hexo s</code>命令启动服务,下面提示访问<a href="http://localhost:4000" target="_blank" rel="noopener">localhost:4000</a>,访问一下看到使用默认主题的网站  </p>
</li>
</ol>
<h1 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h1><p>  使用<code>hexo new post &lt;filename&gt;</code> 创建自己的第一篇文章<br>  找到source–&gt;_post,打开<code>&lt;filename&gt;.md</code><br>  <strong><em>更多<a href="https://hexo.io/zh-cn/docs/writing" target="_blank" rel="noopener">写作</a>用法</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 使用hexo+github pages建立静态blog</span><br><span class="line">date: 2020-01-14 19:32:51</span><br><span class="line">tags: [git,hexo]</span><br><span class="line">categories: hexo</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>  在date下面添加分类和标签,可选<br>  在—下面写正文内容,可以使用<code>&lt;!--more--&gt;</code>分割  </p>
<blockquote>
<p>比如:   </p>
</blockquote>
<pre><code>简介  
&lt;!--more--&gt;
正文  </code></pre><h1 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h1><p>hexo g生成<br>hexo s启动<br>打开浏览器,输入<a href="localhost:4000">localhost:4000</a>看看吧  </p>
<h1 id="部署到服务器"><a href="#部署到服务器" class="headerlink" title="部署到服务器"></a>部署到服务器</h1><p>  安装一键部署</p>
<blockquote>
<p>npm install hexo-deployer-git –save  </p>
</blockquote>
<p>  执行 <code>hexo clean</code>(可选,正常情况不需要)<br>  <code>hexo d</code> 部署到<code>&lt;username&gt;.github.io</code></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>  使用过程中遇到很多问题,目前都没有解决,<br>  比如有些主题莫名看不到tags和categories仓库,最后选来选去只能使用next主题<br>  还有写modules(比如七牛云)安装之后即使你不启用你也得写配置  </p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
