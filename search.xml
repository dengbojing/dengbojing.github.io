<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Naming Convention--命名规范</title>
    <url>/2020/09/21/Naming-Convention-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p>译文: <a href="https://blog.usejournal.com/clean-code-best-practice-for-naming-part-1-f67ebe8c0894" target="_blank" rel="noopener">Clean Code (Best practice for naming) Part 1</a></p>
<a id="more"></a>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>  在代码开发过程中好的变量命名习惯是非常重要的,如果是i,j,k,l的命名,我相信不用同组小伙伴打死你,几个月以后的自己都想打死自己.所以,一个好的命名规范尤为重要,不仅要让编译器看懂,阅读代码的人更要是见名知意.</p>
<hr>
<h1 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h1><p>  <a href="https://blog.usejournal.com/clean-code-best-practice-for-naming-part-1-f67ebe8c0894" target="_blank" rel="noopener">原文地址</a>  </p>
<p>  在你写代码时候,你觉得你是为谁在写?第一想法是我写代码是为了编译器能编译.想法是对的,编译器应该能’看懂’你得代码并且能编译执行这些代码.那有咩有其他的读者阅读你的代码呢?在专业的开发中,你开发代码并不是隔离式的,你处在一个团队里面,并且团队里面可能有很多其他成员,所以你写的代码应该能让这些团队成员看懂.大概率会发生你需要重新审视这些代码来了解这些代码是什么,怎么工作的,为什么会这么写.大概率会发生在将来你无法回答这些问题的时候正好有其他人需要你这段代码.四个不同的组,最后面的3个组有共同点是非常重要的.所以我们需要确保我们写出的代码能被人类读懂.这就是代码整洁之道.只有遵循这些准则,才能确保你写的代码能被将来阅读它的人看懂,或者你的同组小伙伴code review的时候看懂,或者你自己将来做bug fix是看懂,或者你得交接人能添加一个新的功能.  </p>
<hr>
<h1 id="怎么样才是整洁的代码"><a href="#怎么样才是整洁的代码" class="headerlink" title="怎么样才是整洁的代码"></a>怎么样才是整洁的代码</h1><ul>
<li>代码能被机器编译以及能被人类看懂</li>
<li>代码名称简单易懂</li>
<li>格式一致,格式影响代码的可读性</li>
<li>容易改善,比凌乱的代码容易修复</li>
<li>能清晰的表达出其意图.写代码的人能明白这段代码是做什么的</li>
</ul>
<p>如下代码,该方法名称不够整洁规范,以至于无法说明方法的意图,这种情况你就需要一行一行的阅读代码才能了解他是做是你么的: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun s(arr: IntArray) &#123;</span><br><span class="line">	val n &#x3D; arr.size</span><br><span class="line">	for(i in 0 until n-1) &#123;</span><br><span class="line">		for (j in 0 until n-i-1)</span><br><span class="line">			if (arr[j] &gt; arr[j+1] &#123;</span><br><span class="line">				val temp &#x3D; arr[j]</span><br><span class="line">				arr[j] &#x3D; arr[j+1]</span><br><span class="line">				arr[j] &#x3D; temp</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整洁规范的代码: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun buuleSort(array: IntArray) &#123;</span><br><span class="line">	for (index in 0 until arraySize - 1) &#123;</span><br><span class="line">        for (pointerIndex in 0 until arraySize - index - 1)</span><br><span class="line">            if (array[pointerIndex] &gt; array[pointerIndex + 1]) &#123;</span><br><span class="line">                val temp &#x3D; array[pointerIndex]</span><br><span class="line">                array[pointerIndex] &#x3D; array[pointerIndex + 1]</span><br><span class="line">                array[pointerIndex + 1] &#x3D; temp</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样你能一眼就看出来这个方法的意图,对,就是冒泡排序.</p>
<hr>
<h1 id="类命名规范"><a href="#类命名规范" class="headerlink" title="类命名规范"></a>类命名规范</h1><ul>
<li>类名应该使用名词. $#x1F47D</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Performer</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Performance</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>避免动词形式的类名.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Perform</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Performed</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Performing</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用形容词前缀表示时态.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActivePerformance</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PastPerformer</span> </span>&#123;&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<ul>
<li><p>类名不能仅使用形容词.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Huge</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Small</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fast</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slow</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用形容词前缀加名词作为类名.</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallPerformance</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PastPerformer</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>避免使用模糊前缀.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPerformer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APerformer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThePerformer</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThisPerformer</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>避免使用单个字母作为类名.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">L</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>避免使用单字母前缀类名.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPerformer</span>() </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TPerformer</span>() </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>避免使用<strong>首字母缩写词</strong>大写.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTTPAPIPerformer</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在单词连接处首字母大写(驼峰命名).</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpApiPerformer</span> </span>&#123;&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<ul>
<li>避免使用缩略词.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Perf</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>避免使用复数作为类名.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">performers</span> </span>&#123;&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<ul>
<li>使用复数作为集合类的类名.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Currencies</span> </span>&#123;</span><br><span class="line">...<span class="comment">// contain map of Currencies, and romat price for each currency</span></span><br><span class="line"></span><br><span class="line">	val currencyMap = mapOf(</span><br><span class="line">		Pair(RUSSIAN_RUBLE, <span class="string">"\u20BD"</span>),</span><br><span class="line">		Pair(UNITED_STATES_DOLLAR, <span class="string">"\$"</span>)</span><br><span class="line">	)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="整洁规范的方法名称"><a href="#整洁规范的方法名称" class="headerlink" title="整洁规范的方法名称"></a>整洁规范的方法名称</h1><ul>
<li>使用一般现在时作为方法名称.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">open</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">perform</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">close</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validate</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>避免使用动名词(现在进行时).</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">performing</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validating</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">opening</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closing</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>避免使用一般过去时.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">performed</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">opened</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closed</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validated</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>is</code>作为动名词前缀.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isRunning</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isClosing</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isServint</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* 使用`</span>has<span class="string">`作为一般过去时前缀.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasPerformed</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasOpened</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasClosed</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasValidated</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在应用系统中保持所有的命名标准和转换一致.</li>
<li>如果语言支持驼峰命名,则应该使用驼峰命名.<br>驼峰命名的准确率比下划线命名准去率要高(高出51.5%的几率)  </li>
</ul>
<hr>
<h1 id="整洁规范的变量命名"><a href="#整洁规范的变量命名" class="headerlink" title="整洁规范的变量命名"></a>整洁规范的变量命名</h1><ul>
<li>使用单数名词作为原始类型和对象类型的变量名]</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br></pre></td></tr></table></figure>

<ul>
<li>使用复数名字作为数组和集合的变量名</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] names = <span class="keyword">new</span> String[](<span class="string">"Alex"</span>, <span class="string">"Ali"</span>, <span class="string">"Aesop"</span>&#125;;</span><br><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>避免使用<strong>动词</strong>作为原始类型的变量名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> create = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> perform = <span class="number">12</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<strong>名词</strong>作为原始类型的变量名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> performanceCode = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">boolean</span> creationEnabled = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>避免使用单个单词作为变量名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> s = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用有意义的变量名</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">9</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>避免使用容易引起混淆的缩写和简写.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String dbsqlSelAllNames = <span class="string">"select * from names"</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用大写分割变量名,并将简写展开</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String dbSqlSelectAllNames = <span class="string">"select * from names"</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要使用无用的复杂前缀,如<strong>匈牙利前缀</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String f_strFirstName = <span class="string">"Jefferson"</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>避免使用数据类型最为变量名后缀</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String lastNameString = <span class="string">"Amaya"</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="整洁规范的参数名"><a href="#整洁规范的参数名" class="headerlink" title="整洁规范的参数名"></a>整洁规范的参数名</h1><ul>
<li>命名参数包含单个值时,使用单数名词</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>命名参数包含多个值时,使用复数名词</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(List&lt;Integer&gt; values)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> values.stream().collect(Collectors.summarizingInt(Integer::intValue)).getSum();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>避免使用单个字母作为参数名称</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i+j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>避免使用简写作为参数名</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(String FSP)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数首字母不应该大写</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">random</span><span class="params">(<span class="keyword">int</span> SeedGenerator)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>避免使用难懂的前缀</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persistName</span><span class="params">(String sName)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="整洁规范的常量名"><a href="#整洁规范的常量名" class="headerlink" title="整洁规范的常量名"></a>整洁规范的常量名</h1><ul>
<li>常量名所有的字母都应该大写.</li>
<li>使用单数名词作为原始类型常量命名.</li>
<li>使用复数名词作为集合常量命名.</li>
<li>避免使用单字母和简写.</li>
<li>确保<strong>首字母缩写词</strong>之间的分割.</li>
</ul>
<hr>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这些规范是根据语言来定,对于其他语言可能有所变化</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>how_to_write_good_tests</title>
    <url>/2020/06/04/how-to-write-good-tests/</url>
    <content><![CDATA[<p>译文: <a href="https://github.com/mockito/mockito/wiki/How-to-write-good-tests" target="_blank" rel="noopener">How to write good tests</a></p>
<a id="more"></a>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>  代码测试是一件非常重要的工作,在之前的工作中总是找各种借口(时间不够,写起来太繁琐,有些场景无法测试)等等原因做的不够完善.有时甚至不做,无心之中发现一篇非常好的代码测试文章.花些时间来翻译一下,提高一下英文水平,顺便也学习一下正经的代码测试该是什么样的.</p>
<hr>
<h1 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h1><p>  <a href="https://github.com/mockito/mockito/wiki/How-to-write-good-tests" target="_blank" rel="noopener">原文地址</a></p>
<p>  为我们的软件定制一个测试用例是件好事,但是实际上,一个<strong>好的</strong>的测试用例也是非常重要的.</p>
<p>  遵循一些固有的原则来热爱测试代码 </p>
<hr>
<h2 id="保持测试代码简洁和可读"><a href="#保持测试代码简洁和可读" class="headerlink" title="保持测试代码简洁和可读"></a>保持测试代码简洁和可读</h2><p>  要做到这一点,需要像对生产代码那样进行<em>无情的重构</em>.否则,让事情发展下去测试代码就会变成恐怖的<code>祖传代码</code>.如果测试代码不能轻松重构,那么意味着生产代码也不能重构,从而导致<code>祖传代码</code>.<strong>总是要勇于重构.</strong>  </p>
<hr>
<h2 id="避免编码重复"><a href="#避免编码重复" class="headerlink" title="避免编码重复"></a>避免编码重复</h2><p>  例如, 测试代码与parser使用完全相同的<code>正则表达式</code>来生成内容.  </p>
<p>  通常来说人们不愿意重复测试与代码的逻辑,所以在测试中重复<code>正则表达式</code>或者其他代码是不可取的.设想以下测试情况,输入/输出结果<code>(f(input)-&gt;(output))</code>,例如,如果代码要处理模版,不要添加固定值,相反,应该根据计算结果添加值. </p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// use</span></span><br><span class="line">Assertions.assertThat(processTemplate(<span class="string">"param1"</span>, <span class="string">"param2"</span>)).isEqualTo(<span class="string">"this is 'param1', and this is 'param2'"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// instead of</span></span><br><span class="line">Assertions.assertThat(processTemplate(<span class="string">"param1"</span>, <span class="string">"param2"</span>)).isEqualTo(String.format(<span class="string">"this is '%s', and this is '%s'"</span>, param1, param2));</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="覆盖尽可能多的情况-来显示正向的用例-特别是错误的代码位置"><a href="#覆盖尽可能多的情况-来显示正向的用例-特别是错误的代码位置" class="headerlink" title="覆盖尽可能多的情况,来显示正向的用例,特别是错误的代码位置"></a>覆盖尽可能多的情况,来显示正向的用例,特别是错误的代码位置</h2><p>  通常使用<code>测试驱动开发(TDD--Test Dirven Development)</code>是最佳的实践方式. 使用<code>TDD</code>人们能在设计阶段就找出什么地方会被破坏. 不要认为为一个小的代码片段编写简单的测试不值得，你永远不知道什么时候、因为什么而修改这段代码.</p>
<p>  可与使用PIT(<a href="http://pitest.org/" target="_blank" rel="noopener">突变检测系统</a>)来对测试代码的有效性进行检测. </p>
<hr>
<h2 id="不要Mock一个你不拥有的类型"><a href="#不要Mock一个你不拥有的类型" class="headerlink" title="不要Mock一个你不拥有的类型"></a>不要Mock一个你不拥有的类型</h2><p>  这并非一条硬性规定,但是如果不遵循该条规定会有影响(很可能会有). </p>
<blockquote>
<p><code>TDD</code>的设计方面和测试方面同样重要.在模拟外部API时,无法使用测试来驱动设计,该API属于其他人;因此第三方也将可以更改API的方法签名和行为. </p>
</blockquote>
<ol>
<li><p>设想一下代码mocks了一个第三方库,在更新了第三方库之后,三方库的逻辑可能改变了一点,但是测试代码依然能够执行成功,因为他被mock了.所以在这之后,所有的事情看起来很美好,构建也成功了,但是软件部署到正式环境–爆炸! </p>
</li>
<li><p>这也可能导致当前的设计和第三方库不够松耦合. </p>
</li>
<li><p>另一个问是第三方库可能非常复杂需要mock许多东西才能运行,这就导致了大量的特定测试和复杂的测试装置, 而这本身就损害了简洁性和可读性的目标.或者由于模拟外部系统的复杂性而没有充分覆盖代码的测试. </p>
<p>相反,最常见的方式是创建一个第三方库的<code>warpper</code>来包装他们,不过应该注意<code>抽象泄漏</code>(<a href="https://zhuanlan.zhihu.com/p/26803553" target="_blank" rel="noopener">什么是abstraction leakage?</a>)的风险,因为太多的底层API,概念或者异常超过了<code>warpper</code>的边界.为了验证第三方提供API的可用性,请使用<code>集成测试</code>,并尽可能的是它们简洁可读. </p>
<p>下面是其他人在mock了非他所有的类型库遇到的痛苦和总结的经验: </p>
</li>
</ol>
<ul>
<li><a href="http://davesquared.net/2011/04/dont-mock-types-you-dont-own.html" target="_blank" rel="noopener">http://davesquared.net/2011/04/dont-mock-types-you-dont-own.html</a></li>
<li><a href="http://www.markhneedham.com/blog/2009/12/13/tdd-only-mock-types-you-own" target="_blank" rel="noopener">http://www.markhneedham.com/blog/2009/12/13/tdd-only-mock-types-you-own</a></li>
<li><a href="http://blog.8thlight.com/eric-smith/2011/10/27/thats-not-yours.html" target="_blank" rel="noopener">http://blog.8thlight.com/eric-smith/2011/10/27/thats-not-yours.html</a></li>
<li><a href="http://stackoverflow.com/questions/1906344/should-you-only-mock-types-you-own" target="_blank" rel="noopener">http://stackoverflow.com/questions/1906344/should-you-only-mock-types-you-own</a></li>
</ul>
<hr>
<h2 id="反模式-Mock一切"><a href="#反模式-Mock一切" class="headerlink" title="反模式: Mock一切"></a>反模式: Mock一切</h2><p>  如果所有的代码都mock了,那么我们怎么测试业务代码?不要害怕不使用Mock的方法. </p>
<hr>
<h2 id="不要Mock值对象"><a href="#不要Mock值对象" class="headerlink" title="不要Mock值对象"></a>不要Mock值对象</h2><p>  为什么会有人要这么做呢? </p>
<blockquote>
<p>因为实例化一个对象非常痛苦? =&gt; 不是一个很好的理由</p>
</blockquote>
<p>  如果创建一个对象非常困难,那么这是代码需要严重重构的一个信号.一种可行的方法就是为你的<code>值对象</code>构造一个<code>builder</code>(构造者模式)–有很多工具可以使用比如<code>IDE 插件</code>,<code>Lombok</code>等等. 还可以在测试环境中创建有意义的工厂方法.<br>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerCreations</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Customer <span class="title">customer_with_a_single_item_in_the_basket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// long init sequence</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  <a href="https://github.com/mockito" target="_blank" rel="noopener"><code>Mockito</code></a>更加关注对象交互,这也是<code>面向对象</code>的重要要素. </p>
<hr>
<h2 id="原文-推荐阅读Growing-Object-Oriented-Software-Guided-by-Tests"><a href="#原文-推荐阅读Growing-Object-Oriented-Software-Guided-by-Tests" class="headerlink" title="(原文)推荐阅读Growing Object Oriented Software Guided by Tests"></a>(原文)推荐阅读<a href="https://book.douban.com/subject/4156589/" target="_blank" rel="noopener"><code>Growing Object Oriented Software Guided by Tests</code></a></h2><p>必读,这本书阐释了功能完整的应用程序在从无到有过程中, 开发的许多方面以及如何在项目生命周期的各个阶段实现测试.</p>
<p>如果遇到一些不理解不确定的事情,可以发邮件给作者.</p>
]]></content>
      <tags>
        <tag>mockito</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-network</title>
    <url>/2020/03/13/docker-network/</url>
    <content><![CDATA[<p>docker-network学习</p>
<a id="more"></a>

<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>阶段性的记录一下docker学习,docker-network里面还有很多问题很搞明白,亟待解决.</p>
<blockquote>
<p>以下操作都是基于<code>docker desktop for windows</code>的<code>linux container</code>模式下</p>
</blockquote>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ol>
<li><p><code>docker</code> 官方有5种网络模式,<code>none,bridge,macvlan,host,overlay</code>.  </p>
<p> 1.1 <code>none</code> 模式,参数 <code>--network=none</code>,无网络模式,这种模式一般很少用,官方说法是和自定义网络驱动时使用.  </p>
<p> 1.2 <code>birdge</code> 模式,参数 <code>--network ${bridge_name}</code>.该模式是默认模式,在安装<code>docker</code>会创建一个默认的<code>docker0</code>的linux网桥,如果启动容器时不指定网络,就会默认连接到<code>docker0</code>网桥   </p>
<blockquote>
<p><code>docker desktop for windows</code>看不见<code>docker0</code>,这是因为,<code>docker desktop for windows</code>实际上是把Docker装在Hyper-v虚拟机上,打开Hyper-v虚拟机管理,可以看到<code>DockerDesktopVM</code>这个虚拟机,Docker实际是运行在这个里面,而<code>docker0</code>就在这个里面,但是你如果连接这个虚拟机,发现连接不上.  </p>
</blockquote>
<p> 1.3 <code>host</code> 模式,参数<code>--network=host</code>,该模式下,容器和宿主机共用一个网络,在指定<code>--privileged=true</code> 时候,如果你不小心修改了网络参数,那么就会造成不必要的麻烦,所以一般不推荐这中做法,上面说到<code>docker desktop for windows</code> 无法查看虚拟机里面的<code>docker0</code>网桥,此时如果你以<code>--network=host</code>启动一个容器,此时你就可以执行<code>ifconfig</code>看到<code>docker0</code>网桥.    </p>
<blockquote>
<p>另一个查看方式<code>docker run -it --rm --privileged --pid=host justincormack/nsenter1</code>,启动之后,执行 <code>ifconfig</code>,指定 <code>--pid=host</code> 参数就是说,让当前启动的容器可以看到宿主机上所有的进程.  </p>
</blockquote>
<p> 1.4 <code>overlay</code> 模式, 参数 <code>network=container:${conatiner_id}</code>,该模式下,容器1和容器2共用一个网络.  </p>
<p> 1.5 <code>macvlan</code> 指定网络的mac地址.</p>
</li>
</ol>
<h1 id="实战bridge模式"><a href="#实战bridge模式" class="headerlink" title="实战bridge模式"></a>实战<code>bridge</code>模式</h1><ol>
<li><p><code>docker network ls</code>查看网络,<br><img src="https://i.loli.net/2020/08/04/otAxfl6vescaw5j.png" alt="docker-network-ls.png"><br>可以看到上面讲到的3种类型的网络,至于<code>overlay</code>呢,是需要依赖别的容器,所以取决与别的容器的网络模式,主要学习一下桥接模式的内容.  </p>
</li>
<li><p><code>bridge</code> 网桥模式的原理, 当创建一个容器的时候,<code>Docker</code> 会创建两个网络模块,一个是在容器里面叫<code>eth0</code>, 另一个则在宿主机里面,名字为<code>vethxxxx</code>,<code>Docker</code> 这个网络模块桥街道容器里面的<code>eth0</code>.<br> 2.1 首先我们以<code>bridge</code>启动一个<code>ubuntu</code> 容器,执行: <code>docker run  -ti --rm ubuntu:14.04 bash</code>, 启动一个一次性容器并进入<br> 2.2  在容器中执行<code>ifconfig</code>, 看到如下图所示:<br> <img src="https://i.loli.net/2020/08/04/VYBJ4Imwhkv6Xcj.png" alt="Docker-ifconfig.png"><br> <code>lo</code>: loopback 回环网络接口,也就是执行<code>localhost</code>或者<code>127.0.0.1</code>时候会走这个网络接口<br> <code>eth0</code>: 所有来自外部的流量都会通过这个网络接口  </p>
<p> 2.2 新开一个终端窗口,执行<code>docker run -it --rm --privileged --pid=host justincormack/nsenter1</code> , 进入容器之后,执行<code>ifconfig</code> 可以看到如图所示:<br> <img src="https://i.loli.net/2020/08/04/uMSpOI8qr3cR7VH.png" alt="docker-host-ifconfig.png"><br> 其中一个<code>vethxxx</code>是桥接到上面<code>ubuntu</code> 容器的网络接口,另一个是当前这个容器的网络接口(因为当前网络没有指定网络模式,所以以默认桥接模式启动,所以也会给当前容器创建一个网络接口).  </p>
</li>
<li><p>自定义网桥,之前使用<code>docker-compose</code> 创建了一个<code>compose</code>, 里面包含了一个<code>gateway</code>和一个<code>zookeeper</code>, 里面还定义了一个<code>network</code> ,让两个容器能够以容器名称相互访问, 了解了<code>docker network</code>之后,其实里面<code>network</code> 节点就是创建了一个<code>bridge</code> 网桥, 此时容器就可以通过名称相互访问, 官方名称叫 <code>automatic service discovery</code> 服务自动发现(瞎鸡巴翻译的).<br> 3.1 执行<code>docker network create -d bridge my-network</code>创建一个<code>bridge</code> 类型网络, 执行<code>docker inspect my-network</code> 看一下里面都有什么,  如图:<br> <img src="https://i.loli.net/2020/08/04/5F4cn2ah6VtJs9H.png" alt="docker-network-inspect-my-network.png"><br> 可以看到,子网掩码是<code>172,19.0.0/16</code>,网关是<code>172,19.0.1</code>,可以使用<code>--subnet=192.168.0.0/16</code> 来指定子网掩码,另外还可以使用<code>--gateway=192.168.0.1</code> 指定网关, <code>--ip-range=192.168.2.0/25</code>指定ip范围  </p>
<p> 3.2 最好是指定子网掩码,免得网络冲突.如果不指定网关,会从地址范围内自动选择一个出来作为网关,目前测试结论默认是xxx.xxx.xxx.1.  </p>
</li>
<li><p>使用<code>docker run --network=my-network</code> 来启动一个容器,执行ifconfig:<br><img src="https://i.loli.net/2020/08/04/uUfES7oBhPpYskj.png" alt="docker-run-network-my-network.png"><br>可以看到此时ip地址为我们创建的桥接网络借口的ip地址范围  </p>
</li>
<li><p>一个容器可以同时连接两个网络,使用<code>docker network connect ${networkid|networkname} ${containerid|containername}</code>, 如图:<br><img src="https://i.loli.net/2020/08/04/9aZx65RWMFXbq1Y.png" alt="docker-network-connect.png"><br>会有两个网络接口一个<code>eth0</code>,另一个<code>eth1</code>, 这样该容器就可以同时访问两个网路  </p>
</li>
<li><p><code>docker network disconnect ${networkid|networkname} ${containerid|containername}</code> 取消容器和网络的链接  </p>
</li>
<li><p><code>--icc</code>高级参数, 如果网络该参数为禁止,则两个容器之间是无法访问的.  </p>
</li>
</ol>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>网络这块真的是比较重要,也比较难的一块,还可以创建<code>overlay</code>类型的网络,有待研究.官方说法生产环境最好不要使用默认的<code>docker0</code>网桥,所以使用<code>docker-compose</code>管理容器还是一个比较好的方式.或者努力学习k8s吧.</p>
<blockquote>
<p>积土成山,风雨兴焉;积水成,渊蛟龙生</p>
</blockquote>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-compose</title>
    <url>/2020/02/11/docker-compose/</url>
    <content><![CDATA[<p>what? 扫把独立日? </p>
<a id="more"></a>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>使用gradle插件构建镜像和docker-compose连接容器</p>
<blockquote>
<h1 id="Talk-is-cheap-show-me-the-code"><a href="#Talk-is-cheap-show-me-the-code" class="headerlink" title="Talk is cheap, show me the code"></a>Talk is cheap, show me the code</h1></blockquote>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>打开docker远程访问端口,<code>docker desktop for windows</code> GUI 界面有一个<code>expose daemon on tcp://localhost:2375</code>, 只需要勾选,然后重启就行;当然这个是提供一个loopback的访问,实际上你并没有真正的暴露一个局域网或者广域网访问的端口,不过对于<code>docker-gradle</code> 使用已经足够,如果非要提供一个远程访问端口请参考<a href="https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-docker/configure-docker-daemon" target="_blank" rel="noopener">微软文档</a>.<br>操作很简单就是在 <code>C:\ProgramData\Docker\config\daemon.json</code> 添加一行<code>&quot;hosts&quot;: [&quot;tcp://0.0.0.0:2375&quot;]</code>(ps:需要关闭<code>expose daemon on tcp://localhost:2375</code>), 这里需要注意的就是你 <code>docker desktop for windows</code> 是以windows container启动的而不是linux container 方式启动, 不然不起作用, 如果非要以linux container方式启动并且提供外网访问, 也不是没有办法具体操作参考<a href="https://github.com/docker/for-win/issues/314" target="_blank" rel="noopener">这个issue</a>(ps:未实验)</p>
<h1 id="Gradle插件构建镜像"><a href="#Gradle插件构建镜像" class="headerlink" title="Gradle插件构建镜像"></a>Gradle插件构建镜像</h1><ol>
<li><p>在 <code>build.gradle</code> 中添加 <code>docker-plugin</code> 插件,然后编写脚本具体文档参考<a href="https://bmuschko.github.io/gradle-docker-plugin/#remote_api_plugin" target="_blank" rel="noopener">这里</a>, 最终 <code>build.gradle</code> 就是像下面这样:  </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    ...</span><br><span class="line">    id &#39;com.bmuschko.docker-spring-boot-application&#39; version &#39;6.1.3&#39;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">dependencies&#123;...&#125;</span><br><span class="line">docker &#123;</span><br><span class="line">    springBootApplication &#123;</span><br><span class="line">        baseImage &#x3D; &#39;openjdk:11&#39;</span><br><span class="line">        ports &#x3D; [8090]</span><br><span class="line">        maintainer &#x3D; &#39;dengbojing@qq.com&#39;</span><br><span class="line">        images &#x3D; [&#39;dengbojing&#x2F;gateway:v3&#39;]</span><br><span class="line">        jvmArgs &#x3D; [&#39;-Dspring.profiles.active&#x3D;production&#39;, &#39;-Xmx2048m&#39;]</span><br><span class="line">        mainClassName &#x3D; &#39;com.yichen.ServiceGatewayApplication&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>baseImage</code> 基于哪个基础镜像构建.<br> <code>ports</code> 需要暴露的端口.<br> <code>maintainer</code> 对应 <code>dockerfile</code> 中已经废弃的 <code>maintainer</code> 命令, 添加一些元信息.<br> <code>images</code>  构建出来的额镜像名称.<br> <code>jvmArgs</code> 对应 <code>dockerfile</code> <code>ENTRYPOINT</code> 命令中的启动参数.<br> <code>mainClassName</code>  对应 <code>dockerfile</code> <code>ENTRYPOINT</code> 命令中的启动类.    </p>
</li>
<li><p>执行 <code>gradle dockerBuildImage</code>, 该命令就会使用 <code>docker -H tcp://127.0.0.1:2375 build</code> 来构建镜像, 所以要先开启 <code>2375端口</code>;<br>当然该插件也能提供远程构建,具体请看<a href="https://bmuschko.github.io/gradle-docker-plugin/#remote_api_plugin" target="_blank" rel="noopener">官方文档</a>;<br>如果使用开发工具可以在开发工具<code>gradle</code>插件里面找到对应的执行的<code>task</code>;<br>然后会在 <code>${classpath}/build/docker</code> 下面看到生成的 <code>dockerfile</code>,这里并不是打 <code>jar</code> 包的方式, 而是用完整的<code>lib</code> 和 <code>classes</code> 制作镜像,然后用<code>java -cp</code> 指定设置 <code>classpath</code> 然后启动脚本写的 <code>mianClass</code>;<br>此时执行 <code>docker images</code> 就可以看到制作的镜像.  </p>
</li>
<li><p>插件提供了4个 <code>task</code>, 分别是 <code>dockerPushImage</code>–推送镜像到镜像仓库,需要指定用户名密码,具体参看<a href="https://bmuschko.github.io/gradle-docker-plugin/#remote_api_plugin" target="_blank" rel="noopener">官方文档</a> , <code>dockerBuildImage</code>–构建镜像 , <code>dockerCreateDockerfile</code>–创建<code>dockerfile</code> , <code>dockerSyncBuildContext</code>–将代码同步到<code>docker context</code> , 前面的 <code>task</code> 总是依赖后面的 <code>task</code>.</p>
</li>
</ol>
<h1 id="Docker-compose介绍-amp-简单使用"><a href="#Docker-compose介绍-amp-简单使用" class="headerlink" title="Docker-compose介绍 &amp; 简单使用"></a>Docker-compose介绍 &amp; 简单使用</h1><ol>
<li><p><code>docker-compose</code> 是官方提供的编排项目工具, 主要是应对<strong><em>单机</em></strong>多容器之间连接通信.</p>
</li>
<li><p>使用 <code>docker-compose.yml</code> 作为模版文件  </p>
</li>
<li><p>模版文件开头使用 <code>version</code> 来指定 <code>docker-compose</code> 文件格式,目前最新版本为3.7,具体对照关系可以参考<a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener">这里</a>  </p>
</li>
<li><p>一个简单的 <code>docker-compose.yml</code> 示例:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span> </span><br><span class="line">    <span class="attr">web:</span> </span><br><span class="line">        <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">dengbojing/gateway:v4</span></span><br><span class="line">        <span class="attr">ports:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">"8090:8090"</span></span><br><span class="line">        <span class="attr">networks:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">gateway</span></span><br><span class="line">    <span class="attr">zookeeper:</span> </span><br><span class="line">        <span class="attr">image:</span> <span class="string">zookeeper</span></span><br><span class="line">        <span class="attr">networks:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">gateway</span></span><br><span class="line"><span class="attr">networks:</span> </span><br><span class="line">    <span class="attr">gateway:</span></span><br></pre></td></tr></table></figure>
<p><code>version</code>: compose的版本号,具体对应关系可以查看<a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener">文档</a><br><code>services</code>: 需要启动的服务,一个服务对应一个容器,也就是说在执行该文件之后,会多出两个容器<br><code>web</code>,<code>zookeeper</code>: 服务名称, 最终创建的容器名称会以启动时候指定的 <code>${project_name}</code> 加上服务的名称为完整的容器名称<br><code>build</code>: 指定构建的 <code>docker-context</code> 和 <code>dockerfile</code>, 此处都在当前目录; 详细指定格式为:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">build:</span> </span><br><span class="line">    <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">dockfile:</span> <span class="string">./dockerfile</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>
<p>ps: 这里可以指定 <code>docker-gradle</code>生成的 <code>dockerfile</code> 作为构建脚本.<br><code>image:</code> 指定构建完成之后的镜像名称,也就说执行完该文件会多一个以 <code>dengbojing/gateway:v4</code> 为名称的镜像; 下面的<code>image</code>为以<code>zookeeper</code>镜像为基础创建一个容器;<br><code>ports</code>: 对外暴露的端口  </p>
</li>
<li><p><code>networks</code>: 定义一个网络, 然后在 <code>services</code> 中使用, 此时 <code>web</code> 服务容器就可以通过下面的服务名–<code>zookeeper</code> 来访问下面的服务容器, 例:  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">zookeeper:</span></span><br><span class="line">      <span class="attr">connect-string:</span> <span class="string">zookeeper:2181</span></span><br></pre></td></tr></table></figure>
<p>ps: <code>gateway</code> 项目为<code>spring-cloud-gateway</code> 项目, 使用了 <code>zookeeper</code> 作为注册中心和配置中心, 所以需要访问 <code>zookeeper</code>.  </p>
</li>
<li><p>写到这里,简单的使用 <code>docker-compose</code> 就完成了, 不难发现对于微服务来说这种方式是非常有用的, 我们可以把我们几个服务包装成一个 <code>docker-compose</code> 项目,然后进行部署,它还支持从一个镜像启动多个容器实例–毕竟容器实例就是类的对象,有对个对象当然是没问题的; 这样以来那么一个文件里面就可以包含多个相同功能的服务,一个注册中心,一个配置中心,完美实现了集群功能.<br>当然在实际生产过程中,注册中心和配置中心肯定在不同的服务器上, 所以这种方式有一定的局限性.</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>简单的学习了一下 <code>docker-compose</code> , 其中有很多配置和命令之后实战的时候才会真的用到. 怎么说呢:    </p>
<blockquote>
<p>路漫漫其修远兮, 吾将上下而求索</p>
</blockquote>
</li>
</ol>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>springboot</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>dockerfile构建自己的应用</title>
    <url>/2020/02/01/dockerfile/</url>
    <content><![CDATA[<p>使用docker构建自己的应用</p>
<a id="more"></a>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>  自从docker入门以后,一发不可收拾,越学习越感觉有趣,本文记录一下在学习dockerfile构建自己应用遇到的坑以及学习心得  </p>
<blockquote>
<h1 id="Talk-is-cheap-show-me-the-code"><a href="#Talk-is-cheap-show-me-the-code" class="headerlink" title="Talk is cheap, show me the code"></a>Talk is cheap, show me the code</h1></blockquote>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>  使用gradle+jdk11编译及打包springboot项目,然后使用docker制作镜像  </p>
<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><p>  springboot,作为现在最流行的微服务基础框架,我相信大家已经非常非常熟悉了,即使没有使用过,肯定听说过.一般比较通用的创建方式是使用springboot官网提供的<a href="https://start.spring.io/" target="_blank" rel="noopener">创建工具</a>进行创建,如果你使用intellij idea那么也可以在创建的时候使用spring initializr,这个和使用官方提供的创建工具是一回事  </p>
<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><ol>
<li><p>FROM<br>该指令是dockerfile的起始命令,是必须的,而且必须是第一个,作用是以一个镜像为基础,在该镜像上进行定制.  </p>
<blockquote>
<p><code>FROM [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</code><br><code>FROM [--platform=&lt;platform&gt;] &lt;image&gt; [AS &lt;name&gt;]</code><br><code>FROM [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]</code>  </p>
</blockquote>
</li>
<li><p>ARG<br>该指令是声明一个变量: </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ARG &lt;name&gt;[&#x3D;&lt;default value&gt;]</span><br></pre></td></tr></table></figure>
<p> 如果想覆盖默认值,可以在执行 <code>docker build</code> 命令时候指定 <code>--build-arg &lt;name&gt;=&lt;value&gt;</code></p>
</li>
</ol>
<pre><code>ps:在FROM之前声明的ARG在构建阶段之外，因此，FROM之后的任何指令都不能使用它。要使用在第一个FROM之前声明的ARG的默认值，请使用ARG指令，且在构建阶段内部不带值  
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ARG VERSION&#x3D;latest  </span><br><span class="line">FROM busybox:$VERSION  </span><br><span class="line">ARG VERSION  </span><br><span class="line">RUN echo $VERSION &gt; image_version</span><br></pre></td></tr></table></figure></code></pre><ol start="3">
<li><p>LABEL<br>该指令添加 <code>metadata</code> 到镜像之中,格式为键值对,如: </p>
<blockquote>
<p><code>LABEL maintainer=&quot;dengbojing@qq.com&quot;</code></p>
</blockquote>
<p>   ps: 这里正好用 <code>maintainer</code> 字段来说明一下,官方已经将<code>MAINTAINER</code> 这个命令废弃,改用 <code>LABEL</code> 代替   </p>
</li>
<li><p>RUN<br>该指令有两种格式  </p>
<ul>
<li><p>shell格式, <code>RUN &lt;command&gt;</code> command将会在shell中执行,对于linux系统shell为/bin/bash, 对于windows系统shell为 cmd /S /D   </p>
</li>
<li><p>exec格式, <code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> , 注意该指令不会进行shell处理,比如 <code>RUN [&quot;echo&quot;, &quot;$home&quot;]</code> 是不会对 <code>$home</code> 处理的,你需要自己指定shell,<code>RUN [&quot;sh&quot;, &quot;-c&quot;, &quot;echo $home&quot;]</code>.   </p>
<p>该命令执行一次会产生一层layer,所以应该尽量合并 <code>RUN</code> 后面 <code>command</code> 比如:  </p>
<blockquote>
<p>RUN &amp;&amp; apt-get update <br>  &amp;&amp; apt-get install -y $buildDeps  </p>
</blockquote>
</li>
</ul>
</li>
<li><p>CMD<br>该指令主要作用是为容器提供一个默认的执行命令,三种格式:  </p>
<ul>
<li><p>exec格式, <code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code> ,该格式是官方推荐首选格式,同样该格式也不会进行shell处理.  </p>
</li>
<li><p>参数格式: <code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code>, 该格式需要指定 <code>ENTRYPOINT</code> ,作为 <code>ENTRYPOINT</code> 的参数  </p>
</li>
<li><p>shell格式, <code>CMD command param1 param2</code>   </p>
<p>ps: 该指令在文件中只有一个,如果有多个那么只有最后一个 <code>CMD</code> 才会起作用,如果在<code>docker run</code> 后面指定了其他命令或者参数会覆盖 <code>CMD</code> 后面的命令或者参数</p>
</li>
</ul>
</li>
<li><p>ENTRYPOINT<br>该指令主要作用是为容器提供一个每次都执行的命令,该命令有两种格式:  </p>
<blockquote>
<p>exec格式: <code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> ,官方推荐<br>shell格式: <code>ENTRYPOINT command param1 param2</code>  </p>
</blockquote>
<p> ps: 同 <code>CMD</code> 指令如果有多个 <code>ENTRYPOINT</code> 也只有最有一个起作用,如果想覆盖默认的<code>ENTRYPOINT</code> 可以使用: <code>docker run --entrypoint</code>;不同点在于,该指令可以直接在 <code>docker run</code> 后面跟参数,而 <code>CMD</code> 指令不可以.  </p>
</li>
<li><p>COPY<br>顾名思义,该指令主要作用就是–复制,两种格式:  </p>
<blockquote>
<p><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code><br><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</code>  </p>
</blockquote>
<p>   ps: 1. 该指令的 <code>--chown</code> 只有linux才有,windows和linux权限管理不一样;另外该指令还支持通配符  </p>
<pre><code>2. 该指令只会cp源目标下文件.  
3. 如果目标目录没有/, 则会将目标地址当成一个文件  
4. 如果目标目录不存在, 则会创建目标目录的所有层级的目录   </code></pre></li>
</ol>
<ol start="8">
<li><p>EXPOSE<br>该指令暴露一个容器内部端口到外部,格式为:  </p>
<blockquote>
<p><code>EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</code><br>   ps: 该指令并非真正暴露一个端口供外部使用,只是一种说明,说明容器内部哪些端口可以被访问,在启动时候需要使用 <code>docker run -p &lt;out port&gt;:&lt;expose port&gt;</code>   </p>
</blockquote>
</li>
</ol>
<ol start="9">
<li>WORKDIR<br>该指令指定工作目录,相当于<code>shell</code>命令里面的 <code>cd</code>,指定工作目录之后,后续的<code>COPY</code>,  <code>RUN</code>, <code>CMD</code>, <code>ENTRYPOINT</code> 等命令都是在当前目录下完成  </li>
</ol>
<h1 id="USAGE-amp-CONTEXT"><a href="#USAGE-amp-CONTEXT" class="headerlink" title="USAGE  &amp;  CONTEXT"></a>USAGE  &amp;  CONTEXT</h1><p>  当执行 <code>docker build</code> 的时候需要一个 <code>Dockerfile</code> 文件和一个 <code>context</code>, <code>context</code> 的涵义是指包含一些列文件的<code>PATH</code>或者<code>URL</code>,这里的 <code>PATH</code> 代表了文件系统的目录, <code>URL</code> 则代表了 <code>Git</code> 仓库地址.  </p>
<p>  这里文件系统的目录是包含下面的子目录以及子目录中的文件,也就是 <code>whole directory</code> 都会被作为上下文发送给 <code>docker daemon</code>.  </p>
<p>  <code>docker build</code> 构建的时候不是在CLI(命令行界面)构建而是把 <code>当前目录</code> 作为 <code>context</code> 发送给 <code>docker daemon</code>, 也就是docker的守护进程,所以说不能发送过大的目录,特别是不要在根目录执行 <code>docker build</code>, 官方推荐是使用一个空目录作为 <code>context</code> 来存放 <code>Dockerfile</code> ,仅仅添加 <code>Dockerfile</code> 需要的文件.  </p>
<p>  这里遇到一些问题,执行 <code>docker build</code> 命令的时候会将当前目录作为 <code>context</code> 发送给守护进程, 但是 <code>Dockerfile</code> 不能直接使用这些文件,官方说明为:  </p>
<blockquote>
<p>To use a file in the build context, the Dockerfile refers to the file specified in an instruction, for example, a COPY instruction  </p>
</blockquote>
<p>  翻译过来就是–<code>要使用 context 中使用某个文件, Dockerfile 指定一个命令来引用这个文件,例如: COPY 命令</code>, 换句话说,就是这些文件发送给守护进程,但是不能直接使用,得通过命令来使用(后面会说明碰到的问题).  </p>
<h1 id="制作"><a href="#制作" class="headerlink" title="制作"></a>制作</h1><h2 id="学习了dockerfile和指令之后-我想到应该有两种方式制作镜像"><a href="#学习了dockerfile和指令之后-我想到应该有两种方式制作镜像" class="headerlink" title="学习了dockerfile和指令之后,我想到应该有两种方式制作镜像"></a>学习了dockerfile和指令之后,我想到应该有两种方式制作镜像</h2><ul>
<li><p>方法一: 使用gradle构建项目,然后在使用dockerfile把jar包制作成镜像: 这种方法简单,但是感觉没什么意义啊,不过随后我还真的在<a href="https://spring.io/guides/gs/spring-boot-docker/" target="_blank" rel="noopener">springboot官方指导</a>下找到了这个方法.  </p>
<ol>
<li><p>第一步,执行gradle构建项目gradle build -x test  </p>
</li>
<li><p>第二步,编写dockerfile  </p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM openjdk:11</span><br><span class="line">LABEL maintainer&#x3D;&quot;dengbojing@qq.com&quot;  </span><br><span class="line">ARG JAR_FILE&#x3D;build&#x2F;libs&#x2F;*.jar</span><br><span class="line">COPY $&#123;JAR_FILE&#125; app.jar</span><br><span class="line">EXPOSE 8090</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;&#x2F;app.jar&quot;]</span><br></pre></td></tr></table></figure></li>
<li><p><code>docker build -t dengbojing/gateway .</code> 点代表把当前目录作为<code>context</code>发送给<code>dockerdeamon</code></p>
</li>
</ol>
</li>
<li><p>方法二: 把方法一的第一步放在Dockerfile里面,这样就少执行一步命令,</p>
<ol>
<li><p>进入项目目录,新建一个空白的 <code>Dockerfile</code> 文件,填写如下内容:  </p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM openjdk:11  </span><br><span class="line">LABEL maintainer&#x3D;&quot;dengbojing@qq.com&quot;  </span><br><span class="line">COPY . .</span><br><span class="line">RUN .&#x2F;gradlew build -x test  </span><br><span class="line">EXPOSE 8090  </span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;build&#x2F;libs&#x2F;service-gateway-0.0.1-SNAPSHOT.jar&quot;]</span><br></pre></td></tr></table></figure>

<p>   ps: 第一次写命令时候不了解 <code>Dockerfile</code> 和 <code>context</code> 的工作原理,觉得将当前工作目录发送给<code>docker daemon</code> 就能直接使用了,没有写<code>COPY . .</code>, 结果就是怎么都运行不过去,找不到<code>gradlew</code> 文件.后面 <code>Google</code> 之,看到这种写法,一脸懵,后来请教群里大神,加上仔细阅读文档,最终解惑.  </p>
</li>
<li><p>这种方法有一个弊端,就是构建之后的镜像会比较大,因为 <code>gradle</code> 构建项目阶段所需要的额外的文件最终也被添加到镜像中了, 所以官方提供了多阶段构建. 例: </p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM openjdk:11 AS build  </span><br><span class="line">LABEL maintainer&#x3D;&quot;dengbojing@qq.com&quot;  </span><br><span class="line">COPY . .</span><br><span class="line">RUN .&#x2F;gradlew build -x test  </span><br><span class="line"></span><br><span class="line">FROM openjdk:11 AS final</span><br><span class="line">WORKDIR &#x2F;app</span><br><span class="line">COPY --from&#x3D;build build&#x2F;libs&#x2F;service-gateway-0.0.1-SNAPSHOT.jar app.jar</span><br><span class="line">EXPOSE 8090  </span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;app.jar&quot;]</span><br></pre></td></tr></table></figure>

<p>   可以对比一下两种不同方式构建的镜像最后的大小, 如下图: <img src="https://i.loli.net/2020/08/04/6MwQ8Vtqpye1Wdn.png" alt="compare-v1-v2.png"><br>   可以看到,v1是通过非多阶段构建的,构建之后有1.16g大小,而通过多阶段构建,抛弃了 <code>gradle</code> 文件,只留下需要的项目jar包, 只有652M,好处显而易见.<br>   ps: 如果还想那个精简,那么可以使用 <code>jre</code> 而非 <code>jdk</code>; 我这里是使用的自己的一个<code>spring-cloud-gateway</code>项目进行学习的.  </p>
</li>
</ol>
</li>
<li><p>方法三: 以上的方法,是我直观能想到的方法,但是通过学习,找到了更简便的方法,那就是 <code>gradle插件</code> ,编写 <code>gradle构建脚本</code> ,生成 <code>docker</code> 镜像, 具体文档, 点击<a href="https://bmuschko.github.io/gradle-docker-plugin/#spring_boot_application_plugin" target="_blank" rel="noopener">这里</a>  </p>
</li>
</ul>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>  目前方法三还处于理论阶段,文档是看懂了,但是没有实质性的操作过.而且在项目构建过程中涉及到网络通信, <code>spring-cloud</code> 所有的项目都应该在注册中心注册, 我采用的 <code>zookeeper</code> 作为注册中心和配置中心, 这就涉及到了两个容器之间相互通信, 目前还没有学会, 目前做法是在宿主机启动 <code>zookeeper</code>, 然后找到 <code>docker</code> 虚拟网卡, 找到宿主机相对于 <code>docker</code> 的 <code>ip address</code> , 将镜像里面的 zk 地址改为宿主机相对于容器的ip, 这种方法很不容器化, 所以接着学习, 学会很容器化的方式方法.  </p>
<blockquote>
<p>骐骥一跃,不能十步;驽马十驾,功在不舍.</p>
</blockquote>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>springboot</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>docker入门学习</title>
    <url>/2020/01/25/docker-new/</url>
    <content><![CDATA[<p>docker入门</p>
<a id="more"></a>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>  作于2020年春节大年初一晚,此时疫情真的是猛于虎,为了避免给我媳妇她们医院带来不必要的麻烦,老实在家呆着学学新知识,提升自我.  </p>
<blockquote>
<h1 id="Talk-is-cheap-show-me-the-code"><a href="#Talk-is-cheap-show-me-the-code" class="headerlink" title="Talk is cheap, show me the code"></a>Talk is cheap, show me the code</h1></blockquote>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><blockquote>
<p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现,基于 Linux 内核的<br>   cgroup,namespace,以及 AUFS 类的 Union FS 等技术,对进程进行封装隔离,属于操作<br>   系统层面的虚拟化技术  </p>
</blockquote>
<p>   个人理解就是一种虚拟化技术,类似之前接触过的lvm(linux virtual machine),但是有很大的不同,lvm是有一套完整的系统,虚拟出一套硬件系统和操作系统,然后在该系统之上又有很多的应用;而容器技术里面的应用直接是运行在容器宿主的内核之上,也没有虚拟除一套硬件,一套操作系统;所以容器很轻便小巧.<br>   ps: 从以上描述可以看出,容器技术更适用于持续集成和devOps,有点 <code>java--Complie Once,Run Anywhere</code> 的意思,只需要打包一次,在任何地方,任何系统之上都能使用,不存在之前 <code>各种环境</code> (开发环境,测试环境,灰度环境,正式环境)导致的[这段代码在我机器上好好的啊,怎么可能有问题]</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol>
<li><p>注册docker hub 账号  </p>
</li>
<li><p>在<a href="https://docs.docker.com/" target="_blank" rel="noopener">docker</a>官方文档上找到对应操作系统的<img src="https://i.loli.net/2020/08/04/Gg3EerLRHzWOyb4.png" alt="docker.com.png"><br>ps: 文件还是有点大,建议使用迅雷等p2p工具下载.  </p>
</li>
<li><p>本人使用<code>windows专业版系统</code>,选择<code>docker desktop for windows</code>按照官网提示下载,完成之后不着急安装,此时需要先启动<code>hyper-v</code>,<code>docker desktop</code>是依赖<code>hyper-v</code>的,开启<code>hype-v</code>之后需要重启电脑,重启之后安装<code>docker desktop</code>,安装过程省略,下一步下一步即可.<br>ps: 如果你是<code>windows 家庭版</code>,请参考<a href="https://www.jianshu.com/p/1329954aa329/" target="_blank" rel="noopener">这篇文章</a>  </p>
</li>
<li><p>启动<code>docker desktop</code>,在系统托盘图标<code>右键-&gt;setting</code>,找到<code>resources-&gt;file sharing</code>,选择你要共享的盘符,因为<code>docker desktop</code>默认是使用<code>hyper-v</code>虚拟机,而<code>hyper-v</code>虚拟机默认的镜像地址都是在<code>C盘</code>,也就是系统盘,这会导致<code>c盘</code>不够用,可以直接在<code>resources-&gt;advanced</code>下面找到<code>disak image location</code>修改镜像位置,本人是没有修改,这里本人是开启了共享盘符,把之后镜像使用的存储空间映射到本地其他磁盘上,这样解决了大部分存储空间的问题,镜像存储就不管了    </p>
</li>
</ol>
<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><ol>
<li><p>打开<code>power shell</code>,这里最好是不要使用其他命令终端,本人之前学习时候使用cmd,使用cmd是有坑的,后面会讲到,输入<code>docker login</code>,按照提示输入之前在<code>docker hub</code>上注册的用户名,密码,第一次需要输入,后续可以不用,也可使用图像化界面登录,右键<code>docker desktop</code>系统托盘图标-&gt;login.  </p>
</li>
<li><p>登录之后我们就可以是用<code>docker search</code>命令来搜索我们感兴趣的仓库了,比如我们安装一个mysql吧,<code>docker search mysql</code>,可以看到有很多的<code>mysql</code>镜像,还有<code>star数</code>和<code>official</code><br>ps: 根据是否是官方提供,可将镜像资源分为两类.一种是类似 <code>mysql</code> 这样的镜像,被称为基础镜像或根镜像.这些基础镜像由 Docker 公司创建、验证、支持、提供.这样的镜像往往使用单个单词作为名字.还有一种类型,比如 <code>bitnami/mysql</code> 镜像,它是由 Docker 的用户创建并维护的,往往带有用户名称前缀.  </p>
</li>
<li><p>使用<code>docker pull</code>拉去镜像,具体命令如下  </p>
<blockquote>
<p>docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]   </p>
</blockquote>
</li>
</ol>
<pre><code>具体选项可以通过`docker pull --help` 来查看,  

- docker registry地址: 默认是docker hub,一般不需要指定
- 仓库名: 前文提到镜像名称分为两段,`&lt;username&gt;/&lt;soft name&gt;`如果不指定默认是library,即docker官方的镜像.
- tag: 标签,如果不指定默认为latest,当然可以指定需要的版本,查询tag目前本人没有找到相应的命令,只能去[docker hub](https://hub.docker.com/)搜索镜像然后查看tag    

综上所述,此时只需使用`docker pull mysql`就可以了  </code></pre><ol start="4">
<li><p>可以是用<code>docker image ls</code>或者<code>docker images</code> 查看本地镜像<img src="https://i.loli.net/2020/08/04/dIoT2zwKU4BSQV6.png" alt="docker-images.png"><br>此时可以看到镜像的大小和在<code>docker hub</code>大小是不一样的,这是因为,在<code>docker hub</code>显示的是压缩大小,<code>docker hub</code>作为一个中央镜像仓库,关心的是流量大小,而不是体积大小,所以会尽可能的压缩镜像体积;而且在这里,显示的大小可能和实际占用磁盘空间大小还不一样,这是因为,镜像是有很多文件层组成,而文件层之间又存在继承,复用的关系,如果不同的镜像使用相同的基础层,那么只需要保存一份该基础层就可以了,不同镜像的其他层可以直接引用该基础层,可以使用<code>docker system df -v</code>来查看具体的占用情况,同时可以使用<code>docker system prune</code>来清理磁盘空间.<br><code>docker image ls</code> 支持通配符,如 <code>docker images my*</code> 可以将所有my开头的镜像都列出<br><code>docker image ls -q</code> 可以只显示镜像的 <code>ID</code><br>此外还支持 <code>-f(--filter)</code> 过滤模式, 比如: <code>docker images -f since=mysql</code> 会列出在 <code>mysql</code>之后的所有镜像,将 <code>since</code> 换成 <code>before</code> 可以列出之前的镜像  </p>
</li>
<li><p>启动容器,每一个容器都是一个镜像实例,这个就像<code>java里面的oop思想</code>一样,一个镜像就是一个类,一个类的对象对应一个容器,java 里面使用<code>new</code>关键字实例化对象,这里我们使用<code>docker run</code>来启动一个容器,具体命令参数:  </p>
<blockquote>
<p>docker run [OPTIONS] IMAGE [COMMAND] [ARG…]   </p>
</blockquote>
<p>此处常用的 <code>options</code> 有 <code>-p</code> 指定端口号, <code>-P</code> 指定端口号映射为本机随机端口号; <code>-e</code> 指定容器内部的环境变量;<code>-d</code> 指定为后台启动;<code>-i</code> 保持stdin标准的输入流打开状态,即使没有链接; <code>-t</code> 分配一个伪终端, <code>-v</code> 指定文件映射,即讲本地的一个目录或者文件映射到容器内部;具体启动命令:  </p>
<blockquote>
<p>docker run -d -p 3305:3306 –privileged=true -e MYSQL_ROOT_PASSWORD=xxxx –name   mysqltest -v /f/mysql/data:/var/lib/mysql -v /f/mysql/conf/my.cnf:/etc/mysql/my.cnf -v //f/mysql/mysql-files:/var/lib mysql-files/ mysql:latest –character-set-server=utf8mb4 –collation-server=utf8mb4_unicode_ci  </p>
</blockquote>
<p>解释一下,此时我们就把容器内部的3306端口映射为宿主机的3305端口,并且设置了mysql的配置,数据存储位置,并且进行了一系列的mysql参数设置,指定了 <code>msyql root</code> 的密码为xxx,–privileged是让容器内部的用户获取宿主机特殊权限,此处一定要把文件映射在你已经共享的盘符,不然会失败  </p>
</li>
<li><p>查看容器状态, <code>docker container ls -a</code> 或 <code>docker ps -a</code> 可以看到容器的状态,映射端口,名字等;<br>使用 <code>docker stop &lt;container name\id&gt;</code> 停止容器, 使用 <code>docker start &lt;container name\id&gt;</code> 再次启动容器,注意第一次启动容器使用 <code>docker  run</code> 命令,该命令会创建并启动一个容器, 之后并不需要在run,只需要执行start就可以了,此外 <code>docker run</code> 执行时,如果指定镜像不存在,该命令会自动拉去默认仓库所匹配的镜像  </p>
</li>
</ol>
<ol start="7">
<li>删除镜像和容器<br>删除镜像使用 <code>docker image rm</code> 或 <code>docker rmi</code> 加上镜像的 <code>ID</code> 来删除镜像<br>删除容器使用 <code>docker container rm</code> 或 <code>docker rm</code> 加上容器 <code>ID</code> 删除容器,可以添加 <code>-f</code> 强制删除一个正在运行的容器;<br>此外如果只是想清理未被容器使用的镜像可以使用 <code>docker image prune</code><br>同理,可以使用  <code>docker container prune</code> 清理未运行的容器<br>如果需要删除的容器或者镜像太多,手动一个个输入就显得有点智障了,此时可以使用 <code>docker image ls -q</code> 来配合批量删除,比如:<br><code>docker rmi $(docker image ls -q -f since=mysql)</code><br>此时就会将mysql之前所有的镜像都删除<br>ps: 此处有之前说的 <code>cmd</code> 的坑,使用 <code>cmd</code> 会报错,改用 <code>power shell</code> 就不会</li>
</ol>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>基础入门就这些,后续根据自身所学内容,会陆陆续续的记录更多的东西,比如如何创建一个docker容器啊,导入导出镜像啊,私有仓库的搭建等等.  </p>
<blockquote>
<p>不积跬步，无以至千里；不积小流，无以成江海</p>
</blockquote>
<hr>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo+github pages建立静态blog</title>
    <url>/2020/01/14/first/</url>
    <content><![CDATA[<blockquote>
<p>好记性不如烂笔头</p>
</blockquote>
<p>记录一下使用hexo + github pages搭建博客的过程,以及过程中遇到的坑;同时也给阅读这篇文章,想要搭建博客的人一点帮助</p>
<a id="more"></a>
<h1 id="为什么搞独立blog"><a href="#为什么搞独立blog" class="headerlink" title="为什么搞独立blog"></a>为什么搞独立blog</h1><p><code>市面上blog service多如牛毛为啥非要搞自己的,因为独立的才是自己的</code></p>
<h1 id="为什么使用gihub-pages"><a href="#为什么使用gihub-pages" class="headerlink" title="为什么使用gihub pages"></a>为什么使用gihub pages</h1><p><code>因为不用买服务器,免费而且稳定,也无需域名,只需要你有github账号就能用</code></p>
<blockquote>
<h1 id="Talk-is-cheap-show-me-the-code"><a href="#Talk-is-cheap-show-me-the-code" class="headerlink" title="Talk is cheap, show me the code"></a>Talk is cheap, show me the code</h1></blockquote>
<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><ol>
<li><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">git</a>根据自己电脑下载相应版本,本人是win10电脑使用git bash.</li>
<li>安装完成打开<code>git bash</code>, 输入<code>git --version</code>测试是否安装成功</li>
<li>注册<a href="https://github.com/" target="_blank" rel="noopener">github</a>账号(全球最大的同性交友网站,你值得拥有).</li>
<li>新建<code>&lt;username&gt;.github.io</code>仓库.</li>
</ol>
<h1 id="node"><a href="#node" class="headerlink" title="node"></a>node</h1><ol>
<li><a href="http://nodejs.cn/download/]" target="_blank" rel="noopener">node</a>根据自己电脑下载相应版本</li>
<li>安装完成之后,在之前的<code>git bash</code>输入<code>node --version</code>测试是否安装成功</li>
</ol>
<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><ol>
<li><p>安装好 Node.js 后，通过 npm 安装 Hexo</p>
<blockquote>
<p>npm install hexo-cli -g</p>
</blockquote>
<p> ps: 可能安装失败,如果失败,安装cnpm,然后在安装hexo;或者挂代理,走梯子</p>
<blockquote>
<p>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p>
</blockquote>
</li>
<li><p>安装 Hexo 完成后,执行</p>
<blockquote>
<p>hexo init &lt;folder&gt;<br>cd &lt;folder&gt;<br>npm install  </p>
</blockquote>
<p> 执行完成之后目录会像</p>
<blockquote>
<p>├── _config.yml<br> ├── node_modules<br> │   ├── hexo<br> │   ├── hexo-generator-archive<br> │   ├── hexo-generator-category<br> │   ├── hexo-generator-index<br> │   ├── hexo-generator-tag<br> │   ├── hexo-renderer-ejs<br> │   ├── hexo-renderer-marked<br> │   ├── hexo-renderer-stylus<br> │   └── hexo-server<br> ├── package.json<br> ├── scaffolds<br> │   ├── draft.md<br> │   ├── page.md<br> │   └── post.md<br> ├── source<br> │   └── _posts<br> └── themes  </p>
<pre><code>└── landscape  </code></pre></blockquote>
<p> ps: 简单说明一下目录作用   </p>
<blockquote>
<p> _config.yml  配置文件,网站的标题,作者,主题配置等<br> node_modules hexo的模块,较少关心<br> package.json 项目描述文件,不用关心<br> scaffolds  模版配置,较少关心<br> source–&gt;_post  主要存放我们写的文章<br> themes  <a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo主题</a>,文件夹名称对应为主题名称  </p>
</blockquote>
</li>
<li><p>配置_config.yml</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: Hexo #标题</span><br><span class="line">subtitle: #副标题</span><br><span class="line">description: #描述</span><br><span class="line">author: #你的名字</span><br><span class="line">language: zh #网站使用的语言,注意使用主题下面的语言(themes--&gt;&lt;要使用的主题&gt;--&gt;languages)不然会出现未知结果</span><br><span class="line">timezone: Asia&#x2F;Shanghai #网站时区 </span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">url: https:&#x2F;&#x2F;dengbojing.com #地址(如果未申请域名则不需要填写)</span><br><span class="line">root: &#x2F; #根目录</span><br><span class="line">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F; #文章的永久链接格式</span><br><span class="line">permalink_defaults: #</span><br><span class="line">    trailing_index: true # Set to false to remove trailing &#39;index.html&#39; from permalinks</span><br><span class="line">    trailing_html: true # Set to false to remove trailing &#39;.html&#39; from permalinks</span><br><span class="line"></span><br><span class="line"># Directory</span><br><span class="line">source_dir: source #资源文件夹</span><br><span class="line">public_dir: public #由资源文件夹生成而来</span><br><span class="line">tag_dir: tags #标签文件夹,默认是没有的需要使用hexo new page tags 自行创建</span><br><span class="line">archive_dir: archives #归档文件夹</span><br><span class="line">category_dir: categories #分类文件夹,默认是没有的需要使用hexo new page tags 自行创建</span><br><span class="line">code_dir: downloads&#x2F;code #Include code 文件夹</span><br><span class="line">i18n_dir: :lang #国际化（i18n）文件夹</span><br><span class="line">skip_render: #跳过指定文件的解析</span><br><span class="line"></span><br><span class="line"># Writing</span><br><span class="line">new_post_name: title.md # 新文章的文件名称</span><br><span class="line">default_layout: post #预设布局</span><br><span class="line">titlecase: false # 把标题转换为单词首字母大写</span><br><span class="line">external_link: </span><br><span class="line">    enable: true # 在新标签中打开链接</span><br><span class="line">    field: site</span><br><span class="line">    exclude: &#39;&#39; #排除文件</span><br><span class="line">filename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写</span><br><span class="line">render_drafts: false #显示草稿</span><br><span class="line">post_asset_folder: false #启动 Asset 文件夹，为 true 时，每次建立文件时，Hexo 会自动建立一个与文章同名的文件夹</span><br><span class="line">relative_link: false #把链接改为与根目录的相对位址</span><br><span class="line">future: true #显示未来的文章</span><br><span class="line">highlight: #代码块高亮,很多主题要求此项为false</span><br><span class="line">    enable: true</span><br><span class="line">    line_number: true</span><br><span class="line">    auto_detect: true</span><br><span class="line">    tab_replace:</span><br><span class="line"></span><br><span class="line"># Category &amp; Tag</span><br><span class="line">default_category: uncategorized #默认分类</span><br><span class="line">category_map: #分类别名</span><br><span class="line">tag_map: #标签别名</span><br><span class="line"></span><br><span class="line"># Date &#x2F; Time format</span><br><span class="line">date_format: YYYY-MM-DD #日期格式</span><br><span class="line">time_format: HH:mm:ss #时间格式</span><br><span class="line"></span><br><span class="line"># Pagination</span><br><span class="line">per_page: 10 #每页显示的文章量 (0关闭分页功能)</span><br><span class="line">pagination_dir: page #分页目录</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">theme: next #当前主题名称(本人使用的非默认主题)</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">deploy: #部署</span><br><span class="line">    type: git</span><br><span class="line">    repo: https:&#x2F;&#x2F;github.com&#x2F;username&#x2F;username.github.io.git #仓库地址</span><br><span class="line">    branch: master #分支名称</span><br></pre></td></tr></table></figure></li>
<li><p>打开看看, 在<code>git bash</code>中使用 <code>hexo g</code> 命令生成文章,<code>hexo s</code>命令启动服务,下面提示访问<a href="http://localhost:4000" target="_blank" rel="noopener">localhost:4000</a>,访问一下看到使用默认主题的网站  </p>
</li>
</ol>
<h1 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h1><p>  使用<code>hexo new post &lt;filename&gt;</code> 创建自己的第一篇文章<br>  找到source–&gt;_post,打开<code>&lt;filename&gt;.md</code><br>  <strong><em>更多<a href="https://hexo.io/zh-cn/docs/writing" target="_blank" rel="noopener">写作</a>用法</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 使用hexo+github pages建立静态blog</span><br><span class="line">date: 2020-01-14 19:32:51</span><br><span class="line">tags: [git,hexo]</span><br><span class="line">categories: hexo</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>  在date下面添加分类和标签,可选<br>  在—下面写正文内容,可以使用<code>&lt;!--more--&gt;</code>分割  </p>
<blockquote>
<p>比如:   </p>
</blockquote>
<pre><code>简介  
&lt;!--more--&gt;
正文  </code></pre><h1 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h1><p>hexo g生成<br>hexo s启动<br>打开浏览器,输入<a href="localhost:4000">localhost:4000</a>看看吧  </p>
<h1 id="部署到服务器"><a href="#部署到服务器" class="headerlink" title="部署到服务器"></a>部署到服务器</h1><p>  安装一键部署</p>
<blockquote>
<p>npm install hexo-deployer-git –save  </p>
</blockquote>
<p>  执行 <code>hexo clean</code>(可选,正常情况不需要)<br>  <code>hexo d</code> 部署到<code>&lt;username&gt;.github.io</code></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>  使用过程中遇到很多问题,目前都没有解决,<br>  比如有些主题莫名看不到tags和categories仓库,最后选来选去只能使用next主题<br>  还有写modules(比如七牛云)安装之后即使你不启用你也得写配置  </p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
