{"meta":{"title":"生活不易,砥砺前行","subtitle":"Keep farmed and carry hard","description":"","author":"Dengbojing","url":"http://dengbojing.com","root":"/"},"pages":[{"title":"","date":"2020-01-15T03:33:52.175Z","updated":"2020-01-15T03:33:52.175Z","comments":true,"path":"404.html","permalink":"http://dengbojing.com/404.html","excerpt":"","text":"你要找的内容不存在! 返回首页"},{"title":"tags","date":"2020-01-14T12:42:52.000Z","updated":"2020-01-14T12:43:46.157Z","comments":true,"path":"tags/index.html","permalink":"http://dengbojing.com/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2020-01-15T02:32:15.000Z","updated":"2020-01-15T12:10:22.196Z","comments":true,"path":"about/index.html","permalink":"http://dengbojing.com/about/index.html","excerpt":"","text":"About 少壮不努力,后跳带剑气 java-web开发者,就职于一家混日子的小公司,每天过着摸鱼的生活,很少加班,也不掉头发,完全一个假程序员,不过我很开心. 虽然工作年限也不短了,但是还远没有到知识输出那个境界,开此博客主要目的就收记录我积累的只是和经验,有些东西靠脑子记还真容易忘掉. 没开放评论,因为如果要问什么,我估计会被问懵逼,如果真要和我杠,请发送邮件至dengbojing@qq.com,我这人还是比较钢精的,说不定会回邮件;同样如果你有什么好的东西和我分享或者愿意指导我,那鄙人会欣喜若狂. 至于本站内容,随便复制粘贴,知识只有传播和分享才能体现他的价值,不然就是一堆冰冷的文字."}],"posts":[{"title":"Effective-java-第四章学习笔记","slug":"Effective-java-第四章学习笔记","date":"2021-04-07T06:25:59.000Z","updated":"2021-05-12T12:34:01.210Z","comments":true,"path":"2021/04/07/Effective-java-第四章学习笔记/","link":"","permalink":"http://dengbojing.com/2021/04/07/Effective-java-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"第四章: 类和接口","text":"第四章: 类和接口 引言这章主要讲了类和接口的设计原则,如何设计除更健壮,更灵活的类和接口. 正文使类和成员的访问最小化以及在公有类中使用访问方法而非公有域前面两条实质上讲的是一件事,就是不要暴露类的内部成员,如果是公有类(一般情况我们写的都是public的类)一定不能暴露内部的成员,而是使用getter和setter.尽可能的降低内部成员的可访问性. 这么做的好处就是封装性比较强, 也灵活很多,如果将来想在类的成员上做限制,直接在getter或者setter上做改变就可以, 外部调用者完全感受不到变化. 如果编写一个不可变的类 不要提供任何会修改对象状态的方法–比如setter 保证类不会被扩展–使用final修饰符或者private的构造器. 将所有的域(类的成员)都设置成private final的. 确保任何可变组件的互斥访问–就是如果类的成员是一个对象引用, 则保证这个引用不会被外部获取到. functional: 不改变当前实例, 而是创建一个返回一个新的实例的方法. 这种方法被称为functional. 这种方法的方法名都使用介词. 不可变对象的优点: 不可变对象是线程安全的, 不要求同步. 不可变对象可以自由的共享, 甚至可以共享他们的内部信息. 不可变对象可以为其他对象提供构件. 不可变对象提供了原子性. 不可变对象的缺点每一个不同的值都需要一个对象, 如果创建不可变对象代价太高, 那么可能会导致程序性能下降. 一般不可变对象都提供一个对应的可变的配套类,比如String和StringBuilder. 组合(复合)优于继承 继承打破了封装性.子类依赖父类其中特定的功能细节,如果将来父类改变了,那么子类也会跟着发生相应的变化,往往这些变化不是子类自己能控制的. 除非父类是专门用来被继承的或者有很好的说明该如何继承该类, 否则最好使用组合. 如果A和B两者直接存在is-a的关系才应该使用继承, 在实现继承时候, 要反复的确定 B 在任何时候都是一个 A 类型. 如果不是, B 仅仅是使用了 A 的一个功能, 那么就应该使用组合模式. 要么设计继承并提供文档, 要么禁止继承这条其实是对于上面那条的补充说明, 上一条说如果继承了一个不是用来被继承的类,是一件很危险的事情, 可能导致封装性被破坏, 在设计一个被继承的类时, 要有良好的说明 该类必须有说明可以被重写的方法的自用性–即类必须在文档中说明,在哪些情况下它会调用被重写的方法. 对于为了继承而设计的类, 必须在发布之前先编写子类对其进行测试. 构造器不可以调用可以被重写的方法. clone和readObject 方法也不能调用可以被重写方法. 接口优于抽象类如果是对实现类的规范和约束则应该使用抽象类, 如果想实现多继承则应该使用接口. 接口的可扩展性要优于继承. 接口的使用 为后代设计接口. 接口只用于定义类型. 不要使用常量接口. 写在最后整章对于在写代码设计类的层次接口非常有用, 但是由于使用spring框架, 很多事情spring都帮你做了, 这些设计原则用到的机会不是非常多, 导致里面有很多东西看了似懂非懂, 所以以后还是要离开spring框架单独做一些非web项目, 这样才能有较深的感悟.","categories":[],"tags":[{"name":"java, 读书笔记","slug":"java-读书笔记","permalink":"http://dengbojing.com/tags/java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"Effective-java-第三章学习笔记","slug":"Effective-java-第三章学习笔记","date":"2021-03-08T12:01:55.000Z","updated":"2021-04-07T06:23:27.627Z","comments":true,"path":"2021/03/08/Effective-java-第三章学习笔记/","link":"","permalink":"http://dengbojing.com/2021/03/08/Effective-java-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"第三章: 重写Object类中的几个方法","text":"第三章: 重写Object类中的几个方法 引言这一章主要讲的是Object类中的几个方法该如何重写.实际上本章内容没有在开发实践中并不会出现,一般开发人员都用lombok或者其他工具类实现了Object中的方法,很少遇到自己重写的情况,而且在正常逻辑上也不会违背文中所说的注意点. 正文重写equals方法在一下3种情况不应该重写equals 该类不是一个值类,是代表活动实体的类,比如Thread. 该类没必要提供逻辑相等,比如单例类,只会产生一个实例,Object类提供的地址相等的equals方法已经足够;再比如一些工具类xxxUtil,xxxxBuilder等,实际上这些类有时候无法实例化,所以没必要重写equals方法 该类是私有的或者包级私有的,可以确保equals方法不会被调用.(这句才是重点) 重写equals时遵循的规范 自反性(reflexive): 对于任何非null的引用值x, x.equals(x)必须返回true. 对称性(symmetric): 对于任何非null的引用值x和y, 当且仅当y.equals(x)返回true, x.equals(y)必须返回true. 传递性(transitive): 对于任何非null的引用值x,y,z, 如果x.equals(y)返回true,y.equals(z)返回true, 那么x.equalis(z)也返回true 一致性(consistent): 对于任何非null的引用值x,y,只要对象中的信息没有被修改过,那么多次调用x.equals(y)的结果必然一致. 任何对象equals(null)必然返回false. 以上规范,看起来挺复杂,实际上属于一种自然而然的做法,在重写equals的时候,很自然的就做到了.最好的方法就是使用第三方库来重写equals省事,还不会出错,除非你有非常特别的理由要自己手动重写. 重写equals时注意事项 不要依赖不可靠资源,比如java.net.URL中主机ip地址的比较,可能会存在host不变但是ip变了. 优先比较最有可能不一致的字段,或者开销比较低的字段,最理想是二者兼备,有这些字段组成关键字段. 重写equals时总是重写hashCode方法. 不要让equals过于智能. 重写equals方法的步骤 使用==操作符检查对象引用是否相等. 如果是,那么是同一个对象,直接返回true. 使用instanceOf检查参数类型是否正确. 类型转换.(如果是jdk 14以上可以和上一步合并: if(o instanceof X x){}) 对该类型中的关键字段进行比较.如果是除浮点数之外的基本类型,直接用==判断,如果是对象递归使用equals,如果是浮点数(float,double)使用Float.compare(param1,param2), Double.compare(param1,param2),原因是float和double中存在Float.NaN,-0.0f 这样的常量. 总结: 总之不要轻易的自己重写equals方法,在多数情况下并不需要,如果需要请使用第三方,如果还不满足在自己动手写. 重写equals方法时重写hasCode方法特点 如果两个对象equals, 那么他们必然具有相同的hashCode. 为什么?因为在使用hashMap等集合时, 如果相等的对象具有不同的hashCode,可能会放在不同的bucket中,这样导致get逻辑上相等的对象时, 会出现获取不到对象.2. 如果两个对象不equals, 但是他们可能具有相同的hashCode, 但是最好不要, 因为这样HashMap等依赖hashCode方法的集合类会变的性能非常低下,最好是不同的对象具有不同的hashCode 重写步骤 定义一个result存储第一个关键字段的hashCode. 关键字段的hashCode的计算: a. 若果字段是基本类型,则调用对应的包装类型的hashCode(value)方法,如: Integer.hashCode(code). b. 如果字段是对象引用,并且equals中使用到这个字段时, 则同样的递归的调用该字段的hashCode方法. 如果需要更复杂的比较, 则可以为这个字段计算一个范式,然后针对这个范式计算hashCode. 如果该字段是null则返回0 c. 如果字段是一个数组,则逐个计算数组中的元素的hashCode,如果数组不重要,返回一个常量,但最好不是0. 根据前两步骤计算,合并除最后的hashCode 完整示例: 123456public int hashCode() &#123; int result = Short.hashCode(param); result = 31 * result + Integer.hashCode(param1); result = 31 * result + Double.hashCode(param2); return result;&#125; 使用乘法使得hashCode依赖字段顺序,设想一下如果不用乘法那么abc和bac将会拥有相同的hashCode,这显然是不对的.使用31这个数字书中给出的原因是: 因为它是一个奇素数,习惯上使用,可以使用移位和减法来优化乘法31 * i == (i &lt;&lt; 5) - i,而且虚拟机自动完成这一优化;如果想知道更多具体内容请参考stackoverflow上的回答 重写toString方法该条主要作用是在日志或者输出对象时候,比较容易的读懂对象中的信息,书上说的有点啰嗦,最简单的方法是使用三方json库将对象直接按json输出.不建议自己手写,字段多了容易遗漏外加出错. 重写clone方法通用约定(非必须) x.clone() != x; x.clone().getClass() == x.getClass(); x.clone().equals(x); 实现步骤 调用super.clone(), 然后转换类型. 如果该类包含数组引用类型的字段, 并且是非final的, 那么调用该字段的clone()方法. 如果该类包含引用类型中的字段还包含其他引用类型,那么递归调用,进行深拷贝. 使用构造拷贝器–一个接收自身类型为参数的构造函数. 或者使用构造器静态工厂方法. 总结: 实际生产过程中, 很少遇到需要调用clone方法来获取对象. 考虑实现comparable接口如果是在编写一个值类(value class)并且可能排序敏感,那么建议你实现comparable接口,这样当这个类的实例添加到集合里面的时候,便于搜索,分类,排序. 通用约定 sgn(x.compareTo(y)) == -sgn(y.compareTo(x)),其中sgn为signum函数,根据表达式的值,返回-1,0或者1. 如果x.compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0 则 x.compareTo(z) &gt; 0. 如果x.compareTo(y) == 9 那么有x.compareTo(z) == y.compareTo(z). 如果x.compareTo(y) == 0 那么他们最好是相等, 如果不等请注明. 实现实现该方法时,最好不要使用&lt;, &gt;符号. 1234567891011public int compareTo(PhoneNumber pn)&#123; int result = Short.compare(this.areaCode, pn.areaCode); if(result == 0)&#123; result = Short.compare(this.prefix, pn.prefix); if(result == 0)&#123; result = Short.compare(this.lineNum, pn.lineNum); &#125; ... &#125; return result;&#125; 或者使用java 8中Comparator中的函数式接口实现 123456public static final Comparator&lt;PhoneNumber&gt; COMPARATOR = comparingInt(pn -&gt; pn.araeCode) .thenComparingInt(pn -&gt; pn.prefix) .thenCOmparingInt(pn -&gt; pn.lineNum);public int compareTo(PhoneNumber pn)&#123; return this.COMPARATOR.compare(this, pn);&#125; 后记实际开发过程中很少用到该章节知识, equals, hasCode, toString等方法都是用第三方类库实现, comparable接口, 在流式处理集合的时候可以手动指定比较器. 总之, 该章节内容,理论大于实践, 只有在很少的情况用到, 自己有特殊的需求时才会用到.","categories":[{"name":"java","slug":"java","permalink":"http://dengbojing.com/categories/java/"}],"tags":[{"name":"java, 读书笔记","slug":"java-读书笔记","permalink":"http://dengbojing.com/tags/java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"Effective_java_第二章学习笔记","slug":"Effective-java-第二章学习笔记","date":"2021-03-03T06:27:01.000Z","updated":"2021-04-07T06:24:02.431Z","comments":true,"path":"2021/03/03/Effective-java-第二章学习笔记/","link":"","permalink":"http://dengbojing.com/2021/03/03/Effective-java-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"第二章: 创建和销毁对像","text":"第二章: 创建和销毁对像 引言第一章主要讲除了用构造函数之外,如何创建一个对象,以及他们之间的利弊 正文 使用静态工厂方法创建对象. 在对象方法内部,或者使用一个单独的工具类来维护一些静态的创建该类的对象的方法. 工具类(书中术语叫做伴生类)命名方式一般在该类的后面加s, 比如Collection 和 Collections , Collector 和 Collectors 工厂方法的命名方式一般有: from 类型转换方法, 从一个对象中获取我们想要的类的对象,通常只有一个参数. 如: 1NewsBody newsbody = NewsBody.from(news); of 聚合方法,将多个参数聚合在一起, 如: 1NewsBody newsbody = NewsBody.of(news.getTitle(),news.getAuthor(),news.getReleaseDate()); valueOf 功能和上面两个类似, 只是相对来说更加啰嗦, 如: 1NewsBody newsBody = NewsBody.valueOf(news); instance or getInstance 根据给定的参数(可选)来创建对象,但是不能保证该对象一定和参数所描述的对象一致, 如: 1NewsBody newsBody = NewsBody.instance(news); // 可能newsbody中的author字段或者其他字段与参数news中的不一致 create or newInstance 根据参数每次都返回一个新的对象, 如: 1NewsBody newsBody = NewsBody.create(news); getType 功能和getInstance相同,只是该方法处于工具类中, 如java nio2中: 1FileStore fs = Files.getFileStore(path); newsType 功能和newInstance相同, 只是该方法处于工具类中, 如: 1BufferedReader br = Files.newBufferedReader(path); 静态工厂的优点: 除了上述通用的命名方式之外, 可以起一个见名知意的方法, 书中举例为BigInteger中获取素数的方法. 第二个优点是可以控制返回的实例,可以在第一次创建时候缓存起来,以便之后使用,经典案例就是单例模式和享元模式(String采用的模式). 伪代码: 123456public class Elvis&#123; private static final Elvis INSTANCE = new Elvis(); private Elvis()&#123;&#125; public static Elvis getInstance()&#123;return INSTANCE;&#125; public String doSth()&#123;&#125;&#125; 由于INSTANCE是静态的, 所以在类加载时就会创建类的实例, 天然避免了多线程并发问题, 使用静态工厂方法获取该实例, 则每次都获取相同的实例. 第三个优点就是多态. 这个是面向对象三大特性中的重要特性. 使用静态工厂方法, 你可以返回任意一个子类的对象.书中讲述了Collections的由来, 但是在java 8之后, 接口是可以包含静态方法的,所以伴生类存在的理由就很薄弱. 第四个优点是可以根据参数的不同, 静态工厂方法返不同类型的对象.(这一点理解比较模糊,感觉和上一条重复). 第五个优点在编写静态工厂方法时候, 方法返回对象所属的类, 不一定存在. 还是利用多态的特性. 书中举例SPI(Service Provider Interface)机制, 在编写Driver.getConnection() 具体的Connection实现类不一定存在, 由各大数据库厂商自己提供实现. 静态工厂的缺点: 必须提供一个public或者protected的构造函数, 否则无法子类化. 第二个缺点是不好找到, 如果是在该类内部还好, 如果是工具类, 那么就不容易被发现. 扩展: SPI主要是使用ServiceLoader加载位于META-INF/services下面配置的具体的实现类来完成服务. 具体角色如下: Service Provider Interface 服务提供者接口, 通常一种约定, 约定了实现了该接口的类会提供哪种服务. Service Providers 服务的具体提供者, 实现了Service Provider Interface. 并将该类全限定名称写在META-INF/services目录下以服务提供者接口命名的文件中. ServiceLoader 用来加载META-INF/services下所有配置的服务具体提供者的类. 1ServiceLoader&lt;T&gt; serviceLoader = ServiceLoader.load(服务提供者.class); 遇见多参数构造函数时,考虑使用Builder模式. 如果参数过多可以使用重叠构造器, 即构造器套构造器这种, 或者使用javaBean, 即setXxx(), 这两种方式来创建对象. 第一种方法, 代码臃肿不好维护, 而且可读性也差, 如果参数多了就会不知道构造器里面参数是干什么的, 一般有思想的程序员都不会写出来这种代码. 第二种方法我们在编码过程中经常使用,如: news.setAuthor(&quot;dengbojing&quot;), news.setTitle(&quot;xxxx&quot;), news.setReleaseDate(new LocalDate()), news.setContent(&quot;xxxx&quot;) 等等, 该方法弊端就是会出现在构造过程中出现对象状态不一致, 因为构造过程分为几个步骤(分别设置所有属性). 此时使用Builder模式就很容易避免上述错误, 在jdk中其实有很多地方都是使用这种方法, 比如: 123456789101112var httpClient = HttpClient.newBuilder() .authenticator(Authenticator.getDefault()) .connectTimeout(Duration.ofSeconds(10)) .cookieHandler(CookieHandler.getDefault()) .executor(Executors.newFixedThreadPool(2)) .followRedirects(HttpClient.Redirect.NEVER) .priority(1) .proxy(ProxySelector.getDefault()) .sslContext(SSLContext.getDefault()) .sslParameters(new SSLParameters()) .version(HttpClient.Version.HTTP_2) .build(); 有现成lombok插件可以通过@Builder注解实现Builder模式, 方便快捷. 简而言之, 就是如果类里面有很多参数时候, 使用Builder 就是一个很不错的额选择. 用私有构造器或者枚举类型来强化单例模式 单例模式,老生常谈的话题, 具体衍生有饱汉模式, 饿汉模式(翻译过来), 双重检测等等专业名词, 总结一句话: 单元素的枚举类型经常成为单例模式的最佳实践. 通过private构造器来增强不可实例化的类 该条主要针对工具类,包含一些列静态参数或者方法,实例化这些类无意义,所以应该采用私有的构造函数. 使用依赖注入代替硬编码 依赖注入指的是在构造函数或者静态工厂方法中,传入参数来注入所需要的资源(如: this.resource = recource).其中需要注入的资源具有不可变特性. 需要引用底层资源的类不适合使用静态工具类和单例类来实现. 因为这两种方式都不能主动实例化对象, 每次获取的都是同一个底层资源, 所以不适合. 也不适合直接在这种类(需要依赖底层资源)中实例化需要的资源, 应该将这些资源或者资源工厂方法传递到构造函数或者静态工厂方法中, 通过这些来创建这种类 避免创建不需要的对象 String 对象, 这种频繁使用的对象, 则应该避免创建而是直接使用字符串池中的对象. 简而言之就是不要显示创建. 优先使用基本类型, 要避免自动拆箱装箱. 后记剩下几条不是很重要,消除过期引用, 这个在源码里面可以看到, 就是将对象引用等于null; 不使用finalizer方法,这个方法从来都没用过,只在面试题见过; 使用try-with-resource 一般都会使用这种方式.","categories":[{"name":"java,读书笔记","slug":"java-读书笔记","permalink":"http://dengbojing.com/categories/java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://dengbojing.com/tags/java/"}]},{"title":"java_11_new_http","slug":"java-11-new-http","date":"2020-12-10T01:21:53.000Z","updated":"2020-12-23T12:20:20.872Z","comments":true,"path":"2020/12/10/java-11-new-http/","link":"","permalink":"http://dengbojing.com/2020/12/10/java-11-new-http/","excerpt":"java.net.http模块使用","text":"java.net.http模块使用 引言写代码的时候难免会远程调用别人的api,之前用httpclient,在接着是okhttp,也都是跟着项目上用的,其实java 9就出现了一个http模块,只是当时是孵化版本,java 11正式推出了. 简介主要类和接口 类 java.net.http.HttpClient java.net.http.HttpHeaders java.net.http.HttpRequest java.net.http.HttpRequest.BodyPublishers java.net.http.HttpRequest.BodyHanler java.net.http.HttpRequest.BodySubscribers 接口 java.net.http.HttpClient.Builder java.net.http.HttpRequest.BodyPublisher java.net.http.HttpRequest.Builder java.net.http.HttpResponse&lt;T&gt; java.net.http.HttpResponse.BodyHandler&lt;T&gt; java.net.http.HttpResponse.BodySubscriber&lt;T&gt; java.net.http.HttpResponse.PushPromiseHandler&lt;T&gt; java.net.http.HttpResponse.ResponseInfo java.net.http.WebSocket java.net.http.WebSocket.Builder java.net.http.WebSocket.Listener 基本使用 jdk 9之后都是使用模块化组织代码,所以创建一个模块化的项目让后引入java.net.http模块. 123module com.dbj.httpClient&#123; requires java.net.http&#125; 创建httpClient 使用builder模式创建对象, 基本上该包下面所有的对象都使用builder模式创建对象, 这么做的好处参见effective java一书 12345678910111213var httpClient = HttpClient.newBuilder() .authenticator(new BasicAuthenticator(\"user\", \"password\")) //.authenticator(Authenticator.getDefault() .connectTimeout(Duration.ofSeconds(10)) .cookieHandler(CookieHandler.getDefault()) .executor(Executors.newFixedThreadPool(2)) .followRedirects(HttpClient.Redirect.NEVER) .priority(1) .proxy(ProxySelector.getDefault()) .sslContext(SSLContext.getDefault()) .sslParameters(new SSLParameters()) .version(HttpClient.Version.HTTP_2) .build(); or 1var httpClient = HttpClient.newHttpClient(); equivalent 1var httpCLient = HttpClient.newBuilder().build(); httpClient 类似String 设计模式是不变的,所以没有提供方法改变创建时候的参数. 如果使用http2创建链接,但是服务端不支持,那么会自动降级成为http1.1,如果没有指定,默认也是使用http2 excutor() 在使用异步请求时候使用,默认是使用线程池技术 connectionTimeout() 默认没有超时时间 priority() 优先级,范围[1-256],不在此范围会抛出异常 connectTimeout() 链接超时设置,在设定的时间内没有连接上则抛出HttpConnectTimeoutException executor() 用于异步任务执行,如果未指定,则会为每个HttpClient实例创建一个. followRedirects() 当服务器返回30x时,是否跳转,默认不跳转 authenticator() 验证参数,Authenticator.getDefault()获取当前验证规则,可以使用BasicAuthenticator来传递用户名密码,也可以继承Authenticator实现自己的验证规则. proxy() 是否使用代理. 创建HttpRequest 12345678var httpRequset = HttpRequest.newBuilder(URI.create(\"\")) .header(\"Content-Type\",\"application/json\") .header(\"token\",\"faeaafwefeawgaer\") .timeout(Duration.of(10, ChronoUnit.SECONDS)) .expectContinue(true) .POST(HttpRequest.BodyPublishers.ofString(\"\")) .version(HttpClient.Version.HTTP_2) .build(); uri() 可以在newBuidler() 中指定请求地址,也可以调用uri()方法指定请求地址.两者效果是一样的 header() 效果与setHeader()相同,另有headers()批量设置请求头, 请求头键值对必须严格按照RFC7230-section-3.2约定,否则抛出异常. timeout() 请求超时时间设置,超过设定时间未收到响应则抛出异常,如不限制会永远阻塞(等待) POST() GET() DELETE() PUT() 请求方法,或者使用mehtod()设置请求方法 使用前后端分离时候往往前端会发送一次options请求来判断后端是否支持跨域,此时就可以使用method(&quot;OPTIONS&quot;,BodyPublishers.noBody()) BodyPublishers 用于构建BodyPublisher的工具类,包含了一系列实用的构建请求体的方法,其中BodyPublishers 主要是调用RequestPublishers 来完成创建,RequestPublishers 中包含了很多BodyPublisher接口的实现 HttpResponse 同步请求 1var httpResponse = httpClient.send(requset,BodyHandlers.ofString()); 异步请求 1234567var httpResponse = httpClient.sendAsync(httpRequest, HttpResponse.BodyHandlers.ofString()) .thenApply(stringHttpResponse -&gt; &#123; System.out.println(stringHttpResponse.statusCode()); return stringHttpResponse; &#125;) .thenApply(HttpResponse::body) .thenAccept(System.out::println); or 批量请求接口 123456789101112131415 var client = HttpClient.newHttpClient();List&lt;HttpRequest&gt; requests = paths.stream() .map(path -&gt; \"https://localhost:8443\" + path) .map(URI::create) .map(uri -&gt; HttpRequest.newBuilder(uri).build()) .collect(Collectors.toList()); CompletableFuture&lt;?&gt;[] responses = requests.stream() .map(request -&gt; client.sendAsync(request, BodyHandlers.ofString()) .thenApply(HttpResponse::body) .exceptionally(e -&gt; \"Error: \" + e.getMessage()) .thenAccept(System.out::println)) .toArray(CompletableFuture&lt;?&gt;[]::new); 异步请求返回一个CompletableFuture&lt;HttpResponse&lt;T&gt;&gt;,当有响应返回时,该对象后续回调将会被调用.异步请求使用创建httpClient时指定的executor来执行异步请求. HttpResponse为一个接口, 不能直接创建, 所有实例都是httpClient请求返回, 接口提供方法如下: 返回值 方法 描述 T body() 返回响应体 HttpHeaders headers() 返回响应投 int statusCode() 返回的状态码 HttpRequset request() 返回对应的请求体 URI uri() 返回请求地址 HttpClient.Version version() 返回http请求协议版本 BodyHandlers 用于构建BodyHandler的工厂类. 进阶使用 JSON请求 发送请求时秩序指定Content-Type为application/json, 然后将对象转换为json字符串 12345var httpRequest = HttpRequest.newBuilder(URI.create(\"\")) .header(\"content-type\",\"application/json\") .GET() .build(); 接受响应时,自定义BodyHandler将返回的json字符串转换为对象 12345678910111213141516171819202122232425262728public class JsonHandler&lt;T&gt; implements HttpResponse.BodyHandler&lt;T&gt; &#123; private final Class&lt;T&gt; type; private final Gson gson; public JsonHandler(Class&lt;T&gt; type, Gson gson) &#123; this.type = type; this.gson = gson; &#125; @Override public HttpResponse.BodySubscriber&lt;T&gt; apply(HttpResponse.ResponseInfo responseInfo) &#123; return HttpResponse.BodySubscribers.mapping(HttpResponse.BodySubscribers.ofByteArray(),bytes -&gt; gson.fromJson(new String(bytes),this.type)); &#125; public static class JsonHandlers &#123; private JsonHandlers()&#123;&#125; public static &lt;T&gt; JsonHandler&lt;T&gt; ofType(Class&lt;T&gt; type)&#123; return of(new Gson(), type); &#125; public static &lt;T&gt; JsonHandler&lt;T&gt; of(Gson gson, Class&lt;T&gt; type)&#123; return new JsonHandler&lt;T&gt;( type,gson); &#125; &#125;&#125; 使用client发送请求,并接收响应. 123var client = HttpClient.newHttpClient(URI.create(\"Http://localhost:8080\"));var response = client.send(request, JsonHandler.JsonHandlers.ofType(UserBody.class));var userBody = response.body(); // or 使用异步响应 12345var task = client.sendAsync(request, JsonHandler.JsonHandlers.ofType(UserBody.class)) .thenApply(HttpResponse::body) .thenApply(UserBody::getName) .thenAccept(System.out::println);task.get();//测试方便输出结果. x-www-form-urlencoded 请求 这种请求类型是form表单的默认请求类型,另一种就是可以上传文件的form-data了,但是没有现成的类或者方法支持x-www-form-urlencoded请求,不过该请求投类型很好分析 将form表单里面的name和value用=链接,在把他们用&amp;符号链接起来,如果包含空格替换为+,如果有特殊符号,则转换为ASCII HEX值;如果包含中文字符,则转成ASCII HEX后在百分号编码. 百分号编码: 汉字在utf-8字符集里面是占3个字节的,所以转换成16进制字符串就是占6个字节,每两个字节前面加一个百分号,就变成9个字节传递. 如果是GET请求,那直接在url后?拼接. 如果是POST请求, 那就把拼接好的字符串放在body里面. 简单点就是用现成的库urlencoded, 这种库应该是大部分语言都自带的. 123456789101112public static HttpRequest.BodyPublisher ofXForm(Map&lt;Object,Object&gt; map)&#123; var builder = new StringBuilder(); map.forEach((key, value) -&gt; &#123; if (builder.length() &gt; 0) &#123; builder.append(\"&amp;\"); &#125; builder.append(URLEncoder.encode(key.toString(), StandardCharsets.UTF_8)); builder.append(\"=\"); builder.append(URLEncoder.encode(value.toString(), StandardCharsets.UTF_8)); &#125;); return HttpRequest.BodyPublishers.ofString(builder.toString());&#125; 文件上传下载 下载 下载很简单直接,有现成的方法可以使用. 1234var client = HttpClient.newHttpClient();var request = HttpRequest.newBuilder(URI.create(url)).build();var file = Paths.get(\"1.png\");var response = client.send(request,BodyHandlers.ofFile(file)); 该方法适合知道文件名称时使用.or 1234var client = HttpClient.newHttpClient();var request = HttpRequset.newBuilder(URI.create(url)).build();var file = Paths.get(\"/usr/local/file\");var response = client.send(requset,BodyHandlers.ofFileDownload(file)); ofFileDownload属于比较常见的下载方式. 上传 上传没有现成的方法,所以需要我们自定义一个BodyPublishers.ofFile()方法,然后请求头为mutipart/form-data发送请求 1234567891011121314151617181920212223public static HttpRequest.BodyPublisher ofFile(Map&lt;Object,Object&gt; data,String boundary) throws IOException &#123; var byteArrays = new ArrayList&lt;byte[]&gt;(); byte[] separator = (\"--\" + boundary + \"\\r\\nContent-Disposition: form-data; name=\") .getBytes(StandardCharsets.UTF_8); for (Map.Entry&lt;Object, Object&gt; entry : data.entrySet()) &#123; byteArrays.add(separator); if (entry.getValue() instanceof Path) &#123; var path = (Path) entry.getValue(); String mimeType = Files.probeContentType(path); byteArrays.add((\"\\\"\" + entry.getKey() + \"\\\"; filename=\\\"\" + path.getFileName() + \"\\\"\\r\\nContent-Type: \" + mimeType + \"\\r\\n\\r\\n\").getBytes(StandardCharsets.UTF_8)); byteArrays.add(Files.readAllBytes(path)); byteArrays.add(\"\\r\\n\".getBytes(StandardCharsets.UTF_8)); &#125; else &#123; byteArrays.add((\"\\\"\" + entry.getKey() + \"\\\"\\r\\n\\r\\n\" + entry.getValue() + \"\\r\\n\") .getBytes(StandardCharsets.UTF_8)); &#125; &#125; byteArrays.add((\"--\" + boundary + \"--\").getBytes(StandardCharsets.UTF_8)); return HttpRequest.BodyPublishers.ofByteArrays(byteArrays);&#125; 1234567891011Map&lt;Object,Object&gt; data = new HashMap&lt;&gt;();data.put(\"apikey\", virusTotalApiKey);data.put(\"file\", localFile);String boundary = new BigInteger(256, new Random()).toString();request = HttpRequest.newBuilder() .header(\"Content-Type\", \"multipart/form-data;boundary=\" + boundary) .POST(ofMimeMultipartData(data, boundary)) .uri(URI.create(url)) .build();HttpResponse&lt;String&gt; response = client.send(request, BodyHandlers.ofString()); 高阶使用 HTTP2 server push WebSocket 123456789101112131415161718192021222324252627282930WebSocket webSocket = HttpClient.newHttpClient().newWebSocketBuilder().buildAsync(new URI(\"ws://localhost:8081/platform/device/gps\"), new WebSocket.Listener() &#123; @Override public CompletionStage&lt;?&gt; onText(WebSocket webSocket, CharSequence data, boolean last) &#123; System.out.println(\"onText: \" + data); return WebSocket.Listener.super.onText(webSocket, data, last); &#125; @Override public void onOpen(WebSocket webSocket) &#123; System.out.println(\"onOpen\"); WebSocket.Listener.super.onOpen(webSocket); &#125; @Override public CompletionStage&lt;?&gt; onClose(WebSocket webSocket, int statusCode, String reason) &#123; System.out.println(\"onClose: \" + statusCode + \" \" + reason); return WebSocket.Listener.super.onClose(webSocket, statusCode, reason); &#125; &#125;).join(); Gson gson = new Gson(); Message message = new Message(); message.setFrom(\"dbj\"); message.setContent(\"client data send\"); message.setTo(\"some one\"); webSocket.sendText(gson.toJson(message),true); 其中super.OnXxxx()为固定句式, 其实就是调用websocket.requset(1).固定调用.","categories":[{"name":"java","slug":"java","permalink":"http://dengbojing.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://dengbojing.com/tags/java/"},{"name":"java11","slug":"java11","permalink":"http://dengbojing.com/tags/java11/"}]},{"title":"微信图片转换","slug":"微信图片转换","date":"2020-10-22T11:37:07.000Z","updated":"2020-10-22T12:50:44.815Z","comments":true,"path":"2020/10/22/微信图片转换/","link":"","permalink":"http://dengbojing.com/2020/10/22/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2/","excerpt":"PC端微信图片转换","text":"PC端微信图片转换 引言最近孩子去上早教班,老师在早教群里发了很多孩子的图片,我就想着把这些图片存起来,但是老师发一张我存一张这种模式对程序员来说是一种侮辱,所以我就想是不是存在了微信文件夹下面,一看果不其然,只是格式不是jpg,png,gif等,是dat格式,经过一番百度(ps:微信是国内的东西,所以还是百多搜索比较靠谱)终于找到了解码方法.特此记录. 正文微信文件目录微信的图片文件地址这个不难找,具体目录为${wechatFilesDir}/{your_wechat_id}/FileStroage/image,占位符代表微信文件存储目录(微信设置-&gt;文件管理)和自己微信的微信号. 所需图片知识 jpg/jpeg标识头: 0xff 0xd8 png标识头: 0x89 0x50 gif标识头: 0x47 0x49 当然还有其他的图片格式可以自行谷歌. 微信.bat文件加密方式定义一个key值,将图片转换为二进制流,然后每一位与这个key值进行异或(xor),得到新的byte值,然后写入.所以我们反解就很明显了,假设图片为jpg,我们已知jpg图片前两位为0xff,0xd8,用16进制方式打开.bat文件,得到前两位为x,x1.只需x^0xff==x^0xd8 成立(因为x=key^0xff,x1=key^0xd8),那么这个图片就是jpg. 代码示例仅仅是一个示例,实际开发应当更严谨处理异常以及分支. 123456789101112131415161718192021@Testpublic void test() throws IOException &#123; int base = 0xff; int next = 0xd8; int pngBase = 0x89; int pngNext = 0x50; byte[] bs = Files.readAllBytes(Paths.get(\"D:\\\\WebChat\\\\WeChat Files\\\\wxid_sxelod34kou321\\\\FileStorage\\\\Image\\\\2020-06\\\\0ce7898a35eb2a7ac9045480419e5902.dat\")); int firstByte = bs[0] &amp; 0xff; int secondByte = bs[1] &amp; 0xff; int key = base ^ firstByte; String suffix = \".jpg\"; if((pngBase ^ firstByte) == (pngNext ^ secondByte))&#123; key = pngBase ^ firstByte; suffix = \".png\"; &#125; try(OutputStream os = Files.newOutputStream(Paths.get(\"D:\\\\123\"+suffix),StandardOpenOption.CREATE))&#123; for(byte b : bs)&#123; os.write(b ^ key); &#125; &#125;&#125; 后记通过对比发现一个问题,key值在我公司电脑和家里电脑完全相同.也就是说这个算key的过程应该是拿微信里面的一个固定信息算出来的.这个等在后面在研究一下具体是怎么算的.","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://dengbojing.com/tags/java/"}]},{"title":"Naming Convention--命名规范","slug":"Naming-Convention-命名规范","date":"2020-09-21T13:38:30.000Z","updated":"2020-12-22T06:20:28.647Z","comments":true,"path":"2020/09/21/Naming-Convention-命名规范/","link":"","permalink":"http://dengbojing.com/2020/09/21/Naming-Convention-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/","excerpt":"译文: Clean Code (Best practice for naming) Part 1","text":"译文: Clean Code (Best practice for naming) Part 1 引言 在代码开发过程中好的变量命名习惯是非常重要的,如果是i,j,k,l的命名,我相信不用同组小伙伴打死你,几个月以后的自己都想打死自己.所以,一个好的命名规范尤为重要,不仅要让编译器看懂,阅读代码的人更要是见名知意. 译文 原文地址 在你写代码时候,你觉得你是为谁在写?第一想法是我写代码是为了编译器能编译.想法是对的,编译器应该能’看懂’你得代码并且能编译执行这些代码.那有没有其他的读者阅读你的代码呢?在专业的开发中,你开发代码并不是隔离式的,你处在一个团队里面,并且团队里面可能有很多其他成员,所以你写的代码应该能让这些团队成员看懂.大概率会发生你需要重新审视这些代码来了解这些代码是什么,怎么工作的,为什么会这么写.大概率会发生在将来你无法回答这些问题的时候正好有其他人需要你这段代码.四个不同的组,最后面的3个组有共同点是非常重要的.所以我们需要确保我们写出的代码能被人类读懂.这就是代码整洁之道.只有遵循这些准则,才能确保你写的代码能被将来阅读它的人看懂,或者你的同组小伙伴code review的时候看懂,或者你自己将来做bug fix是看懂,或者你得交接人能添加一个新的功能. 怎么样才是整洁的代码 代码能被机器编译以及能被人类看懂 代码名称简单易懂 格式一致,格式影响代码的可读性 容易改善,比凌乱的代码容易修复 能清晰的表达出其意图.写代码的人能明白这段代码是做什么的 如下代码,该方法名称不够整洁规范,以至于无法说明方法的意图,这种情况你就需要一行一行的阅读代码才能了解他是做是你么的: 1234567891011fun s(arr: IntArray) &#123; val n &#x3D; arr.size for(i in 0 until n-1) &#123; for (j in 0 until n-i-1) if (arr[j] &gt; arr[j+1] &#123; val temp &#x3D; arr[j] arr[j] &#x3D; arr[j+1] arr[j] &#x3D; temp &#125; &#125;&#125; 整洁规范的代码: 12345678910fun buuleSort(array: IntArray) &#123; for (index in 0 until arraySize - 1) &#123; for (pointerIndex in 0 until arraySize - index - 1) if (array[pointerIndex] &gt; array[pointerIndex + 1]) &#123; val temp &#x3D; array[pointerIndex] array[pointerIndex] &#x3D; array[pointerIndex + 1] array[pointerIndex + 1] &#x3D; temp &#125; &#125;&#125; 这样你能一眼就看出来这个方法的意图,对,就是冒泡排序. 类命名规范 类名应该使用名词. $#x1F47D 12class Performer&#123;&#125;class Performance&#123;&#125; 避免动词形式的类名. 123class Perform&#123;&#125;class Performed&#123;&#125;class Performing&#123;&#125; 使用形容词前缀表示时态. 123class ActivePerformance &#123;&#125;class PastPerformer &#123;&#125;` 类名不能仅使用形容词. 1234class Huge &#123;&#125;class Small&#123;&#125;class Fast &#123;&#125;class Slow &#123;&#125; 使用形容词前缀加名词作为类名. 12class SmallPerformance &#123;&#125;class PastPerformer &#123;&#125; 避免使用模糊前缀. 1234class MyPerformer &#123;&#125;class APerformer &#123;&#125;class ThePerformer &#123;&#125;class ThisPerformer &#123;&#125; 避免使用单个字母作为类名. 12class P &#123;&#125;class L &#123;&#125; 避免使用单字母前缀类名. 12class CPerformer() &#123;&#125;class TPerformer() &#123;&#125; 避免使用首字母缩写词大写. 1class HTTPAPIPerformer &#123;&#125; 在单词连接处首字母大写(驼峰命名). 12class HttpApiPerformer &#123;&#125;` 避免使用缩略词. 1class Perf &#123;&#125; 避免使用复数作为类名. 12class performers &#123;&#125;` 使用复数作为集合类的类名. 123456789class Currencies &#123;...// contain map of Currencies, and romat price for each currency val currencyMap = mapOf( Pair(RUSSIAN_RUBLE, \"\\u20BD\"), Pair(UNITED_STATES_DOLLAR, \"\\$\") )...&#125; 整洁规范的方法名称 使用一般现在时作为方法名称. 1234func open() &#123;&#125;func perform() &#123;&#125;func close() &#123;&#125;func validate() &#123;&#125; 避免使用动名词(现在进行时). 1234func performing() &#123;&#125;func validating() &#123;&#125;func opening() &#123;&#125;func closing() &#123;&#125; 避免使用一般过去时. 1234func performed() &#123;&#125;func opened() &#123;&#125;func closed() &#123;&#125;func validated() &#123;&#125; 使用is作为动名词前缀. 123func isRunning() &#123;&#125;func isClosing() &#123;&#125;func isServint() &#123;&#125; 使用has作为一般过去时前缀. 1234func hasPerformed() &#123;&#125;func hasOpened() &#123;&#125;func hasClosed() &#123;&#125;func hasValidated() &#123;&#125; 在应用系统中保持所有的命名标准和转换一致. 如果语言支持驼峰命名,则应该使用驼峰命名.驼峰命名的准确率比下划线命名准去率要高(高出51.5%的几率) 整洁规范的变量命名 使用单数名词作为原始类型和对象类型的变量名] 12int count = 0;User user = new User(); 使用复数名字作为数组和集合的变量名 12String[] names = new String[](\"Alex\", \"Ali\", \"Aesop\"&#125;;List&lt;String&gt; names = new ArrayList&lt;String&gt;(); 避免使用动词作为原始类型的变量名 12boolean create = false;int perform = 12; 使用名词作为原始类型的变量名 12int performanceCode = 12;boolean creationEnabled = false; 避免使用单个单词作为变量名 12int s = 12;int i = 8; 使用有意义的变量名 12int size = 10;int index = 9; 避免使用容易引起混淆的缩写和简写. 1String dbsqlSelAllNames = \"select * from names\"; 使用大写分割变量名,并将简写展开 1String dbSqlSelectAllNames = \"select * from names\"; 不要使用无用的复杂前缀,如匈牙利前缀 1String f_strFirstName = \"Jefferson\"; 避免使用数据类型最为变量名后缀 1String lastNameString = \"Amaya\"; 整洁规范的参数名 命名参数包含单个值时,使用单数名词 123public int add(int left, int right)&#123; return left + right;&#125; 命名参数包含多个值时,使用复数名词 123public int sum(List&lt;Integer&gt; values)&#123; return values.stream().collect(Collectors.summarizingInt(Integer::intValue)).getSum();&#125; 避免使用单个字母作为参数名称 123public int add(int i, int j) &#123; return i+j;&#125; 避免使用简写作为参数名 1public void open(String FSP)&#123;&#125; 参数首字母不应该大写 1public void random(int SeedGenerator)&#123;&#125; 避免使用难懂的前缀 1public void persistName(String sName)&#123;&#125; 整洁规范的常量名 常量名所有的字母都应该大写. 使用单数名词作为原始类型常量命名. 使用复数名词作为集合常量命名. 避免使用单字母和简写. 确保首字母缩写词之间的分割. 后记这些规范是根据语言来定,对于其他语言可能有所变化","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://dengbojing.com/tags/java/"}]},{"title":"how_to_write_good_tests","slug":"how-to-write-good-tests","date":"2020-06-04T13:35:35.000Z","updated":"2020-06-09T15:02:43.098Z","comments":true,"path":"2020/06/04/how-to-write-good-tests/","link":"","permalink":"http://dengbojing.com/2020/06/04/how-to-write-good-tests/","excerpt":"译文: How to write good tests","text":"译文: How to write good tests 引言 代码测试是一件非常重要的工作,在之前的工作中总是找各种借口(时间不够,写起来太繁琐,有些场景无法测试)等等原因做的不够完善.有时甚至不做,无心之中发现一篇非常好的代码测试文章.花些时间来翻译一下,提高一下英文水平,顺便也学习一下正经的代码测试该是什么样的. 译文 原文地址 为我们的软件定制一个测试用例是件好事,但是实际上,一个好的的测试用例也是非常重要的. 遵循一些固有的原则来热爱测试代码 保持测试代码简洁和可读 要做到这一点,需要像对生产代码那样进行无情的重构.否则,让事情发展下去测试代码就会变成恐怖的祖传代码.如果测试代码不能轻松重构,那么意味着生产代码也不能重构,从而导致祖传代码.总是要勇于重构. 避免编码重复 例如, 测试代码与parser使用完全相同的正则表达式来生成内容. 通常来说人们不愿意重复测试与代码的逻辑,所以在测试中重复正则表达式或者其他代码是不可取的.设想以下测试情况,输入/输出结果(f(input)-&gt;(output)),例如,如果代码要处理模版,不要添加固定值,相反,应该根据计算结果添加值. 12345// useAssertions.assertThat(processTemplate(\"param1\", \"param2\")).isEqualTo(\"this is 'param1', and this is 'param2'\"));// instead ofAssertions.assertThat(processTemplate(\"param1\", \"param2\")).isEqualTo(String.format(\"this is '%s', and this is '%s'\", param1, param2)); 覆盖尽可能多的情况,来显示正向的用例,特别是错误的代码位置 通常使用测试驱动开发(TDD--Test Dirven Development)是最佳的实践方式. 使用TDD人们能在设计阶段就找出什么地方会被破坏. 不要认为为一个小的代码片段编写简单的测试不值得，你永远不知道什么时候、因为什么而修改这段代码. 可与使用PIT(突变检测系统)来对测试代码的有效性进行检测. 不要Mock一个你不拥有的类型 这并非一条硬性规定,但是如果不遵循该条规定会有影响(很可能会有). TDD的设计方面和测试方面同样重要.在模拟外部API时,无法使用测试来驱动设计,该API属于其他人;因此第三方也将可以更改API的方法签名和行为. 设想一下代码mocks了一个第三方库,在更新了第三方库之后,三方库的逻辑可能改变了一点,但是测试代码依然能够执行成功,因为他被mock了.所以在这之后,所有的事情看起来很美好,构建也成功了,但是软件部署到正式环境–爆炸! 这也可能导致当前的设计和第三方库不够松耦合. 另一个问是第三方库可能非常复杂需要mock许多东西才能运行,这就导致了大量的特定测试和复杂的测试装置, 而这本身就损害了简洁性和可读性的目标.或者由于模拟外部系统的复杂性而没有充分覆盖代码的测试. 相反,最常见的方式是创建一个第三方库的warpper来包装他们,不过应该注意抽象泄漏(什么是abstraction leakage?)的风险,因为太多的底层API,概念或者异常超过了warpper的边界.为了验证第三方提供API的可用性,请使用集成测试,并尽可能的是它们简洁可读. 下面是其他人在mock了非他所有的类型库遇到的痛苦和总结的经验: http://davesquared.net/2011/04/dont-mock-types-you-dont-own.html http://www.markhneedham.com/blog/2009/12/13/tdd-only-mock-types-you-own http://blog.8thlight.com/eric-smith/2011/10/27/thats-not-yours.html http://stackoverflow.com/questions/1906344/should-you-only-mock-types-you-own 反模式: Mock一切 如果所有的代码都mock了,那么我们怎么测试业务代码?不要害怕不使用Mock的方法. 不要Mock值对象 为什么会有人要这么做呢? 因为实例化一个对象非常痛苦? =&gt; 不是一个很好的理由 如果创建一个对象非常困难,那么这是代码需要严重重构的一个信号.一种可行的方法就是为你的值对象构造一个builder(构造者模式)–有很多工具可以使用比如IDE 插件,Lombok等等. 还可以在测试环境中创建有意义的工厂方法. 12345abstract class CustomerCreations &#123; public static Customer customer_with_a_single_item_in_the_basket() &#123; // long init sequence &#125;&#125; Mockito更加关注对象交互,这也是面向对象的重要要素. (原文)推荐阅读Growing Object Oriented Software Guided by Tests必读,这本书阐释了功能完整的应用程序在从无到有过程中, 开发的许多方面以及如何在项目生命周期的各个阶段实现测试. 如果遇到一些不理解不确定的事情,可以发邮件给作者.","categories":[],"tags":[{"name":"mockito","slug":"mockito","permalink":"http://dengbojing.com/tags/mockito/"}]},{"title":"docker-network","slug":"docker-network","date":"2020-03-13T02:12:37.000Z","updated":"2020-08-04T12:36:28.596Z","comments":true,"path":"2020/03/13/docker-network/","link":"","permalink":"http://dengbojing.com/2020/03/13/docker-network/","excerpt":"docker-network学习","text":"docker-network学习 引言阶段性的记录一下docker学习,docker-network里面还有很多问题很搞明白,亟待解决. 以下操作都是基于docker desktop for windows的linux container模式下 介绍 docker 官方有5种网络模式,none,bridge,macvlan,host,overlay. 1.1 none 模式,参数 --network=none,无网络模式,这种模式一般很少用,官方说法是和自定义网络驱动时使用. 1.2 birdge 模式,参数 --network ${bridge_name}.该模式是默认模式,在安装docker会创建一个默认的docker0的linux网桥,如果启动容器时不指定网络,就会默认连接到docker0网桥 docker desktop for windows看不见docker0,这是因为,docker desktop for windows实际上是把Docker装在Hyper-v虚拟机上,打开Hyper-v虚拟机管理,可以看到DockerDesktopVM这个虚拟机,Docker实际是运行在这个里面,而docker0就在这个里面,但是你如果连接这个虚拟机,发现连接不上. 1.3 host 模式,参数--network=host,该模式下,容器和宿主机共用一个网络,在指定--privileged=true 时候,如果你不小心修改了网络参数,那么就会造成不必要的麻烦,所以一般不推荐这中做法,上面说到docker desktop for windows 无法查看虚拟机里面的docker0网桥,此时如果你以--network=host启动一个容器,此时你就可以执行ifconfig看到docker0网桥. 另一个查看方式docker run -it --rm --privileged --pid=host justincormack/nsenter1,启动之后,执行 ifconfig,指定 --pid=host 参数就是说,让当前启动的容器可以看到宿主机上所有的进程. 1.4 overlay 模式, 参数 network=container:${conatiner_id},该模式下,容器1和容器2共用一个网络. 1.5 macvlan 指定网络的mac地址. 实战bridge模式 docker network ls查看网络,可以看到上面讲到的3种类型的网络,至于overlay呢,是需要依赖别的容器,所以取决与别的容器的网络模式,主要学习一下桥接模式的内容. bridge 网桥模式的原理, 当创建一个容器的时候,Docker 会创建两个网络模块,一个是在容器里面叫eth0, 另一个则在宿主机里面,名字为vethxxxx,Docker 这个网络模块桥街道容器里面的eth0. 2.1 首先我们以bridge启动一个ubuntu 容器,执行: docker run -ti --rm ubuntu:14.04 bash, 启动一个一次性容器并进入 2.2 在容器中执行ifconfig, 看到如下图所示: lo: loopback 回环网络接口,也就是执行localhost或者127.0.0.1时候会走这个网络接口 eth0: 所有来自外部的流量都会通过这个网络接口 2.2 新开一个终端窗口,执行docker run -it --rm --privileged --pid=host justincormack/nsenter1 , 进入容器之后,执行ifconfig 可以看到如图所示: 其中一个vethxxx是桥接到上面ubuntu 容器的网络接口,另一个是当前这个容器的网络接口(因为当前网络没有指定网络模式,所以以默认桥接模式启动,所以也会给当前容器创建一个网络接口). 自定义网桥,之前使用docker-compose 创建了一个compose, 里面包含了一个gateway和一个zookeeper, 里面还定义了一个network ,让两个容器能够以容器名称相互访问, 了解了docker network之后,其实里面network 节点就是创建了一个bridge 网桥, 此时容器就可以通过名称相互访问, 官方名称叫 automatic service discovery 服务自动发现(瞎鸡巴翻译的). 3.1 执行docker network create -d bridge my-network创建一个bridge 类型网络, 执行docker inspect my-network 看一下里面都有什么, 如图: 可以看到,子网掩码是172,19.0.0/16,网关是172,19.0.1,可以使用--subnet=192.168.0.0/16 来指定子网掩码,另外还可以使用--gateway=192.168.0.1 指定网关, --ip-range=192.168.2.0/25指定ip范围 3.2 最好是指定子网掩码,免得网络冲突.如果不指定网关,会从地址范围内自动选择一个出来作为网关,目前测试结论默认是xxx.xxx.xxx.1. 使用docker run --network=my-network 来启动一个容器,执行ifconfig:可以看到此时ip地址为我们创建的桥接网络借口的ip地址范围 一个容器可以同时连接两个网络,使用docker network connect ${networkid|networkname} ${containerid|containername}, 如图:会有两个网络接口一个eth0,另一个eth1, 这样该容器就可以同时访问两个网路 docker network disconnect ${networkid|networkname} ${containerid|containername} 取消容器和网络的链接 --icc高级参数, 如果网络该参数为禁止,则两个容器之间是无法访问的. 后记网络这块真的是比较重要,也比较难的一块,还可以创建overlay类型的网络,有待研究.官方说法生产环境最好不要使用默认的docker0网桥,所以使用docker-compose管理容器还是一个比较好的方式.或者努力学习k8s吧. 积土成山,风雨兴焉;积水成,渊蛟龙生","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://dengbojing.com/tags/docker/"}]},{"title":"docker-compose","slug":"docker-compose","date":"2020-02-11T09:36:28.000Z","updated":"2020-07-01T01:47:58.026Z","comments":true,"path":"2020/02/11/docker-compose/","link":"","permalink":"http://dengbojing.com/2020/02/11/docker-compose/","excerpt":"what? 扫把独立日?","text":"what? 扫把独立日? 引言使用gradle插件构建镜像和docker-compose连接容器 Talk is cheap, show me the code 准备打开docker远程访问端口,docker desktop for windows GUI 界面有一个expose daemon on tcp://localhost:2375, 只需要勾选,然后重启就行;当然这个是提供一个loopback的访问,实际上你并没有真正的暴露一个局域网或者广域网访问的端口,不过对于docker-gradle 使用已经足够,如果非要提供一个远程访问端口请参考微软文档.操作很简单就是在 C:\\ProgramData\\Docker\\config\\daemon.json 添加一行&quot;hosts&quot;: [&quot;tcp://0.0.0.0:2375&quot;](ps:需要关闭expose daemon on tcp://localhost:2375), 这里需要注意的就是你 docker desktop for windows 是以windows container启动的而不是linux container 方式启动, 不然不起作用, 如果非要以linux container方式启动并且提供外网访问, 也不是没有办法具体操作参考这个issue(ps:未实验) Gradle插件构建镜像 在 build.gradle 中添加 docker-plugin 插件,然后编写脚本具体文档参考这里, 最终 build.gradle 就是像下面这样: 12345678910111213141516plugins &#123; ... id &#39;com.bmuschko.docker-spring-boot-application&#39; version &#39;6.1.3&#39; ...&#125;dependencies&#123;...&#125;docker &#123; springBootApplication &#123; baseImage &#x3D; &#39;openjdk:11&#39; ports &#x3D; [8090] maintainer &#x3D; &#39;dengbojing@qq.com&#39; images &#x3D; [&#39;dengbojing&#x2F;gateway:v3&#39;] jvmArgs &#x3D; [&#39;-Dspring.profiles.active&#x3D;production&#39;, &#39;-Xmx2048m&#39;] mainClassName &#x3D; &#39;com.yichen.ServiceGatewayApplication&#39; &#125;&#125; baseImage 基于哪个基础镜像构建. ports 需要暴露的端口. maintainer 对应 dockerfile 中已经废弃的 maintainer 命令, 添加一些元信息. images 构建出来的额镜像名称. jvmArgs 对应 dockerfile ENTRYPOINT 命令中的启动参数. mainClassName 对应 dockerfile ENTRYPOINT 命令中的启动类. 执行 gradle dockerBuildImage, 该命令就会使用 docker -H tcp://127.0.0.1:2375 build 来构建镜像, 所以要先开启 2375端口;当然该插件也能提供远程构建,具体请看官方文档;如果使用开发工具可以在开发工具gradle插件里面找到对应的执行的task;然后会在 ${classpath}/build/docker 下面看到生成的 dockerfile,这里并不是打 jar 包的方式, 而是用完整的lib 和 classes 制作镜像,然后用java -cp 指定设置 classpath 然后启动脚本写的 mianClass;此时执行 docker images 就可以看到制作的镜像. 插件提供了4个 task, 分别是 dockerPushImage–推送镜像到镜像仓库,需要指定用户名密码,具体参看官方文档 , dockerBuildImage–构建镜像 , dockerCreateDockerfile–创建dockerfile , dockerSyncBuildContext–将代码同步到docker context , 前面的 task 总是依赖后面的 task. Docker-compose介绍 &amp; 简单使用 docker-compose 是官方提供的编排项目工具, 主要是应对单机多容器之间连接通信. 使用 docker-compose.yml 作为模版文件 模版文件开头使用 version 来指定 docker-compose 文件格式,目前最新版本为3.7,具体对照关系可以参考这里 一个简单的 docker-compose.yml 示例: 123456789101112131415version: '3'services: web: build: . image: dengbojing/gateway:v4 ports: - \"8090:8090\" networks: - gateway zookeeper: image: zookeeper networks: - gatewaynetworks: gateway: version: compose的版本号,具体对应关系可以查看文档services: 需要启动的服务,一个服务对应一个容器,也就是说在执行该文件之后,会多出两个容器web,zookeeper: 服务名称, 最终创建的容器名称会以启动时候指定的 ${project_name} 加上服务的名称为完整的容器名称build: 指定构建的 docker-context 和 dockerfile, 此处都在当前目录; 详细指定格式为: 12345...build: context: . dockfile: ./dockerfile... ps: 这里可以指定 docker-gradle生成的 dockerfile 作为构建脚本.image: 指定构建完成之后的镜像名称,也就说执行完该文件会多一个以 dengbojing/gateway:v4 为名称的镜像; 下面的image为以zookeeper镜像为基础创建一个容器;ports: 对外暴露的端口 networks: 定义一个网络, 然后在 services 中使用, 此时 web 服务容器就可以通过下面的服务名–zookeeper 来访问下面的服务容器, 例: 1234spring: cloud: zookeeper: connect-string: zookeeper:2181 ps: gateway 项目为spring-cloud-gateway 项目, 使用了 zookeeper 作为注册中心和配置中心, 所以需要访问 zookeeper. 写到这里,简单的使用 docker-compose 就完成了, 不难发现对于微服务来说这种方式是非常有用的, 我们可以把我们几个服务包装成一个 docker-compose 项目,然后进行部署,它还支持从一个镜像启动多个容器实例–毕竟容器实例就是类的对象,有对个对象当然是没问题的; 这样以来那么一个文件里面就可以包含多个相同功能的服务,一个注册中心,一个配置中心,完美实现了集群功能.当然在实际生产过程中,注册中心和配置中心肯定在不同的服务器上, 所以这种方式有一定的局限性. 后记简单的学习了一下 docker-compose , 其中有很多配置和命令之后实战的时候才会真的用到. 怎么说呢: 路漫漫其修远兮, 吾将上下而求索","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://dengbojing.com/tags/docker/"},{"name":"springboot","slug":"springboot","permalink":"http://dengbojing.com/tags/springboot/"},{"name":"gradle","slug":"gradle","permalink":"http://dengbojing.com/tags/gradle/"}]},{"title":"dockerfile构建自己的应用","slug":"dockerfile","date":"2020-02-01T03:45:08.000Z","updated":"2020-08-10T08:52:37.786Z","comments":true,"path":"2020/02/01/dockerfile/","link":"","permalink":"http://dengbojing.com/2020/02/01/dockerfile/","excerpt":"使用docker构建自己的应用","text":"使用docker构建自己的应用 引言 自从docker入门以后,一发不可收拾,越学习越感觉有趣,本文记录一下在学习dockerfile构建自己应用遇到的坑以及学习心得 Talk is cheap, show me the code 环境 使用gradle+jdk11编译及打包springboot项目,然后使用docker制作镜像 项目 springboot,作为现在最流行的微服务基础框架,我相信大家已经非常非常熟悉了,即使没有使用过,肯定听说过.一般比较通用的创建方式是使用springboot官网提供的创建工具进行创建,如果你使用intellij idea那么也可以在创建的时候使用spring initializr,这个和使用官方提供的创建工具是一回事 命令 FROM该指令是dockerfile的起始命令,是必须的,而且必须是第一个,作用是以一个镜像为基础,在该镜像上进行定制. FROM [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]FROM [--platform=&lt;platform&gt;] &lt;image&gt; [AS &lt;name&gt;]FROM [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;] ARG该指令是声明一个变量: 1ARG &lt;name&gt;[&#x3D;&lt;default value&gt;] 如果想覆盖默认值,可以在执行 docker build 命令时候指定 --build-arg &lt;name&gt;=&lt;value&gt; ps:在FROM之前声明的ARG在构建阶段之外，因此，FROM之后的任何指令都不能使用它。要使用在第一个FROM之前声明的ARG的默认值，请使用ARG指令，且在构建阶段内部不带值 1234ARG VERSION&#x3D;latest FROM busybox:$VERSION ARG VERSION RUN echo $VERSION &gt; image_version LABEL该指令添加 metadata 到镜像之中,格式为键值对,如: LABEL maintainer=&quot;dengbojing@qq.com&quot; ps: 这里正好用 maintainer 字段来说明一下,官方已经将MAINTAINER 这个命令废弃,改用 LABEL 代替 RUN该指令有两种格式 shell格式, RUN &lt;command&gt; command将会在shell中执行,对于linux系统shell为/bin/bash, 对于windows系统shell为 cmd /S /D exec格式, RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] , 注意该指令不会进行shell处理,比如 RUN [&quot;echo&quot;, &quot;$home&quot;] 是不会对 $home 处理的,你需要自己指定shell,RUN [&quot;sh&quot;, &quot;-c&quot;, &quot;echo $home&quot;]. 该命令执行一次会产生一层layer,所以应该尽量合并 RUN 后面 command 比如: RUN &amp;&amp; apt-get update &amp;&amp; apt-get install -y $buildDeps CMD该指令主要作用是为容器提供一个默认的执行命令,三种格式: exec格式, CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] ,该格式是官方推荐首选格式,同样该格式也不会进行shell处理. 参数格式: CMD [&quot;param1&quot;,&quot;param2&quot;], 该格式需要指定 ENTRYPOINT ,作为 ENTRYPOINT 的参数 shell格式, CMD command param1 param2 ps: 该指令在文件中只有一个,如果有多个那么只有最后一个 CMD 才会起作用,如果在docker run 后面指定了其他命令或者参数会覆盖 CMD 后面的命令或者参数 ENTRYPOINT该指令主要作用是为容器提供一个每次都执行的命令,该命令有两种格式: exec格式: ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] ,官方推荐shell格式: ENTRYPOINT command param1 param2 ps: 同 CMD 指令如果有多个 ENTRYPOINT 也只有最有一个起作用,如果想覆盖默认的ENTRYPOINT 可以使用: docker run --entrypoint;不同点在于,该指令可以直接在 docker run 后面跟参数,而 CMD 指令不可以. COPY顾名思义,该指令主要作用就是–复制,两种格式: COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;] ps: 1. 该指令的 --chown 只有linux才有,windows和linux权限管理不一样;另外该指令还支持通配符 2. 该指令只会cp源目标下文件. 3. 如果目标目录没有/, 则会将目标地址当成一个文件 4. 如果目标目录不存在, 则会创建目标目录的所有层级的目录 EXPOSE该指令暴露一个容器内部端口到外部,格式为: EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...] ps: 该指令并非真正暴露一个端口供外部使用,只是一种说明,说明容器内部哪些端口可以被访问,在启动时候需要使用 docker run -p &lt;out port&gt;:&lt;expose port&gt; WORKDIR该指令指定工作目录,相当于shell命令里面的 cd,指定工作目录之后,后续的COPY, RUN, CMD, ENTRYPOINT 等命令都是在当前目录下完成 USAGE &amp; CONTEXT 当执行 docker build 的时候需要一个 Dockerfile 文件和一个 context, context 的涵义是指包含一些列文件的PATH或者URL,这里的 PATH 代表了文件系统的目录, URL 则代表了 Git 仓库地址. 这里文件系统的目录是包含下面的子目录以及子目录中的文件,也就是 whole directory 都会被作为上下文发送给 docker daemon. docker build 构建的时候不是在CLI(命令行界面)构建而是把 当前目录 作为 context 发送给 docker daemon, 也就是docker的守护进程,所以说不能发送过大的目录,特别是不要在根目录执行 docker build, 官方推荐是使用一个空目录作为 context 来存放 Dockerfile ,仅仅添加 Dockerfile 需要的文件. 这里遇到一些问题,执行 docker build 命令的时候会将当前目录作为 context 发送给守护进程, 但是 Dockerfile 不能直接使用这些文件,官方说明为: To use a file in the build context, the Dockerfile refers to the file specified in an instruction, for example, a COPY instruction 翻译过来就是–要使用 context 中使用某个文件, Dockerfile 指定一个命令来引用这个文件,例如: COPY 命令, 换句话说,就是这些文件发送给守护进程,但是不能直接使用,得通过命令来使用(后面会说明碰到的问题). 制作学习了dockerfile和指令之后,我想到应该有两种方式制作镜像 方法一: 使用gradle构建项目,然后在使用dockerfile把jar包制作成镜像: 这种方法简单,但是感觉没什么意义啊,不过随后我还真的在springboot官方指导下找到了这个方法. 第一步,执行gradle构建项目gradle build -x test 第二步,编写dockerfile 123456FROM openjdk:11LABEL maintainer&#x3D;&quot;dengbojing@qq.com&quot; ARG JAR_FILE&#x3D;build&#x2F;libs&#x2F;*.jarCOPY $&#123;JAR_FILE&#125; app.jarEXPOSE 8090ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;&#x2F;app.jar&quot;] docker build -t dengbojing/gateway . 点代表把当前目录作为context发送给dockerdeamon 方法二: 把方法一的第一步放在Dockerfile里面,这样就少执行一步命令, 进入项目目录,新建一个空白的 Dockerfile 文件,填写如下内容: 123456FROM openjdk:11 LABEL maintainer&#x3D;&quot;dengbojing@qq.com&quot; COPY . .RUN .&#x2F;gradlew build -x test EXPOSE 8090 ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;build&#x2F;libs&#x2F;service-gateway-0.0.1-SNAPSHOT.jar&quot;] ps: 第一次写命令时候不了解 Dockerfile 和 context 的工作原理,觉得将当前工作目录发送给docker daemon 就能直接使用了,没有写COPY . ., 结果就是怎么都运行不过去,找不到gradlew 文件.后面 Google 之,看到这种写法,一脸懵,后来请教群里大神,加上仔细阅读文档,最终解惑. 这种方法有一个弊端,就是构建之后的镜像会比较大,因为 gradle 构建项目阶段所需要的额外的文件最终也被添加到镜像中了, 所以官方提供了多阶段构建. 例: 12345678910FROM openjdk:11 AS build LABEL maintainer&#x3D;&quot;dengbojing@qq.com&quot; COPY . .RUN .&#x2F;gradlew build -x test FROM openjdk:11 AS finalWORKDIR &#x2F;appCOPY --from&#x3D;build build&#x2F;libs&#x2F;service-gateway-0.0.1-SNAPSHOT.jar app.jarEXPOSE 8090 ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;app.jar&quot;] 可以对比一下两种不同方式构建的镜像最后的大小, 如下图: 可以看到,v1是通过非多阶段构建的,构建之后有1.16g大小,而通过多阶段构建,抛弃了 gradle 文件,只留下需要的项目jar包, 只有652M,好处显而易见. ps: 如果还想那个精简,那么可以使用 jre 而非 jdk; 我这里是使用的自己的一个spring-cloud-gateway项目进行学习的. 方法三: 以上的方法,是我直观能想到的方法,但是通过学习,找到了更简便的方法,那就是 gradle插件 ,编写 gradle构建脚本 ,生成 docker 镜像, 具体文档, 点击这里 后记 目前方法三还处于理论阶段,文档是看懂了,但是没有实质性的操作过.而且在项目构建过程中涉及到网络通信, spring-cloud 所有的项目都应该在注册中心注册, 我采用的 zookeeper 作为注册中心和配置中心, 这就涉及到了两个容器之间相互通信, 目前还没有学会, 目前做法是在宿主机启动 zookeeper, 然后找到 docker 虚拟网卡, 找到宿主机相对于 docker 的 ip address , 将镜像里面的 zk 地址改为宿主机相对于容器的ip, 这种方法很不容器化, 所以接着学习, 学会很容器化的方式方法. 骐骥一跃,不能十步;驽马十驾,功在不舍.","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://dengbojing.com/tags/docker/"},{"name":"springboot","slug":"springboot","permalink":"http://dengbojing.com/tags/springboot/"},{"name":"gradle","slug":"gradle","permalink":"http://dengbojing.com/tags/gradle/"}]},{"title":"docker入门学习","slug":"docker-new","date":"2020-01-25T13:12:50.000Z","updated":"2020-08-04T12:29:38.239Z","comments":true,"path":"2020/01/25/docker-new/","link":"","permalink":"http://dengbojing.com/2020/01/25/docker-new/","excerpt":"docker入门","text":"docker入门 引言 作于2020年春节大年初一晚,此时疫情真的是猛于虎,为了避免给我媳妇她们医院带来不必要的麻烦,老实在家呆着学学新知识,提升自我. Talk is cheap, show me the code 介绍 Docker 使用 Google 公司推出的 Go 语言 进行开发实现,基于 Linux 内核的 cgroup,namespace,以及 AUFS 类的 Union FS 等技术,对进程进行封装隔离,属于操作 系统层面的虚拟化技术 个人理解就是一种虚拟化技术,类似之前接触过的lvm(linux virtual machine),但是有很大的不同,lvm是有一套完整的系统,虚拟出一套硬件系统和操作系统,然后在该系统之上又有很多的应用;而容器技术里面的应用直接是运行在容器宿主的内核之上,也没有虚拟除一套硬件,一套操作系统;所以容器很轻便小巧. ps: 从以上描述可以看出,容器技术更适用于持续集成和devOps,有点 java--Complie Once,Run Anywhere 的意思,只需要打包一次,在任何地方,任何系统之上都能使用,不存在之前 各种环境 (开发环境,测试环境,灰度环境,正式环境)导致的[这段代码在我机器上好好的啊,怎么可能有问题] 安装 注册docker hub 账号 在docker官方文档上找到对应操作系统的ps: 文件还是有点大,建议使用迅雷等p2p工具下载. 本人使用windows专业版系统,选择docker desktop for windows按照官网提示下载,完成之后不着急安装,此时需要先启动hyper-v,docker desktop是依赖hyper-v的,开启hype-v之后需要重启电脑,重启之后安装docker desktop,安装过程省略,下一步下一步即可.ps: 如果你是windows 家庭版,请参考这篇文章 启动docker desktop,在系统托盘图标右键-&gt;setting,找到resources-&gt;file sharing,选择你要共享的盘符,因为docker desktop默认是使用hyper-v虚拟机,而hyper-v虚拟机默认的镜像地址都是在C盘,也就是系统盘,这会导致c盘不够用,可以直接在resources-&gt;advanced下面找到disak image location修改镜像位置,本人是没有修改,这里本人是开启了共享盘符,把之后镜像使用的存储空间映射到本地其他磁盘上,这样解决了大部分存储空间的问题,镜像存储就不管了 入门 打开power shell,这里最好是不要使用其他命令终端,本人之前学习时候使用cmd,使用cmd是有坑的,后面会讲到,输入docker login,按照提示输入之前在docker hub上注册的用户名,密码,第一次需要输入,后续可以不用,也可使用图像化界面登录,右键docker desktop系统托盘图标-&gt;login. 登录之后我们就可以是用docker search命令来搜索我们感兴趣的仓库了,比如我们安装一个mysql吧,docker search mysql,可以看到有很多的mysql镜像,还有star数和officialps: 根据是否是官方提供,可将镜像资源分为两类.一种是类似 mysql 这样的镜像,被称为基础镜像或根镜像.这些基础镜像由 Docker 公司创建、验证、支持、提供.这样的镜像往往使用单个单词作为名字.还有一种类型,比如 bitnami/mysql 镜像,它是由 Docker 的用户创建并维护的,往往带有用户名称前缀. 使用docker pull拉去镜像,具体命令如下 docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] 具体选项可以通过`docker pull --help` 来查看, - docker registry地址: 默认是docker hub,一般不需要指定 - 仓库名: 前文提到镜像名称分为两段,`&lt;username&gt;/&lt;soft name&gt;`如果不指定默认是library,即docker官方的镜像. - tag: 标签,如果不指定默认为latest,当然可以指定需要的版本,查询tag目前本人没有找到相应的命令,只能去[docker hub](https://hub.docker.com/)搜索镜像然后查看tag 综上所述,此时只需使用`docker pull mysql`就可以了 可以是用docker image ls或者docker images 查看本地镜像此时可以看到镜像的大小和在docker hub大小是不一样的,这是因为,在docker hub显示的是压缩大小,docker hub作为一个中央镜像仓库,关心的是流量大小,而不是体积大小,所以会尽可能的压缩镜像体积;而且在这里,显示的大小可能和实际占用磁盘空间大小还不一样,这是因为,镜像是有很多文件层组成,而文件层之间又存在继承,复用的关系,如果不同的镜像使用相同的基础层,那么只需要保存一份该基础层就可以了,不同镜像的其他层可以直接引用该基础层,可以使用docker system df -v来查看具体的占用情况,同时可以使用docker system prune来清理磁盘空间.docker image ls 支持通配符,如 docker images my* 可以将所有my开头的镜像都列出docker image ls -q 可以只显示镜像的 ID此外还支持 -f(--filter) 过滤模式, 比如: docker images -f since=mysql 会列出在 mysql之后的所有镜像,将 since 换成 before 可以列出之前的镜像 启动容器,每一个容器都是一个镜像实例,这个就像java里面的oop思想一样,一个镜像就是一个类,一个类的对象对应一个容器,java 里面使用new关键字实例化对象,这里我们使用docker run来启动一个容器,具体命令参数: docker run [OPTIONS] IMAGE [COMMAND] [ARG…] 此处常用的 options 有 -p 指定端口号, -P 指定端口号映射为本机随机端口号; -e 指定容器内部的环境变量;-d 指定为后台启动;-i 保持stdin标准的输入流打开状态,即使没有链接; -t 分配一个伪终端, -v 指定文件映射,即讲本地的一个目录或者文件映射到容器内部;具体启动命令: docker run -d -p 3305:3306 –privileged=true -e MYSQL_ROOT_PASSWORD=xxxx –name mysqltest -v /f/mysql/data:/var/lib/mysql -v /f/mysql/conf/my.cnf:/etc/mysql/my.cnf -v //f/mysql/mysql-files:/var/lib mysql-files/ mysql:latest –character-set-server=utf8mb4 –collation-server=utf8mb4_unicode_ci 解释一下,此时我们就把容器内部的3306端口映射为宿主机的3305端口,并且设置了mysql的配置,数据存储位置,并且进行了一系列的mysql参数设置,指定了 msyql root 的密码为xxx,–privileged是让容器内部的用户获取宿主机特殊权限,此处一定要把文件映射在你已经共享的盘符,不然会失败 查看容器状态, docker container ls -a 或 docker ps -a 可以看到容器的状态,映射端口,名字等;使用 docker stop &lt;container name\\id&gt; 停止容器, 使用 docker start &lt;container name\\id&gt; 再次启动容器,注意第一次启动容器使用 docker run 命令,该命令会创建并启动一个容器, 之后并不需要在run,只需要执行start就可以了,此外 docker run 执行时,如果指定镜像不存在,该命令会自动拉去默认仓库所匹配的镜像 删除镜像和容器删除镜像使用 docker image rm 或 docker rmi 加上镜像的 ID 来删除镜像删除容器使用 docker container rm 或 docker rm 加上容器 ID 删除容器,可以添加 -f 强制删除一个正在运行的容器;此外如果只是想清理未被容器使用的镜像可以使用 docker image prune同理,可以使用 docker container prune 清理未运行的容器如果需要删除的容器或者镜像太多,手动一个个输入就显得有点智障了,此时可以使用 docker image ls -q 来配合批量删除,比如:docker rmi $(docker image ls -q -f since=mysql)此时就会将mysql之前所有的镜像都删除ps: 此处有之前说的 cmd 的坑,使用 cmd 会报错,改用 power shell 就不会 后记基础入门就这些,后续根据自身所学内容,会陆陆续续的记录更多的东西,比如如何创建一个docker容器啊,导入导出镜像啊,私有仓库的搭建等等. 不积跬步，无以至千里；不积小流，无以成江海","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://dengbojing.com/tags/docker/"}]},{"title":"使用hexo+github pages建立静态blog","slug":"first","date":"2020-01-14T11:32:51.000Z","updated":"2020-08-04T12:41:31.060Z","comments":true,"path":"2020/01/14/first/","link":"","permalink":"http://dengbojing.com/2020/01/14/first/","excerpt":"好记性不如烂笔头 记录一下使用hexo + github pages搭建博客的过程,以及过程中遇到的坑;同时也给阅读这篇文章,想要搭建博客的人一点帮助","text":"好记性不如烂笔头 记录一下使用hexo + github pages搭建博客的过程,以及过程中遇到的坑;同时也给阅读这篇文章,想要搭建博客的人一点帮助 为什么搞独立blog市面上blog service多如牛毛为啥非要搞自己的,因为独立的才是自己的 为什么使用gihub pages因为不用买服务器,免费而且稳定,也无需域名,只需要你有github账号就能用 Talk is cheap, show me the code Git git根据自己电脑下载相应版本,本人是win10电脑使用git bash. 安装完成打开git bash, 输入git --version测试是否安装成功 注册github账号(全球最大的同性交友网站,你值得拥有). 新建&lt;username&gt;.github.io仓库. node node根据自己电脑下载相应版本 安装完成之后,在之前的git bash输入node --version测试是否安装成功 Hexo 安装好 Node.js 后，通过 npm 安装 Hexo npm install hexo-cli -g ps: 可能安装失败,如果失败,安装cnpm,然后在安装hexo;或者挂代理,走梯子 npm install -g cnpm –registry=https://registry.npm.taobao.org 安装 Hexo 完成后,执行 hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 执行完成之后目录会像 ├── _config.yml ├── node_modules │ ├── hexo │ ├── hexo-generator-archive │ ├── hexo-generator-category │ ├── hexo-generator-index │ ├── hexo-generator-tag │ ├── hexo-renderer-ejs │ ├── hexo-renderer-marked │ ├── hexo-renderer-stylus │ └── hexo-server ├── package.json ├── scaffolds │ ├── draft.md │ ├── page.md │ └── post.md ├── source │ └── _posts └── themes └── landscape ps: 简单说明一下目录作用 _config.yml 配置文件,网站的标题,作者,主题配置等 node_modules hexo的模块,较少关心 package.json 项目描述文件,不用关心 scaffolds 模版配置,较少关心 source–&gt;_post 主要存放我们写的文章 themes hexo主题,文件夹名称对应为主题名称 配置_config.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# Sitetitle: Hexo #标题subtitle: #副标题description: #描述author: #你的名字language: zh #网站使用的语言,注意使用主题下面的语言(themes--&gt;&lt;要使用的主题&gt;--&gt;languages)不然会出现未知结果timezone: Asia&#x2F;Shanghai #网站时区 # URLurl: https:&#x2F;&#x2F;dengbojing.com #地址(如果未申请域名则不需要填写)root: &#x2F; #根目录permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F; #文章的永久链接格式permalink_defaults: # trailing_index: true # Set to false to remove trailing &#39;index.html&#39; from permalinks trailing_html: true # Set to false to remove trailing &#39;.html&#39; from permalinks# Directorysource_dir: source #资源文件夹public_dir: public #由资源文件夹生成而来tag_dir: tags #标签文件夹,默认是没有的需要使用hexo new page tags 自行创建archive_dir: archives #归档文件夹category_dir: categories #分类文件夹,默认是没有的需要使用hexo new page tags 自行创建code_dir: downloads&#x2F;code #Include code 文件夹i18n_dir: :lang #国际化（i18n）文件夹skip_render: #跳过指定文件的解析# Writingnew_post_name: title.md # 新文章的文件名称default_layout: post #预设布局titlecase: false # 把标题转换为单词首字母大写external_link: enable: true # 在新标签中打开链接 field: site exclude: &#39;&#39; #排除文件filename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写render_drafts: false #显示草稿post_asset_folder: false #启动 Asset 文件夹，为 true 时，每次建立文件时，Hexo 会自动建立一个与文章同名的文件夹relative_link: false #把链接改为与根目录的相对位址future: true #显示未来的文章highlight: #代码块高亮,很多主题要求此项为false enable: true line_number: true auto_detect: true tab_replace:# Category &amp; Tagdefault_category: uncategorized #默认分类category_map: #分类别名tag_map: #标签别名# Date &#x2F; Time formatdate_format: YYYY-MM-DD #日期格式time_format: HH:mm:ss #时间格式# Paginationper_page: 10 #每页显示的文章量 (0关闭分页功能)pagination_dir: page #分页目录# Extensionstheme: next #当前主题名称(本人使用的非默认主题)# Deploymentdeploy: #部署 type: git repo: https:&#x2F;&#x2F;github.com&#x2F;username&#x2F;username.github.io.git #仓库地址 branch: master #分支名称 打开看看, 在git bash中使用 hexo g 命令生成文章,hexo s命令启动服务,下面提示访问localhost:4000,访问一下看到使用默认主题的网站 写文章 使用hexo new post &lt;filename&gt; 创建自己的第一篇文章 找到source–&gt;_post,打开&lt;filename&gt;.md 更多写作用法 123456---title: 使用hexo+github pages建立静态blogdate: 2020-01-14 19:32:51tags: [git,hexo]categories: hexo--- 在date下面添加分类和标签,可选 在—下面写正文内容,可以使用&lt;!--more--&gt;分割 比如: 简介 &lt;!--more--&gt; 正文 本地预览hexo g生成hexo s启动打开浏览器,输入localhost:4000看看吧 部署到服务器 安装一键部署 npm install hexo-deployer-git –save 执行 hexo clean(可选,正常情况不需要) hexo d 部署到&lt;username&gt;.github.io 后记 使用过程中遇到很多问题,目前都没有解决, 比如有些主题莫名看不到tags和categories仓库,最后选来选去只能使用next主题 还有写modules(比如七牛云)安装之后即使你不启用你也得写配置","categories":[{"name":"hexo","slug":"hexo","permalink":"http://dengbojing.com/categories/hexo/"}],"tags":[{"name":"git","slug":"git","permalink":"http://dengbojing.com/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"http://dengbojing.com/tags/hexo/"}]}]}