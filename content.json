{"meta":{"title":"生活不易,砥砺前行","subtitle":"Keep farmed and carry hard","description":"","author":"Dengbojing","url":"http://dengbojing.com","root":"/"},"pages":[{"title":"","date":"2020-01-15T03:33:52.175Z","updated":"2020-01-15T03:33:52.175Z","comments":true,"path":"404.html","permalink":"http://dengbojing.com/404.html","excerpt":"","text":"你要找的内容不存在! 返回首页"},{"title":"tags","date":"2020-01-14T12:42:52.000Z","updated":"2020-01-14T12:43:46.157Z","comments":true,"path":"tags/index.html","permalink":"http://dengbojing.com/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2020-01-15T02:32:15.000Z","updated":"2020-01-15T12:10:22.196Z","comments":true,"path":"about/index.html","permalink":"http://dengbojing.com/about/index.html","excerpt":"","text":"About 少壮不努力,后跳带剑气 java-web开发者,就职于一家混日子的小公司,每天过着摸鱼的生活,很少加班,也不掉头发,完全一个假程序员,不过我很开心. 虽然工作年限也不短了,但是还远没有到知识输出那个境界,开此博客主要目的就收记录我积累的只是和经验,有些东西靠脑子记还真容易忘掉. 没开放评论,因为如果要问什么,我估计会被问懵逼,如果真要和我杠,请发送邮件至dengbojing@qq.com,我这人还是比较钢精的,说不定会回邮件;同样如果你有什么好的东西和我分享或者愿意指导我,那鄙人会欣喜若狂. 至于本站内容,随便复制粘贴,知识只有传播和分享才能体现他的价值,不然就是一堆冰冷的文字."}],"posts":[{"title":"how_to_write_good_tests","slug":"how-to-write-good-tests","date":"2020-06-04T13:35:35.000Z","updated":"2020-06-09T15:02:43.098Z","comments":true,"path":"2020/06/04/how-to-write-good-tests/","link":"","permalink":"http://dengbojing.com/2020/06/04/how-to-write-good-tests/","excerpt":"译文: How to write good tests","text":"译文: How to write good tests 引言 代码测试是一件非常重要的工作,在之前的工作中总是找各种借口(时间不够,写起来太繁琐,有些场景无法测试)等等原因做的不够完善.有时甚至不做,无心之中发现一篇非常好的代码测试文章.花些时间来翻译一下,提高一下英文水平,顺便也学习一下正经的代码测试该是什么样的. 译文 原文地址 为我们的软件定制一个测试用例是件好事,但是实际上,一个好的的测试用例也是非常重要的. 遵循一些固有的原则来热爱测试代码 保持测试代码简洁和可读 要做到这一点,需要像对生产代码那样进行无情的重构.否则,让事情发展下去测试代码就会变成恐怖的祖传代码.如果测试代码不能轻松重构,那么意味着生产代码也不能重构,从而导致祖传代码.总是要勇于重构. 避免编码重复 例如, 测试代码与parser使用完全相同的正则表达式来生成内容. 通常来说人们不愿意重复测试与代码的逻辑,所以在测试中重复正则表达式或者其他代码是不可取的.设想以下测试情况,输入/输出结果(f(input)-&gt;(output)),例如,如果代码要处理模版,不要添加固定值,相反,应该根据计算结果添加值. 12345// useAssertions.assertThat(processTemplate(\"param1\", \"param2\")).isEqualTo(\"this is 'param1', and this is 'param2'\"));// instead ofAssertions.assertThat(processTemplate(\"param1\", \"param2\")).isEqualTo(String.format(\"this is '%s', and this is '%s'\", param1, param2)); 覆盖尽可能多的情况,来显示正向的用例,特别是错误的代码位置 通常使用测试驱动开发(TDD--Test Dirven Development)是最佳的实践方式. 使用TDD人们能在设计阶段就找出什么地方会被破坏. 不要认为为一个小的代码片段编写简单的测试不值得，你永远不知道什么时候、因为什么而修改这段代码. 可与使用PIT(突变检测系统)来对测试代码的有效性进行检测. 不要Mock一个你不拥有的类型 这并非一条硬性规定,但是如果不遵循该条规定会有影响(很可能会有). TDD的设计方面和测试方面同样重要.在模拟外部API时,无法使用测试来驱动设计,该API属于其他人;因此第三方也将可以更改API的方法签名和行为. 设想一下代码mocks了一个第三方库,在更新了第三方库之后,三方库的逻辑可能改变了一点,但是测试代码依然能够执行成功,因为他被mock了.所以在这之后,所有的事情看起来很美好,构建也成功了,但是软件部署到正式环境–爆炸! 这也可能导致当前的设计和第三方库不够松耦合. 另一个问是第三方库可能非常复杂需要mock许多东西才能运行,这就导致了大量的特定测试和复杂的测试装置, 而这本身就损害了简洁性和可读性的目标.或者由于模拟外部系统的复杂性而没有充分覆盖代码的测试. 相反,最常见的方式是创建一个第三方库的warpper来包装他们,不过应该注意抽象泄漏(什么是abstraction leakage?)的风险,因为太多的底层API,概念或者异常超过了warpper的边界.为了验证第三方提供API的可用性,请使用集成测试,并尽可能的是它们简洁可读. 下面是其他人在mock了非他所有的类型库遇到的痛苦和总结的经验: http://davesquared.net/2011/04/dont-mock-types-you-dont-own.html http://www.markhneedham.com/blog/2009/12/13/tdd-only-mock-types-you-own http://blog.8thlight.com/eric-smith/2011/10/27/thats-not-yours.html http://stackoverflow.com/questions/1906344/should-you-only-mock-types-you-own 反模式: Mock一切 如果所有的代码都mock了,那么我们怎么测试业务代码?不要害怕不使用Mock的方法. 不要Mock值对象 为什么会有人要这么做呢? 因为实例化一个对象非常痛苦? =&gt; 不是一个很好的理由 如果创建一个对象非常困难,那么这是代码需要严重重构的一个信号.一种可行的方法就是为你的值对象构造一个builder(构造者模式)–有很多工具可以使用比如IDE 插件,Lombok等等. 还可以在测试环境中创建有意义的工厂方法. 12345abstract class CustomerCreations &#123; public static Customer customer_with_a_single_item_in_the_basket() &#123; // long init sequence &#125;&#125; Mockito更加关注对象交互,这也是面向对象的重要要素. (原文)推荐阅读Growing Object Oriented Software Guided by Tests必读,这本书阐释了功能完整的应用程序在从无到有过程中, 开发的许多方面以及如何在项目生命周期的各个阶段实现测试. 如果遇到一些不理解不确定的事情,可以发邮件给作者.","categories":[],"tags":[{"name":"mockito","slug":"mockito","permalink":"http://dengbojing.com/tags/mockito/"}]},{"title":"docker-network","slug":"docker-network","date":"2020-03-13T02:12:37.000Z","updated":"2020-08-04T12:36:28.596Z","comments":true,"path":"2020/03/13/docker-network/","link":"","permalink":"http://dengbojing.com/2020/03/13/docker-network/","excerpt":"docker-network学习","text":"docker-network学习 引言阶段性的记录一下docker学习,docker-network里面还有很多问题很搞明白,亟待解决. 以下操作都是基于docker desktop for windows的linux container模式下 介绍 docker 官方有5种网络模式,none,bridge,macvlan,host,overlay. 1.1 none 模式,参数 --network=none,无网络模式,这种模式一般很少用,官方说法是和自定义网络驱动时使用. 1.2 birdge 模式,参数 --network ${bridge_name}.该模式是默认模式,在安装docker会创建一个默认的docker0的linux网桥,如果启动容器时不指定网络,就会默认连接到docker0网桥 docker desktop for windows看不见docker0,这是因为,docker desktop for windows实际上是把Docker装在Hyper-v虚拟机上,打开Hyper-v虚拟机管理,可以看到DockerDesktopVM这个虚拟机,Docker实际是运行在这个里面,而docker0就在这个里面,但是你如果连接这个虚拟机,发现连接不上. 1.3 host 模式,参数--network=host,该模式下,容器和宿主机共用一个网络,在指定--privileged=true 时候,如果你不小心修改了网络参数,那么就会造成不必要的麻烦,所以一般不推荐这中做法,上面说到docker desktop for windows 无法查看虚拟机里面的docker0网桥,此时如果你以--network=host启动一个容器,此时你就可以执行ifconfig看到docker0网桥. 另一个查看方式docker run -it --rm --privileged --pid=host justincormack/nsenter1,启动之后,执行 ifconfig,指定 --pid=host 参数就是说,让当前启动的容器可以看到宿主机上所有的进程. 1.4 overlay 模式, 参数 network=container:${conatiner_id},该模式下,容器1和容器2共用一个网络. 1.5 macvlan 指定网络的mac地址. 实战bridge模式 docker network ls查看网络,可以看到上面讲到的3种类型的网络,至于overlay呢,是需要依赖别的容器,所以取决与别的容器的网络模式,主要学习一下桥接模式的内容. bridge 网桥模式的原理, 当创建一个容器的时候,Docker 会创建两个网络模块,一个是在容器里面叫eth0, 另一个则在宿主机里面,名字为vethxxxx,Docker 这个网络模块桥街道容器里面的eth0. 2.1 首先我们以bridge启动一个ubuntu 容器,执行: docker run -ti --rm ubuntu:14.04 bash, 启动一个一次性容器并进入 2.2 在容器中执行ifconfig, 看到如下图所示: lo: loopback 回环网络接口,也就是执行localhost或者127.0.0.1时候会走这个网络接口 eth0: 所有来自外部的流量都会通过这个网络接口 2.2 新开一个终端窗口,执行docker run -it --rm --privileged --pid=host justincormack/nsenter1 , 进入容器之后,执行ifconfig 可以看到如图所示: 其中一个vethxxx是桥接到上面ubuntu 容器的网络接口,另一个是当前这个容器的网络接口(因为当前网络没有指定网络模式,所以以默认桥接模式启动,所以也会给当前容器创建一个网络接口). 自定义网桥,之前使用docker-compose 创建了一个compose, 里面包含了一个gateway和一个zookeeper, 里面还定义了一个network ,让两个容器能够以容器名称相互访问, 了解了docker network之后,其实里面network 节点就是创建了一个bridge 网桥, 此时容器就可以通过名称相互访问, 官方名称叫 automatic service discovery 服务自动发现(瞎鸡巴翻译的). 3.1 执行docker network create -d bridge my-network创建一个bridge 类型网络, 执行docker inspect my-network 看一下里面都有什么, 如图: 可以看到,子网掩码是172,19.0.0/16,网关是172,19.0.1,可以使用--subnet=192.168.0.0/16 来指定子网掩码,另外还可以使用--gateway=192.168.0.1 指定网关, --ip-range=192.168.2.0/25指定ip范围 3.2 最好是指定子网掩码,免得网络冲突.如果不指定网关,会从地址范围内自动选择一个出来作为网关,目前测试结论默认是xxx.xxx.xxx.1. 使用docker run --network=my-network 来启动一个容器,执行ifconfig:可以看到此时ip地址为我们创建的桥接网络借口的ip地址范围 一个容器可以同时连接两个网络,使用docker network connect ${networkid|networkname} ${containerid|containername}, 如图:会有两个网络接口一个eth0,另一个eth1, 这样该容器就可以同时访问两个网路 docker network disconnect ${networkid|networkname} ${containerid|containername} 取消容器和网络的链接 --icc高级参数, 如果网络该参数为禁止,则两个容器之间是无法访问的. 后记网络这块真的是比较重要,也比较难的一块,还可以创建overlay类型的网络,有待研究.官方说法生产环境最好不要使用默认的docker0网桥,所以使用docker-compose管理容器还是一个比较好的方式.或者努力学习k8s吧. 积土成山,风雨兴焉;积水成,渊蛟龙生","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://dengbojing.com/tags/docker/"}]},{"title":"docker-compose","slug":"docker-compose","date":"2020-02-11T09:36:28.000Z","updated":"2020-07-01T01:47:58.026Z","comments":true,"path":"2020/02/11/docker-compose/","link":"","permalink":"http://dengbojing.com/2020/02/11/docker-compose/","excerpt":"what? 扫把独立日?","text":"what? 扫把独立日? 引言使用gradle插件构建镜像和docker-compose连接容器 Talk is cheap, show me the code 准备打开docker远程访问端口,docker desktop for windows GUI 界面有一个expose daemon on tcp://localhost:2375, 只需要勾选,然后重启就行;当然这个是提供一个loopback的访问,实际上你并没有真正的暴露一个局域网或者广域网访问的端口,不过对于docker-gradle 使用已经足够,如果非要提供一个远程访问端口请参考微软文档.操作很简单就是在 C:\\ProgramData\\Docker\\config\\daemon.json 添加一行&quot;hosts&quot;: [&quot;tcp://0.0.0.0:2375&quot;](ps:需要关闭expose daemon on tcp://localhost:2375), 这里需要注意的就是你 docker desktop for windows 是以windows container启动的而不是linux container 方式启动, 不然不起作用, 如果非要以linux container方式启动并且提供外网访问, 也不是没有办法具体操作参考这个issue(ps:未实验) Gradle插件构建镜像 在 build.gradle 中添加 docker-plugin 插件,然后编写脚本具体文档参考这里, 最终 build.gradle 就是像下面这样: 12345678910111213141516plugins &#123; ... id &#39;com.bmuschko.docker-spring-boot-application&#39; version &#39;6.1.3&#39; ...&#125;dependencies&#123;...&#125;docker &#123; springBootApplication &#123; baseImage &#x3D; &#39;openjdk:11&#39; ports &#x3D; [8090] maintainer &#x3D; &#39;dengbojing@qq.com&#39; images &#x3D; [&#39;dengbojing&#x2F;gateway:v3&#39;] jvmArgs &#x3D; [&#39;-Dspring.profiles.active&#x3D;production&#39;, &#39;-Xmx2048m&#39;] mainClassName &#x3D; &#39;com.yichen.ServiceGatewayApplication&#39; &#125;&#125; baseImage 基于哪个基础镜像构建. ports 需要暴露的端口. maintainer 对应 dockerfile 中已经废弃的 maintainer 命令, 添加一些元信息. images 构建出来的额镜像名称. jvmArgs 对应 dockerfile ENTRYPOINT 命令中的启动参数. mainClassName 对应 dockerfile ENTRYPOINT 命令中的启动类. 执行 gradle dockerBuildImage, 该命令就会使用 docker -H tcp://127.0.0.1:2375 build 来构建镜像, 所以要先开启 2375端口;当然该插件也能提供远程构建,具体请看官方文档;如果使用开发工具可以在开发工具gradle插件里面找到对应的执行的task;然后会在 ${classpath}/build/docker 下面看到生成的 dockerfile,这里并不是打 jar 包的方式, 而是用完整的lib 和 classes 制作镜像,然后用java -cp 指定设置 classpath 然后启动脚本写的 mianClass;此时执行 docker images 就可以看到制作的镜像. 插件提供了4个 task, 分别是 dockerPushImage–推送镜像到镜像仓库,需要指定用户名密码,具体参看官方文档 , dockerBuildImage–构建镜像 , dockerCreateDockerfile–创建dockerfile , dockerSyncBuildContext–将代码同步到docker context , 前面的 task 总是依赖后面的 task. Docker-compose介绍 &amp; 简单使用 docker-compose 是官方提供的编排项目工具, 主要是应对单机多容器之间连接通信. 使用 docker-compose.yml 作为模版文件 模版文件开头使用 version 来指定 docker-compose 文件格式,目前最新版本为3.7,具体对照关系可以参考这里 一个简单的 docker-compose.yml 示例: 123456789101112131415version: '3'services: web: build: . image: dengbojing/gateway:v4 ports: - \"8090:8090\" networks: - gateway zookeeper: image: zookeeper networks: - gatewaynetworks: gateway: version: compose的版本号,具体对应关系可以查看文档services: 需要启动的服务,一个服务对应一个容器,也就是说在执行该文件之后,会多出两个容器web,zookeeper: 服务名称, 最终创建的容器名称会以启动时候指定的 ${project_name} 加上服务的名称为完整的容器名称build: 指定构建的 docker-context 和 dockerfile, 此处都在当前目录; 详细指定格式为: 12345...build: context: . dockfile: ./dockerfile... ps: 这里可以指定 docker-gradle生成的 dockerfile 作为构建脚本.image: 指定构建完成之后的镜像名称,也就说执行完该文件会多一个以 dengbojing/gateway:v4 为名称的镜像; 下面的image为以zookeeper镜像为基础创建一个容器;ports: 对外暴露的端口 networks: 定义一个网络, 然后在 services 中使用, 此时 web 服务容器就可以通过下面的服务名–zookeeper 来访问下面的服务容器, 例: 1234spring: cloud: zookeeper: connect-string: zookeeper:2181 ps: gateway 项目为spring-cloud-gateway 项目, 使用了 zookeeper 作为注册中心和配置中心, 所以需要访问 zookeeper. 写到这里,简单的使用 docker-compose 就完成了, 不难发现对于微服务来说这种方式是非常有用的, 我们可以把我们几个服务包装成一个 docker-compose 项目,然后进行部署,它还支持从一个镜像启动多个容器实例–毕竟容器实例就是类的对象,有对个对象当然是没问题的; 这样以来那么一个文件里面就可以包含多个相同功能的服务,一个注册中心,一个配置中心,完美实现了集群功能.当然在实际生产过程中,注册中心和配置中心肯定在不同的服务器上, 所以这种方式有一定的局限性. 后记简单的学习了一下 docker-compose , 其中有很多配置和命令之后实战的时候才会真的用到. 怎么说呢: 路漫漫其修远兮, 吾将上下而求索","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://dengbojing.com/tags/docker/"},{"name":"springboot","slug":"springboot","permalink":"http://dengbojing.com/tags/springboot/"},{"name":"gradle","slug":"gradle","permalink":"http://dengbojing.com/tags/gradle/"}]},{"title":"dockerfile构建自己的应用","slug":"dockerfile","date":"2020-02-01T03:45:08.000Z","updated":"2020-08-04T12:27:43.844Z","comments":true,"path":"2020/02/01/dockerfile/","link":"","permalink":"http://dengbojing.com/2020/02/01/dockerfile/","excerpt":"使用docker构建自己的应用","text":"使用docker构建自己的应用 引言 自从docker入门以后,一发不可收拾,越学习越感觉有趣,本文记录一下在学习dockerfile构建自己应用遇到的坑以及学习心得 Talk is cheap, show me the code 环境 使用gradle+jdk11编译及打包springboot项目,然后使用docker制作镜像 项目 springboot,作为现在最流行的微服务基础框架,我相信大家已经非常非常熟悉了,即使没有使用过,肯定听说过.一般比较通用的创建方式是使用springboot官网提供的创建工具进行创建,如果你使用intellij idea那么也可以在创建的时候使用spring initializr,这个和使用官方提供的创建工具是一回事 命令 FROM该指令是dockerfile的起始命令,是必须的,而且必须是第一个,作用是以一个镜像为基础,在该镜像上进行定制. FROM [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]FROM [--platform=&lt;platform&gt;] &lt;image&gt; [AS &lt;name&gt;]FROM [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;] ARG该指令是声明一个变量: 1ARG &lt;name&gt;[&#x3D;&lt;default value&gt;] 如果想覆盖默认值,可以在执行 docker build 命令时候指定 --build-arg &lt;name&gt;=&lt;value&gt; ps:在FROM之前声明的ARG在构建阶段之外，因此，FROM之后的任何指令都不能使用它。要使用在第一个FROM之前声明的ARG的默认值，请使用ARG指令，且在构建阶段内部不带值 1234ARG VERSION&#x3D;latest FROM busybox:$VERSION ARG VERSION RUN echo $VERSION &gt; image_version LABEL该指令添加 metadata 到镜像之中,格式为键值对,如: LABEL maintainer=&quot;dengbojing@qq.com&quot; ps: 这里正好用 maintainer 字段来说明一下,官方已经将MAINTAINER 这个命令废弃,改用 LABEL 代替 RUN该指令有两种格式 shell格式, RUN &lt;command&gt; command将会在shell中执行,对于linux系统shell为/bin/bash, 对于windows系统shell为 cmd /S /D exec格式, RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] , 注意该指令不会进行shell处理,比如 RUN [&quot;echo&quot;, &quot;$home&quot;] 是不会对 $home 处理的,你需要自己指定shell,RUN [&quot;sh&quot;, &quot;-c&quot;, &quot;echo $home&quot;]. 该命令执行一次会产生一层layer,所以应该尽量合并 RUN 后面 command 比如: RUN &amp;&amp; apt-get update &amp;&amp; apt-get install -y $buildDeps CMD该指令主要作用是为容器提供一个默认的执行命令,三种格式: exec格式, CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] ,该格式是官方推荐首选格式,同样该格式也不会进行shell处理. 参数格式: CMD [&quot;param1&quot;,&quot;param2&quot;], 该格式需要指定 ENTRYPOINT ,作为 ENTRYPOINT 的参数 shell格式, CMD command param1 param2 ps: 该指令在文件中只有一个,如果有多个那么只有最后一个 CMD 才会起作用,如果在docker run 后面指定了其他命令或者参数会覆盖 CMD 后面的命令或者参数 ENTRYPOINT该指令主要作用是为容器提供一个每次都执行的命令,该命令有两种格式: exec格式: ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] ,官方推荐shell格式: ENTRYPOINT command param1 param2 ps: 同 CMD 指令如果有多个 ENTRYPOINT 也只有最有一个起作用,如果想覆盖默认的ENTRYPOINT 可以使用: docker run --entrypoint;不同点在于,该指令可以直接在 docker run 后面跟参数,而 CMD 指令不可以. COPY顾名思义,该指令主要作用就是–复制,两种格式: COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;] ps: 该指令的 --chown 只有linux才有,windows和linux权限管理不一样;另外该指令还支持通配符 EXPOSE该指令暴露一个容器内部端口到外部,格式为: EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...] ps: 该指令并非真正暴露一个端口供外部使用,只是一种说明,说明容器内部哪些端口可以被访问,在启动时候需要使用 docker run -p &lt;out port&gt;:&lt;expose port&gt; WORKDIR该指令指定工作目录,相当于shell命令里面的 cd,指定工作目录之后,后续的COPY, RUN, CMD, ENTRYPOINT 等命令都是在当前目录下完成 USAGE &amp; CONTEXT 当执行 docker build 的时候需要一个 Dockerfile 文件和一个 context, context 的涵义是指包含一些列文件的PATH或者URL,这里的 PATH 代表了文件系统的目录, URL 则代表了 Git 仓库地址. 这里文件系统的目录是包含下面的子目录以及子目录中的文件,也就是 whole directory 都会被作为上下文发送给 docker daemon. docker build 构建的时候不是在CLI(命令行界面)构建而是把 当前目录 作为 context 发送给 docker daemon, 也就是docker的守护进程,所以说不能发送过大的目录,特别是不要在根目录执行 docker build, 官方推荐是使用一个空目录作为 context 来存放 Dockerfile ,仅仅添加 Dockerfile 需要的文件. 这里遇到一些问题,执行 docker build 命令的时候会将当前目录作为 context 发送给守护进程, 但是 Dockerfile 不能直接使用这些文件,官方说明为: To use a file in the build context, the Dockerfile refers to the file specified in an instruction, for example, a COPY instruction 翻译过来就是–要在构建的 context 中使用某个文件, Dockerfile 指定一个命令来引用这个文件,例如: COPY 命令, 换句话说,就是这些文件发送给守护进程,但是不能直接使用,得通过命令来使用(后面会说明碰到的问题). 制作学习了dockerfile和指令之后,我想到应该有两种方式制作镜像 方法一: 使用gradle构建项目,然后在使用dockerfile把jar包制作成镜像: 这种方法简单,但是感觉没什么意义啊,不过随后我还真的在springboot官方指导下找到了这个方法. 第一步,执行gradle构建项目gradle build -x test 第二步,编写dockerfile 123456FROM openjdk:11LABEL maintainer&#x3D;&quot;dengbojing@qq.com&quot; ARG JAR_FILE&#x3D;build&#x2F;libs&#x2F;*.jarCOPY $&#123;JAR_FILE&#125; app.jarEXPOSE 8090ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;&#x2F;app.jar&quot;] docker build -t dengbojing/gateway 方法二: 把方法一的第一步放在Dockerfile里面,这样就少执行一步命令, 进入项目目录,新建一个空白的 Dockerfile 文件,填写如下内容: 123456FROM openjdk:11 LABEL maintainer&#x3D;&quot;dengbojing@qq.com&quot; COPY . .RUN .&#x2F;gradlew build -x test EXPOSE 8090 ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;build&#x2F;libs&#x2F;service-gateway-0.0.1-SNAPSHOT.jar&quot;] ps: 第一次写命令时候不了解 Dockerfile 和 context 的工作原理,觉得将当前工作目录发送给docker daemon 就能直接使用了,没有写COPY . ., 结果就是怎么都运行不过去,找不到gradlew 文件.后面 Google 之,看到这种写法,一脸懵,后来请教群里大神,加上仔细阅读文档,最终解惑. 这种方法有一个弊端,就是构建之后的镜像会比较大,因为 gradle 构建项目阶段所需要的额外的文件最终也被添加到镜像中了, 所以官方提供了多阶段构建. 例: 12345678910FROM openjdk:11 AS build LABEL maintainer&#x3D;&quot;dengbojing@qq.com&quot; COPY . .RUN .&#x2F;gradlew build -x test FROM openjdk:11 AS finalWORKDIR &#x2F;appCOPY --from&#x3D;build build&#x2F;libs&#x2F;service-gateway-0.0.1-SNAPSHOT.jar app.jarEXPOSE 8090 ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;app.jar&quot;] 可以对比一下两种不同方式构建的镜像最后的大小, 如下图: 可以看到,v1是通过非多阶段构建的,构建之后有1.16g大小,而通过多阶段构建,抛弃了 gradle 文件,只留下需要的项目jar包, 只有652M,好处显而易见. ps: 如果还想那个精简,那么可以使用 jre 而非 jdk; 我这里是使用的自己的一个spring-cloud-gateway项目进行学习的. 方法三: 以上的方法,是我直观能想到的方法,但是通过学习,找到了更简便的方法,那就是 gradle插件 ,编写 gradle构建脚本 ,生成 docker 镜像, 具体文档, 点击这里 后记 目前方法三还处于理论阶段,文档是看懂了,但是没有实质性的操作过.而且在项目构建过程中涉及到网络通信, spring-cloud 所有的项目都应该在注册中心注册, 我采用的 zookeeper 作为注册中心和配置中心, 这就涉及到了两个容器之间相互通信, 目前还没有学会, 目前做法是在宿主机启动 zookeeper, 然后找到 docker 虚拟网卡, 找到宿主机相对于 docker 的 ip address , 将镜像里面的 zk 地址改为宿主机相对于容器的ip, 这种方法很不容器化, 所以接着学习, 学会很容器化的方式方法. 骐骥一跃,不能十步;驽马十驾,功在不舍.","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://dengbojing.com/tags/docker/"},{"name":"springboot","slug":"springboot","permalink":"http://dengbojing.com/tags/springboot/"},{"name":"gradle","slug":"gradle","permalink":"http://dengbojing.com/tags/gradle/"}]},{"title":"docker入门学习","slug":"docker-new","date":"2020-01-25T13:12:50.000Z","updated":"2020-08-04T12:29:38.239Z","comments":true,"path":"2020/01/25/docker-new/","link":"","permalink":"http://dengbojing.com/2020/01/25/docker-new/","excerpt":"docker入门","text":"docker入门 引言 作于2020年春节大年初一晚,此时疫情真的是猛于虎,为了避免给我媳妇她们医院带来不必要的麻烦,老实在家呆着学学新知识,提升自我. Talk is cheap, show me the code 介绍 Docker 使用 Google 公司推出的 Go 语言 进行开发实现,基于 Linux 内核的 cgroup,namespace,以及 AUFS 类的 Union FS 等技术,对进程进行封装隔离,属于操作 系统层面的虚拟化技术 个人理解就是一种虚拟化技术,类似之前接触过的lvm(linux virtual machine),但是有很大的不同,lvm是有一套完整的系统,虚拟出一套硬件系统和操作系统,然后在该系统之上又有很多的应用;而容器技术里面的应用直接是运行在容器宿主的内核之上,也没有虚拟除一套硬件,一套操作系统;所以容器很轻便小巧. ps: 从以上描述可以看出,容器技术更适用于持续集成和devOps,有点 java--Complie Once,Run Anywhere 的意思,只需要打包一次,在任何地方,任何系统之上都能使用,不存在之前 各种环境 (开发环境,测试环境,灰度环境,正式环境)导致的[这段代码在我机器上好好的啊,怎么可能有问题] 安装 注册docker hub 账号 在docker官方文档上找到对应操作系统的ps: 文件还是有点大,建议使用迅雷等p2p工具下载. 本人使用windows专业版系统,选择docker desktop for windows按照官网提示下载,完成之后不着急安装,此时需要先启动hyper-v,docker desktop是依赖hyper-v的,开启hype-v之后需要重启电脑,重启之后安装docker desktop,安装过程省略,下一步下一步即可.ps: 如果你是windows 家庭版,请参考这篇文章 启动docker desktop,在系统托盘图标右键-&gt;setting,找到resources-&gt;file sharing,选择你要共享的盘符,因为docker desktop默认是使用hyper-v虚拟机,而hyper-v虚拟机默认的镜像地址都是在C盘,也就是系统盘,这会导致c盘不够用,可以直接在resources-&gt;advanced下面找到disak image location修改镜像位置,本人是没有修改,这里本人是开启了共享盘符,把之后镜像使用的存储空间映射到本地其他磁盘上,这样解决了大部分存储空间的问题,镜像存储就不管了 入门 打开power shell,这里最好是不要使用其他命令终端,本人之前学习时候使用cmd,使用cmd是有坑的,后面会讲到,输入docker login,按照提示输入之前在docker hub上注册的用户名,密码,第一次需要输入,后续可以不用,也可使用图像化界面登录,右键docker desktop系统托盘图标-&gt;login. 登录之后我们就可以是用docker search命令来搜索我们感兴趣的仓库了,比如我们安装一个mysql吧,docker search mysql,可以看到有很多的mysql镜像,还有star数和officialps: 根据是否是官方提供,可将镜像资源分为两类.一种是类似 mysql 这样的镜像,被称为基础镜像或根镜像.这些基础镜像由 Docker 公司创建、验证、支持、提供.这样的镜像往往使用单个单词作为名字.还有一种类型,比如 bitnami/mysql 镜像,它是由 Docker 的用户创建并维护的,往往带有用户名称前缀. 使用docker pull拉去镜像,具体命令如下 docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] 具体选项可以通过`docker pull --help` 来查看, - docker registry地址: 默认是docker hub,一般不需要指定 - 仓库名: 前文提到镜像名称分为两段,`&lt;username&gt;/&lt;soft name&gt;`如果不指定默认是library,即docker官方的镜像. - tag: 标签,如果不指定默认为latest,当然可以指定需要的版本,查询tag目前本人没有找到相应的命令,只能去[docker hub](https://hub.docker.com/)搜索镜像然后查看tag 综上所述,此时只需使用`docker pull mysql`就可以了 可以是用docker image ls或者docker images 查看本地镜像此时可以看到镜像的大小和在docker hub大小是不一样的,这是因为,在docker hub显示的是压缩大小,docker hub作为一个中央镜像仓库,关心的是流量大小,而不是体积大小,所以会尽可能的压缩镜像体积;而且在这里,显示的大小可能和实际占用磁盘空间大小还不一样,这是因为,镜像是有很多文件层组成,而文件层之间又存在继承,复用的关系,如果不同的镜像使用相同的基础层,那么只需要保存一份该基础层就可以了,不同镜像的其他层可以直接引用该基础层,可以使用docker system df -v来查看具体的占用情况,同时可以使用docker system prune来清理磁盘空间.docker image ls 支持通配符,如 docker images my* 可以将所有my开头的镜像都列出docker image ls -q 可以只显示镜像的 ID此外还支持 -f(--filter) 过滤模式, 比如: docker images -f since=mysql 会列出在 mysql之后的所有镜像,将 since 换成 before 可以列出之前的镜像 启动容器,每一个容器都是一个镜像实例,这个就像java里面的oop思想一样,一个镜像就是一个类,一个类的对象对应一个容器,java 里面使用new关键字实例化对象,这里我们使用docker run来启动一个容器,具体命令参数: docker run [OPTIONS] IMAGE [COMMAND] [ARG…] 此处常用的 options 有 -p 指定端口号, -P 指定端口号映射为本机随机端口号; -e 指定容器内部的环境变量;-d 指定为后台启动;-i 保持stdin标准的输入流打开状态,即使没有链接; -t 分配一个伪终端, -v 指定文件映射,即讲本地的一个目录或者文件映射到容器内部;具体启动命令: docker run -d -p 3305:3306 –privileged=true -e MYSQL_ROOT_PASSWORD=xxxx –name mysqltest -v /f/mysql/data:/var/lib/mysql -v /f/mysql/conf/my.cnf:/etc/mysql/my.cnf -v //f/mysql/mysql-files:/var/lib mysql-files/ mysql:latest –character-set-server=utf8mb4 –collation-server=utf8mb4_unicode_ci 解释一下,此时我们就把容器内部的3306端口映射为宿主机的3305端口,并且设置了mysql的配置,数据存储位置,并且进行了一系列的mysql参数设置,指定了 msyql root 的密码为xxx,–privileged是让容器内部的用户获取宿主机特殊权限,此处一定要把文件映射在你已经共享的盘符,不然会失败 查看容器状态, docker container ls -a 或 docker ps -a 可以看到容器的状态,映射端口,名字等;使用 docker stop &lt;container name\\id&gt; 停止容器, 使用 docker start &lt;container name\\id&gt; 再次启动容器,注意第一次启动容器使用 docker run 命令,该命令会创建并启动一个容器, 之后并不需要在run,只需要执行start就可以了,此外 docker run 执行时,如果指定镜像不存在,该命令会自动拉去默认仓库所匹配的镜像 删除镜像和容器删除镜像使用 docker image rm 或 docker rmi 加上镜像的 ID 来删除镜像删除容器使用 docker container rm 或 docker rm 加上容器 ID 删除容器,可以添加 -f 强制删除一个正在运行的容器;此外如果只是想清理未被容器使用的镜像可以使用 docker image prune同理,可以使用 docker container prune 清理未运行的容器如果需要删除的容器或者镜像太多,手动一个个输入就显得有点智障了,此时可以使用 docker image ls -q 来配合批量删除,比如:docker rmi $(docker image ls -q -f since=mysql)此时就会将mysql之前所有的镜像都删除ps: 此处有之前说的 cmd 的坑,使用 cmd 会报错,改用 power shell 就不会 后记基础入门就这些,后续根据自身所学内容,会陆陆续续的记录更多的东西,比如如何创建一个docker容器啊,导入导出镜像啊,私有仓库的搭建等等. 不积跬步，无以至千里；不积小流，无以成江海","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://dengbojing.com/tags/docker/"}]},{"title":"使用hexo+github pages建立静态blog","slug":"first","date":"2020-01-14T11:32:51.000Z","updated":"2020-08-04T12:41:31.060Z","comments":true,"path":"2020/01/14/first/","link":"","permalink":"http://dengbojing.com/2020/01/14/first/","excerpt":"好记性不如烂笔头 记录一下使用hexo + github pages搭建博客的过程,以及过程中遇到的坑;同时也给阅读这篇文章,想要搭建博客的人一点帮助","text":"好记性不如烂笔头 记录一下使用hexo + github pages搭建博客的过程,以及过程中遇到的坑;同时也给阅读这篇文章,想要搭建博客的人一点帮助 为什么搞独立blog市面上blog service多如牛毛为啥非要搞自己的,因为独立的才是自己的 为什么使用gihub pages因为不用买服务器,免费而且稳定,也无需域名,只需要你有github账号就能用 Talk is cheap, show me the code Git git根据自己电脑下载相应版本,本人是win10电脑使用git bash. 安装完成打开git bash, 输入git --version测试是否安装成功 注册github账号(全球最大的同性交友网站,你值得拥有). 新建&lt;username&gt;.github.io仓库. node node根据自己电脑下载相应版本 安装完成之后,在之前的git bash输入node --version测试是否安装成功 Hexo 安装好 Node.js 后，通过 npm 安装 Hexo npm install hexo-cli -g ps: 可能安装失败,如果失败,安装cnpm,然后在安装hexo;或者挂代理,走梯子 npm install -g cnpm –registry=https://registry.npm.taobao.org 安装 Hexo 完成后,执行 hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 执行完成之后目录会像 ├── _config.yml ├── node_modules │ ├── hexo │ ├── hexo-generator-archive │ ├── hexo-generator-category │ ├── hexo-generator-index │ ├── hexo-generator-tag │ ├── hexo-renderer-ejs │ ├── hexo-renderer-marked │ ├── hexo-renderer-stylus │ └── hexo-server ├── package.json ├── scaffolds │ ├── draft.md │ ├── page.md │ └── post.md ├── source │ └── _posts └── themes └── landscape ps: 简单说明一下目录作用 _config.yml 配置文件,网站的标题,作者,主题配置等 node_modules hexo的模块,较少关心 package.json 项目描述文件,不用关心 scaffolds 模版配置,较少关心 source–&gt;_post 主要存放我们写的文章 themes hexo主题,文件夹名称对应为主题名称 配置_config.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# Sitetitle: Hexo #标题subtitle: #副标题description: #描述author: #你的名字language: zh #网站使用的语言,注意使用主题下面的语言(themes--&gt;&lt;要使用的主题&gt;--&gt;languages)不然会出现未知结果timezone: Asia&#x2F;Shanghai #网站时区 # URLurl: https:&#x2F;&#x2F;dengbojing.com #地址(如果未申请域名则不需要填写)root: &#x2F; #根目录permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F; #文章的永久链接格式permalink_defaults: # trailing_index: true # Set to false to remove trailing &#39;index.html&#39; from permalinks trailing_html: true # Set to false to remove trailing &#39;.html&#39; from permalinks# Directorysource_dir: source #资源文件夹public_dir: public #由资源文件夹生成而来tag_dir: tags #标签文件夹,默认是没有的需要使用hexo new page tags 自行创建archive_dir: archives #归档文件夹category_dir: categories #分类文件夹,默认是没有的需要使用hexo new page tags 自行创建code_dir: downloads&#x2F;code #Include code 文件夹i18n_dir: :lang #国际化（i18n）文件夹skip_render: #跳过指定文件的解析# Writingnew_post_name: title.md # 新文章的文件名称default_layout: post #预设布局titlecase: false # 把标题转换为单词首字母大写external_link: enable: true # 在新标签中打开链接 field: site exclude: &#39;&#39; #排除文件filename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写render_drafts: false #显示草稿post_asset_folder: false #启动 Asset 文件夹，为 true 时，每次建立文件时，Hexo 会自动建立一个与文章同名的文件夹relative_link: false #把链接改为与根目录的相对位址future: true #显示未来的文章highlight: #代码块高亮,很多主题要求此项为false enable: true line_number: true auto_detect: true tab_replace:# Category &amp; Tagdefault_category: uncategorized #默认分类category_map: #分类别名tag_map: #标签别名# Date &#x2F; Time formatdate_format: YYYY-MM-DD #日期格式time_format: HH:mm:ss #时间格式# Paginationper_page: 10 #每页显示的文章量 (0关闭分页功能)pagination_dir: page #分页目录# Extensionstheme: next #当前主题名称(本人使用的非默认主题)# Deploymentdeploy: #部署 type: git repo: https:&#x2F;&#x2F;github.com&#x2F;username&#x2F;username.github.io.git #仓库地址 branch: master #分支名称 打开看看, 在git bash中使用 hexo g 命令生成文章,hexo s命令启动服务,下面提示访问localhost:4000,访问一下看到使用默认主题的网站 写文章 使用hexo new post &lt;filename&gt; 创建自己的第一篇文章 找到source–&gt;_post,打开&lt;filename&gt;.md 更多写作用法 123456---title: 使用hexo+github pages建立静态blogdate: 2020-01-14 19:32:51tags: [git,hexo]categories: hexo--- 在date下面添加分类和标签,可选 在—下面写正文内容,可以使用&lt;!--more--&gt;分割 比如: 简介 &lt;!--more--&gt; 正文 本地预览hexo g生成hexo s启动打开浏览器,输入localhost:4000看看吧 部署到服务器 安装一键部署 npm install hexo-deployer-git –save 执行 hexo clean(可选,正常情况不需要) hexo d 部署到&lt;username&gt;.github.io 后记 使用过程中遇到很多问题,目前都没有解决, 比如有些主题莫名看不到tags和categories仓库,最后选来选去只能使用next主题 还有写modules(比如七牛云)安装之后即使你不启用你也得写配置","categories":[{"name":"hexo","slug":"hexo","permalink":"http://dengbojing.com/categories/hexo/"}],"tags":[{"name":"git","slug":"git","permalink":"http://dengbojing.com/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"http://dengbojing.com/tags/hexo/"}]}]}