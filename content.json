{"meta":{"title":"生活不易,砥砺前行","subtitle":"Keep farmed and carry hard","description":"","author":"Dengbojing","url":"http://dengbojing.com"},"pages":[{"title":"","date":"2020-01-15T03:33:52.175Z","updated":"2020-01-15T03:33:52.175Z","comments":true,"path":"404.html","permalink":"http://dengbojing.com/404.html","excerpt":"","text":"你要找的内容不存在! 返回首页"},{"title":"tags","date":"2020-01-14T12:42:52.000Z","updated":"2020-01-14T12:43:46.157Z","comments":true,"path":"tags/index.html","permalink":"http://dengbojing.com/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2020-01-15T02:32:15.000Z","updated":"2020-01-15T12:10:22.196Z","comments":true,"path":"about/index.html","permalink":"http://dengbojing.com/about/index.html","excerpt":"","text":"About 少壮不努力,后跳带剑气 java-web开发者,就职于一家混日子的小公司,每天过着摸鱼的生活,很少加班,也不掉头发,完全一个假程序员,不过我很开心. 虽然工作年限也不短了,但是还远没有到知识输出那个境界,开此博客主要目的就收记录我积累的只是和经验,有些东西靠脑子记还真容易忘掉. 没开放评论,因为如果要问什么,我估计会被问懵逼,如果真要和我杠,请发送邮件至dengbojing@qq.com,我这人还是比较钢精的,说不定会回邮件;同样如果你有什么好的东西和我分享或者愿意指导我,那鄙人会欣喜若狂. 至于本站内容,随便复制粘贴,知识只有传播和分享才能体现他的价值,不然就是一堆冰冷的文字."}],"posts":[{"title":"","slug":"neovim-learn","date":"2023-04-15T16:00:00.000Z","updated":"2023-04-16T16:11:20.887Z","comments":true,"path":"2023/04/16/neovim-learn/","link":"","permalink":"http://dengbojing.com/2023/04/16/neovim-learn/","excerpt":"","text":"0x00从18年开始一直使用 idea-vim 插件作为编辑工具, 日常使用虽然比较频繁, 但是很少做深入了解, 只是局限于一些简单的操作, 虽然速度提升了一些, 但是远远不够, idea 号称内存黑洞, 所以一直在考虑是不是有一种很多好的工具能够替代它,最开始想到的是eclipse系列(sts, myeclipse等), 虽然现在eclipse也很强大,但是还是老问题, 如果workspaces打开项目多了,确实还是会卡, idea 没有 workspaces 这个概念,一个项目开一个窗口,造成内存吃紧;后面队任何 IDE 都失去兴趣了,就考虑是否能直接用vim, 问题在于 java 的提示和编译, 目前找到一个 lunarvim, 使用感觉和 vs code 添加 java 插件差不多.至此,实验失败, 不过过程中收获很多, 让我对 打造一个自己的专属编辑器 这个概念产生了浓厚的兴趣, 而且确实 vim 或者 neovim 确实是简单,灵活,强大. Install 官方安装包下载 windows下使用chocolatey安装, 命令为choco install neovim --pre, 此处--per 为安装beta版本(目前为0.10.0), 默认安装版本为 0.8.0, neovim 0.9.0版本之后使用lua&#96;语言管理插件. Configuration 使用choco安装nvim默认是在c:\\tools下面, 具体的安装位置, 可以通过环境变量ChocolateyToolsLocation来指定. windows操作系统下,neovim的配置文件$env:localappdata\\nvim(默认为c:\\user\\&lt;username&gt;\\appdata\\local\\nvim, 该目录也是大多数应用程序的配置文件所在目录, 详见[what&#39;s appdata](https://www.xda-developers.com/appdata/#:~:text=It&#39;s%20a%20hidden%20folder%20that,User%2Dspecific%20installations)). 创建init.lua文件, 0.8.0之前是init.vim, 之后版本也兼容init.vim但是大部分使用init.lua. 创建lua\\user文件夹, md lua\\user. 进入lua\\user目录, 创建options.lua文件, 用于做vim的通用配置, 创建globals.lua用于全局配置, 创建plugins.lua 用于加载插件. nvim init.lua 然后写入一下信息 1234vim.g.mapleader = &#x27; &#x27;require(&#x27;user.plugins&#x27;)require(&#x27;user.global&#x27;)require(&#x27;user.options&#x27;) 此处一定要先加载插件文件,如果其他文件里面有用到插件配置,会导致插件未加载,配置不生效.7. 添加插件管理, git clone https://github.com/wbthomason/packer.nvim &quot;$env:LOCALAPPDATA\\nvim-data\\site\\pack\\packer\\start\\packer.nvim&quot; 编辑插件配置文件 nvim lua/user/plugins.lua 添加nvim插件管理此处使用packer, 这个是之前没用用过的插件管理工具, 以前vim使用vim-plug感觉很简单,而且还可以指定插件位置, 这个工具初次接触有一点点难受. 12345678910111213141516171819vim.cmd [[packadd packer.nvim]]vim.cmd([[ augroup packer_user_config autocmd! autocmd BufWritePost plugins.lua source &lt;afile&gt; | PackerSync augroup end]])local status_ok, packer = pcall(require, &quot;packer&quot;)if not status_ok then returnendreturn require(&#x27;packer&#x27;).startup(function(use) -- Packer can manage itself use &#x27;wbthomason/packer.nvim&#x27;end) 此处添加插件自身管理,具体使用方法可以看github链接.9. nvim options.lua文件, 添加一些之前vim的常用配置. 12345678910111213local o = vim.opt -- nvim 对vim的配置映射o.nu = true -- 显示行号o.ignorecase = true -- 忽略大小写o.cursorline = true -- 鼠标行高亮o.langmenu = zh_CN -- 中文菜单, 貌似没啥用o.encoding = &#x27;utf-8&#x27; -- 文件编码o.bk = false -- backfile 不生成o.udf = false -- undofile 不生成, 可以指定undofie的目录 o.tabstop = 2 -- tab键多少个字宽o.shiftwidth = 2 -- &gt;&gt; 推进的字宽o.rnu = true -- 行对行号o.syntax = &#x27;on&#x27; -- 语法高亮o.bg = &#x27;dark&#x27; -- 背景色 Plugins Config (未完待续)nvim真的是有很多插件, nvm-tree 文件树可以像文件资源管理器一样,管理文件,telescope文件搜索, 简直太强大了, 但是非常依赖, 键位记忆以及键位配置, 慢慢学习, 慢慢配置","categories":[],"tags":[{"name":"vim","slug":"vim","permalink":"http://dengbojing.com/tags/vim/"},{"name":"neovim","slug":"neovim","permalink":"http://dengbojing.com/tags/neovim/"}],"keywords":[]},{"title":"spring-boot+elk","slug":"spring-boot-elk","date":"2023-01-22T14:24:58.000Z","updated":"2023-01-22T15:31:25.708Z","comments":true,"path":"2023/01/22/spring-boot-elk/","link":"","permalink":"http://dengbojing.com/2023/01/22/spring-boot-elk/","excerpt":"spring boot 结合 ELK","text":"spring boot 结合 ELK elasticsearchinstall elasticsearch apt-get upgrade wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add - apt-get install apt-transport-https apt-get update apt-get install elasticsearch configurate elasticsearch vim /etc/elasticsearch/elasticsearch.yml 12network.host: 0.0.0.0 port: 9200 其他配置 启动: systemctl start elasticsearch.service 测试: curl -X GET &quot;localhost:9200&quot; kibanainstall kibana apt-get install kibana Configure Kibana vim etc/kibana/kibana.yml 123server.port: 5601 server.host: &quot;localhost&quot;elasticsearch.hosts: [&quot;http://localhost:9200&quot;] 其他配置 启动: systemctl start kibana 开机启动(可选): systemctl enable kibana 开放防火墙, 浏览器测试访问 http://localhost:5601 Logstashinstall logstash 主要作用: input 收集, filter过滤, output输出 apt-get install logstash 开机启动(可选): systemctl enable logstash Configure Logstash vim /etc/logstash/conf.d/logstash.conf其他配置 配置说明: 以beats为例,下面使用filebeat 123456789101112input &#123; beats &#123; port =&gt; 5044 &#125;&#125;output &#123; elasticsearch &#123; hosts =&gt; [&quot;http://localhost:9200&quot;] index =&gt; &quot;%&#123;[@metadata][beat]&#125;-%&#123;[@metadata][version]&#125;&quot; &#125;&#125; FileBeat(可选)install fileBeat apt-get install filebeat configure filebeat vim /etc/filebeat/filebeat.yml 注释es配置,打开logstash配置 123456# output.elasticsearch: # Array of hosts to connect to. # hosts: [&quot;localhost:9200&quot;]output.logstash hosts: [&quot;localhost:5044&quot;] (可选)启动一个module(预设的一些日志处理模块): filebeat modules enable system system module在linux系统下会对&#x2F;var&#x2F;logs下面所有日志传输其他配置 加载日志: filebeat setup -e 其他通用日志设置修改: 123456789101112- type: filestream # Unique ID among all inputs, an ID is required. id: my-filestream-id # Change to true to enable this input configuration. enabled: false # Paths that should be crawled and fetched. Glob based paths. paths: - /var/log/*.log #- c:\\programdata\\elasticsearch\\logs\\* enable 设置为ture, paths设置为日志文件目录 启动: systemctl start filebeat 开机启动(可选): systemctl enable filebeat spring-bootadd dependency1implementation group: &#x27;net.logstash.logback&#x27;, name: &#x27;logstash-logback-encoder&#x27;, version: &#x27;7.2&#x27; configure logstashinput moule选择tcp, 其他不变, 详见文档 12345678input &#123; tcp &#123; id =&gt; &quot;tcp_1&quot; port =&gt; 9250 mode =&gt; [&quot;server&quot;] codec =&gt; json_lines &#125;&#125; set log filelogback.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt; &lt;property name=&quot;LOGS&quot; value=&quot;./logs&quot; /&gt; &lt;appender name=&quot;Console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt; &lt;Pattern&gt; %red(%d&#123;ISO8601&#125;) %highlight(%-5level) [%blue(%t)] %yellow(%C&#123;1.&#125;): %msg%n%throwable &lt;/Pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;appender name=&quot;stash&quot; class=&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;&gt; &lt;destination&gt;localhost:9250&lt;/destination&gt; &lt;!-- encoder is required --&gt; &lt;encoder class=&quot;net.logstash.logback.encoder.LogstashEncoder&quot; /&gt; &lt;/appender&gt; &lt;appender name=&quot;RollingFile&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;file&gt;$&#123;LOGS&#125;/spring-boot-logger.log&lt;/file&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;Pattern&gt;%d %p %C&#123;1.&#125; [%t] %m%n&lt;/Pattern&gt; &lt;/encoder&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- rollover daily and when the file reaches 10 MegaBytes --&gt; &lt;fileNamePattern&gt;$&#123;LOGS&#125;/archived/spring-boot-logger-%d&#123;yyyy-MM-dd&#125;.%i.log &lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;!-- LOG everything at INFO level --&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;stash&quot; /&gt; &lt;appender-ref ref=&quot;RollingFile&quot; /&gt; &lt;appender-ref ref=&quot;Console&quot; /&gt; &lt;/root&gt; &lt;!-- LOG &quot;com.lotus*&quot; at TRACE level --&gt; &lt;logger name=&quot;com.lotus&quot; level=&quot;trace&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;stash&quot; /&gt; &lt;appender-ref ref=&quot;RollingFile&quot; /&gt; &lt;appender-ref ref=&quot;Console&quot; /&gt; &lt;/logger&gt;&lt;/configuration&gt;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://dengbojing.com/tags/java/"},{"name":"spring-boot","slug":"spring-boot","permalink":"http://dengbojing.com/tags/spring-boot/"},{"name":"elk","slug":"elk","permalink":"http://dengbojing.com/tags/elk/"}],"keywords":[]},{"title":"JVM-学习","slug":"JVM-学习","date":"2021-11-25T06:05:51.000Z","updated":"2023-01-22T15:37:18.298Z","comments":true,"path":"2021/11/25/JVM-学习/","link":"","permalink":"http://dengbojing.com/2021/11/25/JVM-%E5%AD%A6%E4%B9%A0/","excerpt":"JVM 基础学习","text":"JVM 基础学习 ClassLoader SubSystem： 类加载 类链接(验证,准备,解析) 初始化 加载加载就是读取class文件,并在方法区存储对应的二进制数据,每一个class文件jvm会存储以下信息至方法区： 类(接口,枚举)的全限定名称 该类(接口,枚举)的直接父类的全限定名称 class文件是否关联一个类(接口,枚举) 修饰符信息 局部变量,成员变量信息 方法信息 常量池信息等等 在加载class文件之后,jvm会立即创建一个代表该类的Class对象,以表示堆内存上的类级别的二进制信息.每一个class文件加载之后只会创建一个代表该类的Class对象,无论你该类你在程序中使用多少次(创建多少次) 链接 验证 检查类的Class对象的二进制表示是否正确(静态约束和结构化约束),检查class文件是否符合规范,编译版本是否兼容.如果确认文件无误,可以使用jvm参数关闭验证. 准备 jvm分配静态变量内存空间(变量定义在方法区上,变量的值如果是引用类型则在堆空间,如果是原始类型直接分配在方法区上,值分配在初始化时候),并为静态变量(static)赋默认值(不是初始值,初始值在初始化阶段赋值),如果是类常量(final static)直接赋初始值 解析 将符号引用替换为直接引用(只会执行一次,这一步是可选的直到符号引用被使用).符号引用：一组String字符串能唯一定位到所引用的类,变量或者方法.(当一个类编译完成,所有的方法引用,变量引用等等都是以符号引用保存在常量池中).直接引用：直接指向目标的指针,相对偏移量(java做法),一个能定位到目标地址的句柄. 初始化这个阶段所有的静态变量会被赋初始值,所有的静态代码块被执行(从上到下,从父类到子类),符合以下任意条件会初始化类： new 一个该对象 访问(读取或者设置)该类的静态字段或者调用该类的静态方法 反射 初始化类,会先初始化父类 main方法主类,jvm会优先初始化 ClassLoader类型 BootstrapClassLoader 用c++实现,负责加载jdk-&gt;jre-&gt;lib-&gt;*.jar ExtensionClassLoader 由sun.misc.Launcher$ExtClassLoader类实现,负责加载jdk-&gt;jre-&gt;lib-&gt;ext-&gt;*.class ApplicationClassLoader 由sun.misc.Louncher$AppClassLoader实现,负责加载用户程序的类库(classpath下) CLassLoader 使用双亲委派机制(delegation hierarchy principle): 当jvm遇到一个类,会先从方法区寻找该类的二进制表示,如果未找到如,则ClassLoader SubSystem会请求Application ClassLoader来加载这个这个类,ApplicationClassLoader会委托给ExtensionClassLoader加载,ExtensionClassLoader会委托给BootstrapClassLoader加载,当父加载器如果无法加载则会在委托给子的加载器加载.ps: 这里的父子并不具有继承关系,只是上层加载器的引用. 运行时数据区域(Run-Time Data Areas)Method area方法区: AKA永久代(1.8之前),AKA MetaSpace(1.8之后);jvm规范说方法区是逻辑上属于堆空间,可以是非连续性的,可以不需要垃圾回收机制,1.7方法区的实现是堆上的永久代,1.8之后方法区的实现变成了直接在本地内存上分配的元空间(MetaSpace,存储Class类的元数据)在jvm启动时候就创建,全局共享,它存储每个类的结构,运行时常量池,字段和方法数据,构造函数,包含特殊的初始化方法.如果方法区中的内存无法满足分配请求,Java 虚拟机将抛出 OutOfMemoryError. heap堆: 在jvm启动时候创建,全局共享,堆是运行时数据区,从中分配所有类实例和数组的内存;垃圾回收机制主要是针对该区域回收.1.7: 新生代,老年代,永久代.1.8：新生代,老年代.如果对象需要分配的内存比可回收的内存多,则抛出OutOfMemoryError. stack栈：每一个线程都有一个私有的栈,在线程创建时候被创建,栈里面存储着frame(stack frame),frame保存局部变量和部分结果(方法调用过程中产生),参与方法得调用和结果得返回.当一个方法被调用时候frame就会被创建,jvm对栈只有两个操作,psuh and pop如果线程需要得栈空间大于虚拟机所允许的大小,则抛出StackOverflowError.如果栈可以动态扩展,而扩展没有足够的内存空间,或者初始化一个新的线程栈时候没有足够的空间,则会抛出OutOfMemoryError. Run-time Constant pool运行时常量池：每个类或者接口一个,分配在方法区上.包含 1.类,接口,方法,动态计算(lambda表达式)的符号引用–基本上等于对应类,接口,方法的全限定名称,但是会多出来一些额外的东西,虚拟机使用这些符号引用找到对应依赖的类. 2.类常量(final static) 如果创建类或者接口的运行时常量池需要的内存大于虚拟机可以使用的内存,则抛出OutOfMemoryError. Framestack frame用于存储局部变量和中间结果以及执行动态链接,方法返回结果,抛出异常.以下简称frame当一个方法被调用时会创建一个新的frame,当方法调用结束时候(无论正常结束还是异常结束),frame会被销毁.在任何时候一个线程只会有一个frame被执行,被称作current frame,对应的是当前正在执行的方法.当一个frame执行时候遇见调用另一个方法,会创建一个对应方法的new frame,new frame将成current frame,然后等待新的方法执行完成,new frame返回结果至之前的frame,然后之前的fram再次成为current frame并且丢弃new frame. frame分为3个部分,局部变量数组,操作对象栈,帧数据 local variables每一个frame中包含一个局部变量数组,数组的长度由编译期间方法内的代码确定,存储在class文件二进制的表示信息中(方法区中).每个数组的槽站4个字节,其中int float reference占用数组的一个槽位,long double类型占用2个槽位,byte char short将会转会为int类型占用一个槽位,boolean类型占用的槽位不同虚拟机实现不同,大部分情况占用1个槽位. operand stack操作栈,也是一个栈类型的数据结构,先进后出; 作用是stack的工作空间work space, jvm指令从局部变量数组中获取数据push至操作栈,或者从操作栈中pop数据进行操作,然后在push结果到操作栈, dynamic link每个frame都包含一个指向运行时常量池中该frame所属方法的引用,持有这个引用是为了支持方法调用过程中的动态链接.在类加载阶段中的解析阶段会将符号引用转为直接引用,这种转化也称为静态解析.另外的一部分将在运行时转化为直接引用,这部分称为动态链接. Class 文件结构123456789101112131415161718ClassFile &#123; u4 magic; //魔法数,固定的,0xCAFEBABE u2 minor_version; //编译次版本,向下兼容 u2 major_version; //编译主版本, 向下兼容 u2 constant_pool_count; //常量池长度 cp_info constant_pool[constant_pool_count-1]; //静态常量池,运行时生成动态常量池,下标从1开始 u2 access_flags; //访问权限 u2 this_class; //常量池中的该类的引用的索引 u2 super_class; //0或者是常量池中的一个索引,如果是0表示是`Object`类,如果是索引表示父类在常量池中的索引 u2 interfaces_count; //实现接口的数量 u2 interfaces[interfaces_count];//接口数组 u2 fields_count; //总共字段的数量(类变量,成员变量) field_info fields[fields_count];//字段数组 u2 methods_count; //方法数量 method_info methods[methods_count];//方法数组 u2 attributes_count; //属性数量 attribute_info attributes[attributes_count]; //属性数组,比较复杂&#125; 其中u代表字节,u1一个字节,u2两个字节分析示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class TestClass &#123; private String s = &quot;fffff&quot;; private static String s2 =&quot;xxxxxx&quot;; private final String s1 = &quot;fdasg&quot;; private final int i = 1000001; private int j; public Thread thread; public static void main(String...args)&#123; TestClass tc = new TestClass(); tc.start(); &#125; public void start()&#123; int iiii = 135; thread = new Thread(() -&gt; &#123; int jjjj = iiii; System.out.println(s1); System.out.println(++jjjj); &#125;); thread.start(); &#125;&#125;public class TestClass &#123; private String s = &quot;fffff&quot;; private static String s2 =&quot;xxxxxx&quot;; private final String s1 = &quot;fdasg&quot;; private final int i = 1000001; private int j; public Thread thread; public static void main(String...args)&#123; TestClass tc = new TestClass(); tc.start(); &#125; public void start()&#123; thread = new Thread(() -&gt; System.out.println(s1)); thread.start(); &#125;&#125; 编译之后的运行时常量池这里Constant的意思不是指存储的是常量，而是说是不变的东西，也就是说类的方法，字段名称，字段的值都是编译期间可以知道的，所以这些东西是不变的,这些存储是以静态constant_pool存储(class文件的constant_pool),当jvm启动时候就会将静态的constant_pool转换为runtime constant_pool. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197&gt; javap -v TestClass.class Constant pool: #1 = Methodref #21.#53 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = String #54 // fffff #3 = Fieldref #8.#55 // com/interact/jugg/TestClass.s:Ljava/lang/String; #4 = String #56 // fdasg #5 = Fieldref #8.#57 // com/interact/jugg/TestClass.s1:Ljava/lang/String; #6 = Integer 1000001 #7 = Fieldref #8.#58 // com/interact/jugg/TestClass.i:I #8 = Class #59 // com/interact/jugg/TestClass #9 = Methodref #8.#53 // com/interact/jugg/TestClass.&quot;&lt;init&gt;&quot;:()V #10 = Methodref #8.#60 // com/interact/jugg/TestClass.start:()V #11 = Class #61 // java/lang/Thread #12 = InvokeDynamic #0:#66 // #0:run:(Lcom/interact/jugg/TestClass;I)Ljava/lang/Runnable; #13 = Methodref #11.#67 // java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V #14 = Fieldref #8.#68 // com/interact/jugg/TestClass.thread:Ljava/lang/Thread; #15 = Methodref #11.#60 // java/lang/Thread.start:()V #16 = Fieldref #69.#70 // java/lang/System.out:Ljava/io/PrintStream; #17 = Methodref #71.#72 // java/io/PrintStream.println:(Ljava/lang/String;)V #18 = Methodref #71.#73 // java/io/PrintStream.println:(I)V #19 = String #74 // xxxxxx #20 = Fieldref #8.#75 // com/interact/jugg/TestClass.s2:Ljava/lang/String; #21 = Class #76 // java/lang/Object #22 = Utf8 s #23 = Utf8 Ljava/lang/String; #24 = Utf8 s2 #25 = Utf8 s1 #26 = Utf8 ConstantValue #27 = Utf8 i #28 = Utf8 I #29 = Utf8 j #30 = Utf8 thread #31 = Utf8 Ljava/lang/Thread; #32 = Utf8 &lt;init&gt; #33 = Utf8 ()V #34 = Utf8 Code #35 = Utf8 LineNumberTable #36 = Utf8 LocalVariableTable #37 = Utf8 this #38 = Utf8 Lcom/interact/jugg/TestClass; #39 = Utf8 main #40 = Utf8 ([Ljava/lang/String;)V #41 = Utf8 args #42 = Utf8 [Ljava/lang/String; #43 = Utf8 tc #44 = Utf8 MethodParameters #45 = Utf8 start #46 = Utf8 iiii #47 = Utf8 lambda$start$0 #48 = Utf8 (I)V #49 = Utf8 jjjj #50 = Utf8 &lt;clinit&gt; #51 = Utf8 SourceFile #52 = Utf8 TestClass.java #53 = NameAndType #32:#33 // &quot;&lt;init&gt;&quot;:()V #54 = Utf8 fffff #55 = NameAndType #22:#23 // s:Ljava/lang/String; #56 = Utf8 fdasg #57 = NameAndType #25:#23 // s1:Ljava/lang/String; #58 = NameAndType #27:#28 // i:I #59 = Utf8 com/interact/jugg/TestClass #60 = NameAndType #45:#33 // start:()V #61 = Utf8 java/lang/Thread #62 = Utf8 BootstrapMethods #63 = MethodHandle 6:#77 // REF_invokeStatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite; #64 = MethodType #33 // ()V #65 = MethodHandle 7:#78 // REF_invokeSpecial com/interact/jugg/TestClass.lambda$start$0:(I)V #66 = NameAndType #79:#80 // run:(Lcom/interact/jugg/TestClass;I)Ljava/lang/Runnable; #67 = NameAndType #32:#81 // &quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V #68 = NameAndType #30:#31 // thread:Ljava/lang/Thread; #69 = Class #82 // java/lang/System #70 = NameAndType #83:#84 // out:Ljava/io/PrintStream; #71 = Class #85 // java/io/PrintStream #72 = NameAndType #86:#87 // println:(Ljava/lang/String;)V #73 = NameAndType #86:#48 // println:(I)V #74 = Utf8 xxxxxx #75 = NameAndType #24:#23 // s2:Ljava/lang/String; #76 = Utf8 java/lang/Object #77 = Methodref #88.#89 // java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite; #78 = Methodref #8.#90 // com/interact/jugg/TestClass.lambda$start$0:(I)V #79 = Utf8 run #80 = Utf8 (Lcom/interact/jugg/TestClass;I)Ljava/lang/Runnable; #81 = Utf8 (Ljava/lang/Runnable;)V #82 = Utf8 java/lang/System #83 = Utf8 out #84 = Utf8 Ljava/io/PrintStream; #85 = Utf8 java/io/PrintStream #86 = Utf8 println #87 = Utf8 (Ljava/lang/String;)V #88 = Class #91 // java/lang/invoke/LambdaMetafactory #89 = NameAndType #92:#96 // metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite; #90 = NameAndType #47:#48 // lambda$start$0:(I)V #91 = Utf8 java/lang/invoke/LambdaMetafactory #92 = Utf8 metafactory #93 = Class #98 // java/lang/invoke/MethodHandles$Lookup #94 = Utf8 Lookup #95 = Utf8 InnerClasses #96 = Utf8 (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite; #97 = Class #99 // java/lang/invoke/MethodHandles #98 = Utf8 java/lang/invoke/MethodHandles$Lookup #99 = Utf8 java/lang/invoke/MethodHandles&#123; public java.lang.Thread thread; descriptor: Ljava/lang/Thread; flags: (0x0001) ACC_PUBLIC public com.interact.jugg.TestClass(); descriptor: ()V flags: (0x0001) ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: aload_0 5: ldc #2 // String fffff 7: putfield #3 // Field s:Ljava/lang/String; 10: aload_0 11: ldc #4 // String fdasg 13: putfield #5 // Field s1:Ljava/lang/String; 16: aload_0 17: ldc #6 // int 1000001 19: putfield #7 // Field i:I 22: return LineNumberTable: line 6: 0 line 8: 4 line 12: 10 line 14: 16 LocalVariableTable: Start Length Slot Name Signature 0 23 0 this Lcom/interact/jugg/TestClass; public static void main(java.lang.String...); descriptor: ([Ljava/lang/String;)V flags: (0x0089) ACC_PUBLIC, ACC_STATIC, ACC_VARARGS Code: stack=2, locals=2, args_size=1 0: new #8 // class com/interact/jugg/TestClass 3: dup 4: invokespecial #9 // Method &quot;&lt;init&gt;&quot;:()V 7: astore_1 8: aload_1 9: invokevirtual #10 // Method start:()V 12: return LineNumberTable: line 21: 0 line 22: 8 line 23: 12 LocalVariableTable: Start Length Slot Name Signature 0 13 0 args [Ljava/lang/String; 8 5 1 tc Lcom/interact/jugg/TestClass; MethodParameters: Name Flags args public void start(); descriptor: ()V flags: (0x0001) ACC_PUBLIC Code: stack=5, locals=2, args_size=1 0: sipush 135 3: istore_1 4: aload_0 5: new #11 // class java/lang/Thread 8: dup 9: aload_0 10: iload_1 11: invokedynamic #12, 0 // InvokeDynamic #0:run:(Lcom/interact/jugg/TestClass;I)Ljava/lang/Runnable; 16: invokespecial #13 // Method java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V 19: putfield #14 // Field thread:Ljava/lang/Thread; 22: aload_0 23: getfield #14 // Field thread:Ljava/lang/Thread; 26: invokevirtual #15 // Method java/lang/Thread.start:()V 29: return LineNumberTable: line 26: 0 line 27: 4 line 32: 22 line 34: 29 LocalVariableTable: Start Length Slot Name Signature 0 30 0 this Lcom/interact/jugg/TestClass; 4 26 1 iiii I static &#123;&#125;; descriptor: ()V flags: (0x0008) ACC_STATIC Code: stack=1, locals=0, args_size=0 0: ldc #19 // String xxxxxx 2: putstatic #20 // Field s2:Ljava/lang/String; 5: return LineNumberTable: line 10: 0&#125; 十六进制字节码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114TestClass.class00000000: cafe babe 0000 0037 0064 0a00 1500 3508 .......7.d....5.00000010: 0036 0900 0800 3708 0038 0900 0800 3903 .6....7..8....9.00000020: 000f 4241 0900 0800 3a07 003b 0a00 0800 ..BA....:..;....00000030: 350a 0008 003c 0700 3d12 0000 0042 0a00 5....&lt;..=....B..00000040: 0b00 4309 0008 0044 0a00 0b00 3c09 0045 ..C....D....&lt;..E00000050: 0046 0a00 4700 480a 0047 0049 0800 4a09 .F..G.H..G.I..J.00000060: 0008 004b 0700 4c01 0001 7301 0012 4c6a ...K..L...s...Lj00000070: 6176 612f 6c61 6e67 2f53 7472 696e 673b ava/lang/String;00000080: 0100 0273 3201 0002 7331 0100 0d43 6f6e ...s2...s1...Con00000090: 7374 616e 7456 616c 7565 0100 0169 0100 stantValue...i..000000a0: 0149 0100 016a 0100 0674 6872 6561 6401 .I...j...thread.000000b0: 0012 4c6a 6176 612f 6c61 6e67 2f54 6872 ..Ljava/lang/Thr000000c0: 6561 643b 0100 063c 696e 6974 3e01 0003 ead;...&lt;init&gt;...000000d0: 2829 5601 0004 436f 6465 0100 0f4c 696e ()V...Code...Lin000000e0: 654e 756d 6265 7254 6162 6c65 0100 124c eNumberTable...L000000f0: 6f63 616c 5661 7269 6162 6c65 5461 626c ocalVariableTabl00000100: 6501 0004 7468 6973 0100 1d4c 636f 6d2f e...this...Lcom/00000110: 696e 7465 7261 6374 2f6a 7567 672f 5465 interact/jugg/Te00000120: 7374 436c 6173 733b 0100 046d 6169 6e01 stClass;...main.00000130: 0016 285b 4c6a 6176 612f 6c61 6e67 2f53 ..([Ljava/lang/S00000140: 7472 696e 673b 2956 0100 0461 7267 7301 tring;)V...args.00000150: 0013 5b4c 6a61 7661 2f6c 616e 672f 5374 ..[Ljava/lang/St00000160: 7269 6e67 3b01 0002 7463 0100 104d 6574 ring;...tc...Met00000170: 686f 6450 6172 616d 6574 6572 7301 0005 hodParameters...00000180: 7374 6172 7401 0004 6969 6969 0100 0e6c start...iiii...l00000190: 616d 6264 6124 7374 6172 7424 3001 0004 ambda$start$0...000001a0: 2849 2956 0100 046a 6a6a 6a01 0008 3c63 (I)V...jjjj...&lt;c000001b0: 6c69 6e69 743e 0100 0a53 6f75 7263 6546 linit&gt;...SourceF000001c0: 696c 6501 000e 5465 7374 436c 6173 732e ile...TestClass.000001d0: 6a61 7661 0c00 2000 2101 0005 6666 6666 java.. .!...ffff000001e0: 660c 0016 0017 0100 0566 6461 7367 0c00 f........fdasg..000001f0: 1900 170c 001b 001c 0100 1b63 6f6d 2f69 ...........com/i00000200: 6e74 6572 6163 742f 6a75 6767 2f54 6573 nteract/jugg/Tes00000210: 7443 6c61 7373 0c00 2d00 2101 0010 6a61 tClass..-.!...ja00000220: 7661 2f6c 616e 672f 5468 7265 6164 0100 va/lang/Thread..00000230: 1042 6f6f 7473 7472 6170 4d65 7468 6f64 .BootstrapMethod00000240: 730f 0600 4d10 0021 0f07 004e 0c00 4f00 s...M..!...N..O.00000250: 500c 0020 0051 0c00 1e00 1f07 0052 0c00 P.. .Q.......R..00000260: 5300 5407 0055 0c00 5600 570c 0056 0030 S.T..U..V.W..V.000000270: 0100 0678 7878 7878 780c 0018 0017 0100 ...xxxxxx.......00000280: 106a 6176 612f 6c61 6e67 2f4f 626a 6563 .java/lang/Objec00000290: 740a 0058 0059 0a00 0800 5a01 0003 7275 t..X.Y....Z...ru000002a0: 6e01 0034 284c 636f 6d2f 696e 7465 7261 n..4(Lcom/intera000002b0: 6374 2f6a 7567 672f 5465 7374 436c 6173 ct/jugg/TestClas000002c0: 733b 4929 4c6a 6176 612f 6c61 6e67 2f52 s;I)Ljava/lang/R000002d0: 756e 6e61 626c 653b 0100 1728 4c6a 6176 unnable;...(Ljav000002e0: 612f 6c61 6e67 2f52 756e 6e61 626c 653b a/lang/Runnable;000002f0: 2956 0100 106a 6176 612f 6c61 6e67 2f53 )V...java/lang/S00000300: 7973 7465 6d01 0003 6f75 7401 0015 4c6a ystem...out...Lj00000310: 6176 612f 696f 2f50 7269 6e74 5374 7265 ava/io/PrintStre00000320: 616d 3b01 0013 6a61 7661 2f69 6f2f 5072 am;...java/io/Pr00000330: 696e 7453 7472 6561 6d01 0007 7072 696e intStream...prin00000340: 746c 6e01 0015 284c 6a61 7661 2f6c 616e tln...(Ljava/lan00000350: 672f 5374 7269 6e67 3b29 5607 005b 0c00 g/String;)V..[..00000360: 5c00 600c 002f 0030 0100 226a 6176 612f \\.`../.0..&quot;java/00000370: 6c61 6e67 2f69 6e76 6f6b 652f 4c61 6d62 lang/invoke/Lamb00000380: 6461 4d65 7461 6661 6374 6f72 7901 000b daMetafactory...00000390: 6d65 7461 6661 6374 6f72 7907 0062 0100 metafactory..b..000003a0: 064c 6f6f 6b75 7001 000c 496e 6e65 7243 .Lookup...InnerC000003b0: 6c61 7373 6573 0100 cc28 4c6a 6176 612f lasses...(Ljava/000003c0: 6c61 6e67 2f69 6e76 6f6b 652f 4d65 7468 lang/invoke/Meth000003d0: 6f64 4861 6e64 6c65 7324 4c6f 6f6b 7570 odHandles$Lookup000003e0: 3b4c 6a61 7661 2f6c 616e 672f 5374 7269 ;Ljava/lang/Stri000003f0: 6e67 3b4c 6a61 7661 2f6c 616e 672f 696e ng;Ljava/lang/in00000400: 766f 6b65 2f4d 6574 686f 6454 7970 653b voke/MethodType;00000410: 4c6a 6176 612f 6c61 6e67 2f69 6e76 6f6b Ljava/lang/invok00000420: 652f 4d65 7468 6f64 5479 7065 3b4c 6a61 e/MethodType;Lja00000430: 7661 2f6c 616e 672f 696e 766f 6b65 2f4d va/lang/invoke/M00000440: 6574 686f 6448 616e 646c 653b 4c6a 6176 ethodHandle;Ljav00000450: 612f 6c61 6e67 2f69 6e76 6f6b 652f 4d65 a/lang/invoke/Me00000460: 7468 6f64 5479 7065 3b29 4c6a 6176 612f thodType;)Ljava/00000470: 6c61 6e67 2f69 6e76 6f6b 652f 4361 6c6c lang/invoke/Call00000480: 5369 7465 3b07 0063 0100 256a 6176 612f Site;..c..%java/00000490: 6c61 6e67 2f69 6e76 6f6b 652f 4d65 7468 lang/invoke/Meth000004a0: 6f64 4861 6e64 6c65 7324 4c6f 6f6b 7570 odHandles$Lookup000004b0: 0100 1e6a 6176 612f 6c61 6e67 2f69 6e76 ...java/lang/inv000004c0: 6f6b 652f 4d65 7468 6f64 4861 6e64 6c65 oke/MethodHandle000004d0: 7300 2100 0800 1500 0000 0600 0200 1600 s.!.............000004e0: 1700 0000 0a00 1800 1700 0000 1200 1900 ................000004f0: 1700 0100 1a00 0000 0200 0400 1200 1b00 ................00000500: 1c00 0100 1a00 0000 0200 0600 0200 1d00 ................00000510: 1c00 0000 0100 1e00 1f00 0000 0500 0100 ................00000520: 2000 2100 0100 2200 0000 4d00 0200 0100 .!...&quot;...M.....00000530: 0000 172a b700 012a 1202 b500 032a 1204 ...*...*.....*..00000540: b500 052a 1206 b500 07b1 0000 0002 0023 ...*...........#00000550: 0000 0012 0004 0000 0006 0004 0008 000a ................00000560: 000c 0010 000e 0024 0000 000c 0001 0000 .......$........00000570: 0017 0025 0026 0000 0089 0027 0028 0002 ...%.&amp;.....&#x27;.(..00000580: 0022 0000 0049 0002 0002 0000 000d bb00 .&quot;...I..........00000590: 0859 b700 094c 2bb6 000a b100 0000 0200 .Y...L+.........000005a0: 2300 0000 0e00 0300 0000 1500 0800 1600 #...............000005b0: 0c00 1700 2400 0000 1600 0200 0000 0d00 ....$...........000005c0: 2900 2a00 0000 0800 0500 2b00 2600 0100 ).*.......+.&amp;...000005d0: 2c00 0000 0501 0029 0000 0001 002d 0021 ,......).....-.!000005e0: 0001 0022 0000 005e 0005 0002 0000 001e ...&quot;...^........000005f0: 1100 873c 2abb 000b 592a 1bba 000c 0000 ...&lt;*...Y*......00000600: b700 0db5 000e 2ab4 000e b600 0fb1 0000 ......*.........00000610: 0002 0023 0000 0012 0004 0000 001a 0004 ...#............00000620: 001b 0016 0020 001d 0022 0024 0000 0016 ..... ...&quot;.$....00000630: 0002 0000 001e 0025 0026 0000 0004 001a .......%.&amp;......00000640: 002e 001c 0001 1002 002f 0030 0001 0022 ........./.0...&quot;00000650: 0000 005f 0002 0003 0000 0015 1b3d b200 ..._.........=..00000660: 1012 04b6 0011 b200 1084 0201 1cb6 0012 ................00000670: b100 0000 0200 2300 0000 1200 0400 0000 ......#.........00000680: 1c00 0200 1d00 0a00 1e00 1400 1f00 2400 ..............$.00000690: 0000 2000 0300 0000 1500 2500 2600 0000 .. .......%.&amp;...000006a0: 0000 1500 2e00 1c00 0100 0200 1300 3100 ..............1.000006b0: 1c00 0200 0800 3200 2100 0100 2200 0000 ......2.!...&quot;...000006c0: 1e00 0100 0000 0000 0612 13b3 0014 b100 ................000006d0: 0000 0100 2300 0000 0600 0100 0000 0a00 ....#...........000006e0: 0300 3300 0000 0200 3400 5f00 0000 0a00 ..3.....4._.....000006f0: 0100 5d00 6100 5e00 1900 3e00 0000 0c00 ..].a.^...&gt;.....00000700: 0100 3f00 0300 4000 4100 400a ..?...@.A.@. 1.cafebabe固定4个字节2.0000 次版本,无3.0037 主版本,对应十进制为55,查找版本对照表,为11,具体规则可以查看jvm规范,无非就是什么版本对应什么数字,哪些版本没有次要版本,做了什么兼容设定4.0064 常量池长度,对应十进制为100,上面常量池示例中正好到序号99.5.0a 对应常量池第一个变量,cp_info具体结构为: 12345cp_info &#123; u1 tag; u1 info[];&#125; 所以第一个字符0a对用为10,10对应的cp_info的tag为Method_ref,对应结构如下: 12345CONSTANT_Methodref_info &#123; u1 tag; u2 class_index; u2 name_and_type_index;&#125; 所以随后的两个字节0015代表着对应的class在常量池中的索引,0015对应的十进制为21,查看上面javap代码可以找到对应#21为java.lang.Object类.在之后的2个字节0035代表着也对应着常量池中的索引，而该索引处的数据结构必须符合CONSTANT_NameAndType_info,0035对应十进制为53,查看上面javap代码,得到#53是一个NameAndType而且按照对应的结构引用了utf_8结构的#32#33,分别为特殊方法&lt;init&gt;以及返回值()v,世界上就是一个初始化方法.上述分析对比一下javap反编代码的常量池#1,符合我们的分析. 静态常量池中的CONSTANT_NameAndType_info, CONSTANT_Module_info, and CONSTANT_Package_info, and the foundational structure CONSTANT_Utf8_info不会被转换至动态常量池中,这些结构只会在初始化实例时候间接的使用 后记简单的jvm入门是完成了,虽然看懂了,但是不知道又什么用,参考了很多文章和书籍,jvm规范是最权威的,但是写的略简单,而博客文章又是千篇一律,互相抄,所以最后总结还是看书加动手实践是最好的.","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://dengbojing.com/tags/java/"}],"keywords":[]},{"title":"Effective-java-第十一章学习笔记","slug":"Effective-java-第十一章学习笔记","date":"2021-09-20T02:42:02.000Z","updated":"2023-01-22T15:37:18.255Z","comments":true,"path":"2021/09/20/Effective-java-第十一章学习笔记/","link":"","permalink":"http://dengbojing.com/2021/09/20/Effective-java-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"第十一章: 并发","text":"第十一章: 并发","categories":[],"tags":[{"name":"java,读书笔记","slug":"java-读书笔记","permalink":"http://dengbojing.com/tags/java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"keywords":[]},{"title":"Effective-java-第十章学习笔记","slug":"Effective-java-第十章学习笔记","date":"2021-09-19T04:35:15.000Z","updated":"2023-01-22T15:37:18.249Z","comments":true,"path":"2021/09/19/Effective-java-第十章学习笔记/","link":"","permalink":"http://dengbojing.com/2021/09/19/Effective-java-%E7%AC%AC%E5%8D%81%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"第十章: 异常","text":"第十章: 异常 异常只在异常情况下使用异常不应该用于流程控制： 现代的jvm设计并没有对异常进行优化设计. 将代码放入try-catch模块，将组织jvm对其进行优化. 对于使用异常控制流程的代码可以使用状态测试方法(比如iterator的next方法为状态测试方法，hasNext()为依赖状态测试的方法)，或者返回optional空包含。如果是并发访问并且没有额外的同步控制或者方法调用会改变对象状态，应该使用返回optonal空包含；否则应该使用状态测试方法，状态测试方法具有更好的可读性,而且如果错误的使用也会被更容易的检测出来。 可恢复情况使用checked Exception，对于不可恢复情况使用未受检查异常unchecked Exception所有checked exception都是RuntimeException的子类（直接或者间接的继承） 异常应该提供一个获取异常详细信息的方法,比如：触发条件，如何恢复，特别是checked Exception 避免不必要的checked Exceptionchecked Exception可以调高程序的可读性，但是过度使用也会给调用客户端带来痛苦，所以当程序出意外时候可以恢复但是又需要客户端必须要处理一些意外的情况，可以使用optional. 如果optional不能满足情况(无法提供额外的信息说明为什么不能执行)，那么可以返回一个checked exception. 使用标准异常(java内置) 异常 翻译 何时使用 IllegalArgumentException 参数错误 参数不符合要求 IllegalStateException 状态错误 对象状态不符合调用该方法 NullPointerException 空指针 参数为空 IndexOutOfBoundsException 下标越界 数据或者集合下标超出长度 ConcurrentModificationException 并发修改 并发修改一个对象使不被允许的 UnsupportedOperationException 对象不支持该操作 对象不不具备该操作 这些是常用的异常，当然还有其他异常可以使用。 异常转译高层调用将底层的异常包装起来，抛出更高层次的异常给调用者，避免调用者感到困惑. 异常链: 底层的异常信息对于调试有作用，此时高层的异常提供一个访问的方法获取底层异常的信息(比如: Throwable的getCause()方法) 异常文档注释注释添加@throws表明会抛出哪些异常. 异常信息包含细节信息异常详细信息应该包含除去敏感信息的所有参数值. 失败的原子性当抛出异常时候，应该保持使用的对象保持在调用之前的状态. 对象设计为immutable 进行参数检查，在方法开始检查参数是否有效，如果不满足调用条件，提前抛出异常，保持对象的状态不被改变. 创建一个临时的拷贝对象进行操作，操作完成之后使用临时拷贝对象中的结果作为代替原来对象的内容，如果失败，原对象内容并不会被改变. 最不常用的方法，编写一段recovery code回滚对象状态. 后记并没有关于自定义异常使用的建议，个人在写代码会使用自定义异常（BusinessException关闭爬栈开关）作为方法调用的前置条件不满足时的异常（参数检查不通过，抛出异常）.","categories":[],"tags":[{"name":"java,读书笔记","slug":"java-读书笔记","permalink":"http://dengbojing.com/tags/java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"keywords":[]},{"title":"Effective-java-第九章学习笔记","slug":"Effective-java-第九章学习笔记","date":"2021-08-25T07:19:25.000Z","updated":"2023-01-22T15:37:18.246Z","comments":true,"path":"2021/08/25/Effective-java-第九章学习笔记/","link":"","permalink":"http://dengbojing.com/2021/08/25/Effective-java-%E7%AC%AC%E4%B9%9D%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"第九章：通用编程意见","text":"第九章：通用编程意见 最小化局部变量得作用范围前面说过将类得成员变量访问最小化，增强代码得可读性和可维护性，同样将局部变量得访问最小化，也利于维护和可读性。 在变量使用前声明如果过早得声明变量，会造成读代码的人不得一直记住这个变量的值，会给阅读带来混乱，等到读到使用变量的地方，可能读者已经忘记了变量的值，不得不重新在去寻找一遍该变量的声明。如果一变量在使用他的代码块(&#123;&#125;之间)之外声明，那么在代码块执行结束以后，该变量仍然可见，如果在在代码块执行之前被失误的使用，那么可能造成程序错误。 声明变量应该初始化(赋值)如果你要声明一个变量那么最好是有足够的信息进行初始化该变量，否则应该推迟到直至有足够的信息初始化该变量在声明。在try-catch声明变量例外，因为try里面的变量外部无法访问，那么就无法释放资源。 循环变量一般在循环中的变量都有一个特殊的地方声明变量来使变量作用域最小化，就是在循环的小括号内，因此应该优先使用for循环，而不是while循环，因为while循环没有一个特殊的地方(小括号内)声明变量，比如： 1234567891011121314for (Element e : c) &#123;... // Do Something with e&#125;Iterator&lt;Element&gt; i = c.iterator();while (i.hasNext()) &#123;doSomething(i.next());&#125; ...Iterator&lt;Element&gt; i2 = c2.iterator();while (i.hasNext()) &#123; // BUG!doSomethingElse(i2.next());&#125; 上述while循环就会出现问题，第二个while循环使用的条件判断是i而不是i2,有可能第二个while会执行，也可能不会执行，也可能执行几个，那得看c比c2大多少倍了。 第一个增强的for循环就不会有问题。 另一种是循环变量最小化的做法： 123for (int i = 0, n = expensiveComputation(); i &lt; n; i++) &#123;... // Do something with i;&#125; n用来表示i的上限，此处n只是用来限制i的上限，只会被用到一次，所以应该声明为循环变量。 是方法体代码少和功能单一如果把多个功能的操作合并到一个方法里面，不仅造成方法臃肿，而且两个功能的操作变量还可能重复，造成误操作。、 优先使用for-each循环代替for循环传统的迭代器循环 12345// Not the best way to iterate over a collection!for (Iterator&lt;Element&gt; i = c.iterator(); i.hasNext(); ) &#123;Element e = i.next();... // Do something with e&#125; 传统的数组循环 12345Click here to view code image// Not the best way to iterate over an array!for (int i = 0; i &lt; a.length; i++) &#123;... // Do something with a[i]&#125; 以上两种方法，迭代器中的变量和索引变量都要使用3次，可能会出现错误的使用索引(多重循环最容易出现此问题)，编译器可能发现不了问题。使用for-each循环(增强的for) 123for (Element e : elements) &#123;... // Do something with e&#125; 总之，for-each循环的简洁性和预防bug性都要强于传统的for循环，但是如果有一下情况无法使用for-each循环。 过滤-如果要遍历集合，并删除指定元素，就需要显示的的迭代器，以便可以调用它的remove方法。 转换-如果需要遍历数组，并且替换其中某些位置的元素，那么就需要用到下标替换。 平行迭代-如果需要并行的遍历多个集合，就需要显示的控制迭代器或者索引变量，以便于所有的迭代器或者索引都同步前向移动。 了解和使用java常用类库书中开头举例了一个随机算法的例子，说明了线性同余x(n+1) = (a*x(n)+c) % n伪随机方法,a,c,n为常数，x(n)随机种子，产生随机数的缺陷： 存在生成周期，如果n比较小,那么生成周期就小，随机数过一个周期就会重复。 如果n不是一个2的乘方，随机分布不均匀，如果n比较大更会体现出这个缺点。 第三个问题和线性随机无关，是java中最小值取绝对值，还是最小值(负值)。 但是书中又说了,直接使用Random.nextInt(int)就可以产生一个想要的随机数，没看太明白，待实践到底表达什么意思 同时jdk7以后生成随机数时候使用threadlocalrandom，在stream中使用splittablerandom 总之， 每个java程序员都应该熟悉的包：java.lang, java.util.concurrent, java.util.function, java.time, java.io, java.nio, java.util.stream 精确的数值计算避免使用 float double浮点数公式: V &#x3D; (-1)^S * M * R^E 其中各个变量的含义如下： S：符号位，取值 0 或 1，决定一个数字的符号，0 表示正，1 表示负 M：尾数，用小数表示，例如前面所看到的 8.345 * 10^0，8.345 就是尾数 R：基数，表示十进制数 R 就是 10，表示二进制数 R 就是 2 E：指数，用整数表示，例如前面看到的 10^-1，-1 即是指数 参见文章浮点数的二进制表述, 显然由于浮点数的表示精度由尾数决定, 浮点数的范围有指数决定,而浮点数是固定宽度的(32和64位), 按照约定来说就可能出现丢失精度或者说出现很大无法表示的小数, 在对数字高敏感度的环境并不适用, 比如银行交易(在项目里使用浮点数计算金钱基本就等着被开除吧), 出现了错误可能是致命的, 所以应该是BigDecimal来代替。 基本类型优先于包装类型 基本类型值包含值，包装类型不仅包含值，还包含一些对象信息，所以包装类型是不能使用&#x3D;&#x3D;进行比较的. 在使用包装类型进行操作时候，会出现空指针异常，而且进行算术运算会有自动拆箱操作，性能较差. 在编写PO和VO时候应该使用包装类型，数据对应的任何字段都有可能是null值，使用基本类型在获取数据时候会出现错误，前端页面传值也会有这种问题 有更合适的类型，尽量避免使用String String 不适合代替其他类型得值 String 不适合代替枚举值 String 不适合代替聚合类型 String 不适合作为能力表示 字符串连接+性能低下如果在for循环中拼接字符串，使用+会使得性能非常低下，建议使用StringBuilder,如果只是定义简单得字符串可以使用+ 通过接口引用对象如果有合适得接口存在，那么参数，返回值，成员变量，这些都应该被定义为接口类型。使用接口定义，可以使程序更加零多（多态性），有一种例外，就是如果需要类得具体功能，而接口又不具备，那么此时应该使用具体得类作为对象的引用。 接口优先于反射反射性能非常差，而且代码多，编译期间无法检查你反射出的对象是否可以执行对应的代码。但是有些时候不得不使用反射，在编写一些底层框架代码,如Spring等这些框架就利用了反射，而反射只需要在启动时候执行一次，也不会影响运行过程中的性能;或者编写一些类似对象监视作用的代码也可能会需要反射机制。 谨慎的使用native代码非常难以调试，出错了也不知道报错信息，之前朋友代码中使用JNI非常不友好，native代码出错没法调试，内存泄漏没法控制，灾难性的东西。 不要过早的优化 More computing sins are committed in the name of efficiency (withoutnecessarily achieving it) than for any other single reason—including blindstupidity. —William A. Wulf [Wulf72] We should forget about small efficiencies, say about 97% of the time:premature optimization is the root of all evil. —Donald E. Knuth [Knuth74] We follow two rules in the matter of optimization:Rule 1. Don’t do it.Rule 2 (for experts only). Don’t do it yet—that is, not until you have aperfectly clear and unoptimized solution. —M. A. Jackson [Jackson75] 努力编写好的程序，而不是快的程序 努力避免那些限制性能的设计决策 考虑API设计决策对性能的影响 未获得更好的性能，对API进行包装，是一个非常愚蠢的想法 每次优化前后都要进行性能测试 遵循通用命名规范参见Naming Convention–命名规范","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://dengbojing.com/tags/java/"}],"keywords":[]},{"title":"Effective-java-第八章学习","slug":"Effective-java-第八章学习","date":"2021-08-19T19:23:55.000Z","updated":"2023-04-16T10:04:18.419Z","comments":true,"path":"2021/08/20/Effective-java-第八章学习/","link":"","permalink":"http://dengbojing.com/2021/08/20/Effective-java-%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%AD%A6%E4%B9%A0/","excerpt":"第八章：方法","text":"第八章：方法 检查方法参数failure atomicity(原子性失败): 失败的方法调用，应该使对象保持在被调用之前的状态。 如果一个方法在执行之前未检查参数，那么可能出现以下几种情况： 方法执行失败，抛出令人困惑的异常。 方法执行成功，但是返回的值不正确。 方法执行成功，返回值也是正确的，但是有些对象的状态可能处于未知的状态，可能在未知的时刻，未知的调用情况下出现错误。 以上几点都违反了原子性失败，基于以上几点，所以在方法执行前一定要进行方法参数的检查。检查遵循如下约定： 对于public和protected方法，可以在方法上使用@throw注释说明方法参数可能会引发何种异常，比如IllegalArgumentException, IndexOutOfBoundsException, NullPointerException，并且在参数未通过检查时，抛出这些异常。 使用@Nullable和其他相似的注解，注解在方法参数上，指示方法参数是否可以为空等等。 使用Objects工具类中提供的静态方法，进行方法参数的校验。 对于不被暴露对外的方法(private)，可以控制在什么情况下被调用，可以确认什么时候被调用，什么样参数会被传入，可以使用断言assert，通常在测试时候可以使用-ea开启断言，在正式环境默认是不开启。 对于有些参数在方法本身没有用到，只是保存起来以便以后使用，对于这种参数检查特别重要，因为如果不检查在之后使用中出现了错误，你无法知道是参数错误还是其他错误，举例：静态工厂方法Lists.asList()，构造函数等。 参数检查也有例外，比如检查参数非常的消耗资源，或者有效性检查，隐式的在后续计算中完成，Collections.sort(list)(不用检查list中每个元素是否可以比较，sort方法会做出检查)，当然有可能隐式的检查抛出的异常和我们预期的异常是不同的，所以此时我们需要进行异常转换。 并非参数检查越多越好，如果一个方法能接受所有的参数而且都能工作，非常的通用，那么对参数的限制当然是越少越好。 参数的检查应该写在方法的注释中。 防御性的复制(拷贝)不可变类123456789101112131415161718192021222324// Broken &quot;immutable&quot; time period classpublic final class Period &#123; private final Date start; private final Date end; /** * @param start the beginning of the period * @param end the end of the period; must not precede start * @throws IllegalArgumentException if start is after end * @throws NullPointerException if start or end is null */ public Period(Date start, Date end) &#123; if (start.compareTo(end) &gt; 0) throw new IllegalArgumentException(start + &quot; after &quot; + end); this.start = start; this.end = end; &#125; public Date start() &#123; return start; &#125; public Date end() &#123; return end; &#125; ... // Remainder omitted&#125; 上述代码看起来是不可变，实际上有两个问题: start(),end()方法返回了类的成员变量的引用，调用者可以使用该引用改变成员变量。 构造函数中将传入参数的引用赋给成员变量，如果该引用发生了变化，那么该类的实例也发生了变化。 修改： 在构造函数中使用形参内容创建一个copy的中间对象，然后在将中间对象赋值给成员变量，这样即使传入的参数内容发生了改变也不在会影响该类的实例。 1234567public Period(Date start, Date end) &#123; this.start = new Date(start.getTime()); this.end = new Date(end.getTime()); if (this.start.compareTo(this.end) &gt; 0) throw new IllegalArgumentException( this.start + &quot; after &quot; + this.end);&#125; start(),end() 方法返回该成员变量的copy对象。 123456public Date start() &#123; return new Date(start.getTime());&#125;public Date end() &#123; return new Date(end.getTime());&#125; ps: 在jdk 8以后的版本可以直接使用java.time下的LocalDate，因为LocalDate被设计成不变的。但是本例讨论的是不可变类在内部有可变成员变量时候如何保证不可变性。 defensive copy: 以上设计就是一种防御性复制(拷贝)。 一个不可变的类中含有可变的成员变量，在构造函数中进行防御性复制是不可缺少的。 防御性拷贝应该是在参数检查之前进行，并且参数检查应该检查防御性拷贝之后对象，如果先进行参数检查，在进行拷贝，那么在参数检查之后拷贝进行之前这段脆弱的窗口期其他线程就可以改变参数的内容(虽然时间很短，但是多线程可能出现这种情况)，那么在进行拷贝时，可能就是一个不正确的值。在计算机安全社区，这种是一种攻击手段，叫做： TOCTOU : tiem of check&#x2F;time of use 上述构造方法中并没有使用date.clone()方法获得一个拷贝，因为Date类可以被继承，所以实际的参数就可以是Date的子类的实例，在这种情况调用clone方法，并不能保证正确性和安全性。所以对于 不被信任 可以被子类化的参数(参数的类是可以被继承，实现(implements))不要使用其clone（）方法。但是在start(),end()成员方法时可以使用clone()方法，因为，此时我们已经知道了start,end成员变量就是Date类型，是可以被信任的。 可变类在编写可变类时候也要仔细的考虑是否可以接受客户端传入一个可变的参数，如果不能，那么就要进项防御性拷贝，避免客户端改变参数，影响该类的实例。 其次在返回类的成员变量之前也要考虑是否可以接受客户端改变该类的成员变量的引用，或者改变其内容，如果不能，那么也要进行防御性拷贝。 如果使用不可变类的对象作为成员变量，那么就不必考虑防御性拷贝。 简而言之，如果类具有从客户端得到或者返回到客户端的可变组件，类就必须考虑是否要进行防御性拷贝。 仔细的设计方法签名 仔细的设计方法名称，应该是见名之意，容易理解，并且保持和类的内部或者包内部其他方法名称格式保持一致，而且方法名也不能过长。 不要过于追求便利：每个方法都应该做到它的责任，太多的方法，使类或者接口难以维护，阅读，实现。 避免过长的参数列表： 最多4个参数，特别使相同类型的长参数列表，调用的时候记不住顺序，类型又相同，非常容易传错参数，但是类型相同，编译又不会出错。如果参数太多，考虑查拆分为多个方法; 或者写一个辅助类，保存这些参数; 或者使用builder构造模式。 使用接口类型作为参数类型：增加通用性。 使用枚举代替boolean参数。 谨慎的进行方法重载123456789101112131415161718192021// Broken! - What does this program print?public class CollectionClassifier &#123; public static String classify(Set&lt;?&gt; s) &#123; return &quot;Set&quot;; &#125; public static String classify(List&lt;?&gt; lst) &#123; return &quot;List&quot;; &#125; public static String classify(Collection&lt;?&gt; c) &#123; return &quot;Unknown Collection&quot;; &#125; public static void main(String[] args) &#123; Collection&lt;?&gt;[] collections = &#123; new HashSet&lt;String&gt;(), new ArrayList&lt;BigInteger&gt;(), new HashMap&lt;String, String&gt;().values() &#125;; for (Collection&lt;?&gt; c : collections) System.out.println(classify(c)); &#125;&#125; 灵魂拷问：输出什么? 结果是3次”Unknow Collection”,因为在编译期间所有参数都是c.要调用哪个方法是在编译期间决定的，所以尽管实际参数类型是set,list也还是调用classify(Collection&lt;?&gt;)调用。 重载方法是静态选择的或者说是编译期间选择的，而重写方法的选择是动态的或者说是在运行期间的，选择依据是重写方法在运行时候被调用传入的参数类型。比如如下代码： 1234567891011121314151617class Wine &#123; String name() &#123; return &quot;wine&quot;; &#125;&#125;class SparklingWine extends Wine &#123; @Override String name() &#123; return &quot;sparkling wine&quot;; &#125;&#125;class Champagne extends SparklingWine &#123; @Override String name() &#123; return &quot;champagne&quot;; &#125;&#125;public class Overriding &#123; public static void main(String[] args) &#123; List&lt;Wine&gt; wineList = List.of( new Wine(), new SparklingWine(), new Champagne()); for (Wine wine : wineList) System.out.println(wine.name()); &#125;&#125; 如上代码就会输出我们想要的结果：wine, sparkling wine, champagne 结论：对于具有相同数目参数的方法来说，应该尽量避免重载 谨慎的使用可变参数返回零长度的数组或者空集合而不是返回null返回null值，调用的客户端必须要做null检查，实际上0长度的数组或者集合和null代表了一个意思，都是没有的意思，显然返回0长度的集合或者数组更加合适。 慎用optionalsOptional是java 8提供的一种容器，用来解决npe问题。实际上类似另一种checked exception操作，只是该操作不像抛出异常时需要爬栈(实际自定义异常也可以关闭爬栈)，比较优雅。 容器类型，比如collections, maps, streams, arrays和optioal自身(也可看做一个容器，只能存放至多一个元素)不应该使用optional进行包装。 如果一个方法可能返回null可能返回具体的值，且客户端要对没返回值进行特殊处理，那么因该定义返回Optional&lt;T&gt; 不要使用optional包装一个原始类型的装箱类型，java提供了OptionalInt, OptionalLong,OptionalDouble.3种类来处理这种情况，Boolean, Byte, Character, Short, and Float.这些没有对应的类，所以最好是不用optional进行包装，因为会进行2曾包装，所以最好是直接返回原始类型的值。 不要集合中使用optional,也不要将optinal作为key存入Map.如果这么做了，在检查元素是否在集合中就会很麻烦。得不偿失。 不要将optional作为成员变量使用。 为所有导出的api元素编写注释注释应该简洁的说明方法是做什么的，而不是怎么做；同时文档注释中应该包含该方法调用的前置条件和后置条件 @param: 描述参数，前置条件@return: 返回值@throws: 如果不满足前置条件会抛出什么异常，该描述应该包含一个”如果(if)”,表示异常条件什么时候会抛出@code: 在注释中使用代码时候使用。如{@code int index = 1; index++;}@literal: 如果文档包含html元字符比如&lt;,&gt;可以使用该注释是java doc comment不解释该字符.@link: 链接到别的类或者方法，字段等.@see: 同&#123;@link&#125; 区别是需要单独一行，顶头写，不能混在注释里面。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://dengbojing.com/tags/java/"}],"keywords":[]},{"title":"Effective-java-第七章学习笔记","slug":"Effective-java-第七章学习笔记","date":"2021-08-10T19:02:51.000Z","updated":"2023-01-22T15:37:18.240Z","comments":true,"path":"2021/08/11/Effective-java-第七章学习笔记/","link":"","permalink":"http://dengbojing.com/2021/08/11/Effective-java-%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"第七章：Lambdas 表达式 和 Streams流处理","text":"第七章：Lambdas 表达式 和 Streams流处理 使用Lambads优先于匿名内部类函数式接口： 只拥有一个抽象方法的接口(interface)被称作函数式接口。 函数对象：只具有一个方法的接口的实例，代表一种方法或者具体的执行动作。 Lambad表达式减少了匿名内部类的样板代码，比如: 123456Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; //do sth &#125; &#125;); 使用Lambads代替： 1Thread thread = new Thread(() -&gt; &#123;//do sth&#125;); 当明白了Lambads的语法，会觉得上述写法非常简洁，也非常直观的知道这个线程的作用. 当使用Lambads时，通常省略参数类型，除非参数类型的指定能让程序看起来更加清晰，如果编译器发出警告或者编译错误无法推断参数类型，此时你应该明确的指定参数类型。编译器的类型推断是根据传入参数，或者返回值的泛型类型来确定，所以一定要使用泛型来代替原始类型。 Lambads最好不要超过3行，超过3行可读性就会非常差，超过3行就要进行重构 Lambads没有名称和很好的文档注释，如果表达式不能自我表达，自我描述，或者超过行数限制，都不应该写Lambads Lambads中this指代的是包含表达式的对象，匿名内部类中this代表该匿名内部类的实例。 使用泛型更好的实现枚举的constant-specific方法。 123456789101112public enum Operation &#123; PLUS (&quot;+&quot;, (x, y) -&gt; x + y), MINUS (&quot;-&quot;, (x, y) -&gt; x - y), TIMES (&quot;*&quot;, (x, y) -&gt; x * y), DIVIDE(&quot;/&quot;, (x, y) -&gt; x / y); private final String symbol; private final DoubleBinaryOperator op; Operation(String symbol, DoubleBinaryOperator op) &#123; this.symbol = symbol; this.op = op;&#125; 使用方法引用优先于Lambads如果方法引用不能使代码更加清晰，降低了可读性，那么则应该使用lambad表达式。 优先使用标准的函数式接口 如果有标准的函数式接口可以完成需求，那么就应该优先使用，而不是专门构建一个函数式接口。java 8内置了很多函数式接口在java.util.function包下，优先使用这些函数式接口。如果有以下情况除外： 1.1. 需要一个通用的，具有描述性的名字的函数式接口. 1.2. 拥有很强的约束关系. 1.3. 讲受益于自定义的默认方法. 不要试图使用带有包装类型的基础函数式接口代替原始类型的函数式接口。 函数式接口必须要使用@FunctionalInterface注解。 谨慎的使用&#96;Streams·Stream概念包含一组数据(Steam)和作用于数据上的一个或者多个操作(Stream pipline). Stream pipline分为两种操作：中间操作(intermediate operations) 和 终止操作(terminal operation),中间操作可以有一个或者多个，而终止操作只能有一个，但是只有在调用了有了终止操作，整个Stream pipline才会被触发，如果没有终止操作，那么处理流的代码永远不会被执行。 流的处理默认是串行的，只有当调用流的parallel方法时候流的处理才会被并行处理，但是很少这么做，并行处理需要注意很多地方，且并行处理并不一定都会使处理速度加快。 过度是使用流操作也会是代码难以阅读和维护，比如: 123456789101112131415161718// Overuse of streams - don&#x27;t do this!public class Anagrams &#123; public static void main(String[] args) throws IOException &#123; Path dictionary = Paths.get(args[0]); int minGroupSize = Integer.parseInt(args[1]); try (Stream&lt;String&gt; words = Files.lines(dictionary)) &#123; words.collect( groupingBy(word -&gt; word.chars().sorted() .collect(StringBuilder::new, (sb, c) -&gt; sb.append((char) c), StringBuilder::append).toString())) .values().stream() .filter(group -&gt; group.size() &gt;= minGroupSize) .map(group -&gt; group.size() + &quot;: &quot; + group) .forEach(System.out::println); &#125; &#125;&#125; 这段代码里面的gourpingBy函数的代码读对于没怎么使用过流的人来说读起来非常吃力。建议讲groupingBy单独封装一个方法，单独封装一个方法，可以使用有涵义的方法名和良好的说明注释，这样可以使整个代码可读性和维护性有很大的提升。 由于lambdd表达式没有显示的参数类型，所以参数的名称就非常重要，好的参数名称对于可读性来说是非常重要的，尽量不要使用单个字母来命名，使用单词或者合成单词来命名。 避免使用流来处理char数据，书中举例是因为char字符在输出时会使用对应的int值。 除非有必要重构for循环代码为Stream，否则你应该保持克制，并不是所有的循环改为Stream都拥有很好的可读性和可维护性。复杂的任务进行重构时可能会带来过度使用Stream的问题。从而使代码的可读性和维护性降低。 Stream适用的场景： 对元素进行一些列的变换 过滤元素 合并元素(添加，合并) 元素聚集(合并为一个map,list等) 按条件搜索元素 使用Streams中无额为影响的函数纯函数(pure function): 输出只依赖输入，不依赖其他任何阶段的状态，也不会改变其他任何东西的状态。 forEach函数应该只用作输出Stream最后计算出来的结果，不应该执行具体的计算，偶尔可以用作其他目的，比如添加Stream计算的结果到一个集合中。 应该静态导入Collectors类，提高Stream最终的可读性，永远不要直接使用Collectors.collect(counting())等其他方法(suming,averaging,summarizing,filtering,reducing,mapping,flatmapping等)，这些方法是为了downStream(Collectors许多方法都有downStream参数)设计，应该使用Stream自带的方法 优先使用集合作为返回值问题很简单，因为所有集合都实现了Iterable接口，整个更加通用。 如果返回的数据集特别大，不建议使用现有的集合类，而是自己实现AbstractList. 如实现一个给定集合的全排列： 123456789101112131415161718192021222324//The power set of &#123;a, b, c&#125; is &#123;&#123;&#125;, &#123;a&#125;, &#123;b&#125;, &#123;c&#125;, &#123;a, b&#125;, &#123;a, c&#125;, &#123;b, c&#125;, &#123;a, b, c&#125;&#125;.public class PowerSet &#123; public static final &lt;E&gt; Collection&lt;Set&lt;E&gt;&gt; of(Set&lt;E&gt; s) &#123; List&lt;E&gt; src = new ArrayList&lt;&gt;(s); if (src.size() &gt; 30) throw new IllegalArgumentException(&quot;Set too big &quot; + s); return new AbstractList&lt;Set&lt;E&gt;&gt;() &#123; @Override public int size() &#123; return 1 &lt;&lt; src.size(); // 2 to the power srcSize &#125; @Override public boolean contains(Object o) &#123; return o instanceof Set &amp;&amp; src.containsAll((Set)o); &#125; @Override public Set&lt;E&gt; get(int index) &#123; Set&lt;E&gt; result = new HashSet&lt;&gt;(); for (int i = 0; index != 0; i++, index &gt;&gt;= 1) if ((index &amp; 1) == 1) result.add(src.get(i)); return result; &#125; &#125;; &#125;&#125; Stream并行化的建议如果使用Stream.iterate 和 中间操作limit,并行化流并不会得到性能提升。 在ArrayList, HashMap, HashSet, and ConcurrentHashMap instances; arrays; int ranges; and long ranges上使用并行流会有显著的性能提升。因为这些数据结构统一，可以被精确的分割，有利于并行化。另一重要的因素是这些数据结构有着很好的局部引用，数据引用在内存连续的，虽然这些也引用的数据对象在内存上是不连续的，不利于并行处理的；内存的连续性(局部的引用性)是并行处理的最关键因素，如果没有内存连续性的，线程大部分是空闲的，在等待cpu将内存数据获取到cpu缓存中。最好的内存连续性数据结构就是原始数据类型的数组，他们的分配都是在连续的内存上。 使用并行流不止有可能导致性能降低，还有可能导致结果不正确(使用forEachOrder)和活锁(limit). 只用在适当的情况下，使用并行流才会提升性能，所以建议是不要并行化，除非你有很好的理由非要这么做。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://dengbojing.com/tags/java/"}],"keywords":[]},{"title":"Effective-java-第六章学习笔记","slug":"Effective-java-第六章学习笔记","date":"2021-07-15T02:29:18.000Z","updated":"2023-01-22T15:37:18.235Z","comments":true,"path":"2021/07/15/Effective-java-第六章学习笔记/","link":"","permalink":"http://dengbojing.com/2021/07/15/Effective-java-%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"第六章: 枚举和注解","text":"第六章: 枚举和注解 使用枚举替代int常量在没有枚举之前一致使用int常量或者string常量 123456public static final int APPLE_FUJI = 0;public static final int APPLE_PIPPIN = 1;public static final int APPLE_GRANNY_SMITH = 2;public static final int ORANGE_NAVEL = 0;public static final int ORANGE_TEMPLE = 1;public static final int ORANGE_BLOOD = 2; int常量并不好维护, 而且即使你将常量类型弄混了, 也不会有什么问题, 因为都是int类型, 而且java没有命名空间这个概念, 只能使用前缀作为区分,这种情况下将apple常量和orange常量混合起来计算也不会出现任何编译或者运行时错误, 只会得到错误的结果,同样在进行调试的时候，显示的是一些数字，很难搞清楚数字背后的真正表达的含义。 12public enum Apple &#123; FUJI, PIPPIN, GRANNY_SMITH &#125;public enum Orange &#123; NAVEL, TEMPLE, BLOOD &#125; 如果将这些常量分开使用枚举类型来表示, 那么此时你将Apple和Orange混合使用计算,那么会报错, 因为两者不兼容. 如果一个枚举类型和一个类又紧密的联系,而且不会被外部使用, 那么应该将枚举作为该类的成员内部类使用, 而且尽量降低枚举的可见性, 如果只在包内使用那么可以设为private 或者 package-private constant-specific: 在枚举中定义一个抽象方法，然后在具体的枚举实现常量里面实现该方法。这样做可以使每个枚举常量都可以拥有不同的行为。比如：加，减，乘，除，4个枚举常量对应4中不同的处理数据的行为。 如果重写了toString方法,那么可以写一个fromString方法反向获取枚举123456789101112131415161718192021222324252627282930313233public enum GenderType &#123; /** * 0-男, 1-女 */ MALE(&quot;男&quot;), FEMALE(&quot;女&quot;); /** * 描述性字段 */ private final String value; GenderType(String value) &#123; this.value = value; &#125; public static GenderType instance(int order) &#123; if (order == MALE.ordinal()) &#123; return MALE; &#125; return FEMALE; &#125; private static final Map&lt;String, GenderType&gt; STRING_TO_ENUM = Stream.of(values()).collect(Collectors.toMap(Object::toString, e -&gt; e)); public static Optional&lt;GenderType&gt; fromString(String value)&#123; return Optional.ofNullable(STRING_TO_ENUM.get(value)); &#125; @Override public String toString()&#123; return this.value; &#125;&#125; 使用实例字段代替ordinals在枚举里面ordinals代表了每个枚举的顺序, 如果增加了或减少了枚举, 这个ordinal就发生了变化, 而这种变化是我们无法控制的, 所以应该用一个字段来代替他. 使用EnumSet和EnumMap太高深了,完全不懂,重读第三遍在重新理解. 用接口扩展枚举枚举是不可继承的,因为,枚举实际上就是一个class编译过后的枚举是集成于Enum类的,而且是final的,final类是无法集成的, 为什么要设置成final呢, 很好理解, 所有枚举都是extends Enum 如果你还要在继承自己的BasEnum 就会出现childEnum extends BaseEnum, Enum这种多继承, 而java是禁止多继承的. 不过枚举是可以实现接口的,所以如果又扩展需要,可以实现接口 123456789101112131415161718192021222324public interface Operation &#123; double apply(double x, double y);&#125;public enum BasicOperation implements Operation &#123; PLUS(&quot;+&quot;) &#123; public double apply(double x, double y) &#123; return x + y; &#125; &#125;, MINUS(&quot;-&quot;) &#123; public double apply(double x, double y) &#123; return x - y; &#125; &#125;, TIMES(&quot;*&quot;) &#123; public double apply(double x, double y) &#123; return x * y; &#125; &#125;, DIVIDE(&quot;/&quot;) &#123; public double apply(double x, double y) &#123; return x / y; &#125; &#125;; private final String symbol; BasicOperation(String symbol) &#123; this.symbol = symbol; &#125; @Override public String toString() &#123; return symbol; &#125;&#125; 使用注解代替命名模式命名模式: 就是约定(方法名,字段名,类名等)命名的格式或者规范, 这种方式有很大的弊端，拿junit3来举例: 容易拼写错误test拼写为tset 你无法确定使用的是否合适或者说使用的是否准确，比如一个类名叫做TestSafeMechanisms, 本意是想测试该类下面所有的方法，但是junit3并不会这么做。 没法很好的把参数和程序元素关联起来，比如想写一个测试类，在抛出特定的异常时候才算成功，这时候异常的本质是测试的参数。这时候可以利用具体的命名模式，把异常名字写在方法名中，首先这很不优雅，其次就算你写错了，编译器也检查不出来。 使用注解可以解决上述的弊端，而且从junit4开始也使用@Test来代替命名模式。具体的使用可以搜索元注解，annotationsprocessor等关键信息。总之，使用注解代替原来的命名模式；应该使用java预定义的注解@Override等注解。 标记接口 vs 标记注解 标记接口定义了一个由标记类的实例实现的类型，这句话有点绕，实际上就是标记接口定义了一种类型。在实际运用过程中，如果一个方法要求的参数是一种标记接口，那么编译器可以检查传入的实际参数是否符合要求，而标记注解(上面所说的@Test)则不能让编译器进行类型检查。 标记接口能更精确的标记，比如只想标记某些特定的接口，就可以创建一个标记接口继承这个特定的接口来进行标记。比如·Set之于Collection，可以把Set看成一个标记接口，Collection是一个特定的接口，Set并没有增加任何方法，可以看作只是一个标记接口。 标记注解更好的地方在于可以应用于大型的框架之内，可以作为框架的元注解构成更高级的注解比如@SpringBootApplication就是基于·@EnableAutoConfiguration&#96;等注解，这种方式可以实现更加丰富的框架。 如果是标记方法参数，成员变量等应当使用标记注解；因为标记接口只能又类和接口来扩展；如果需要标记一个类或者接口，那么分情况，如果该接口是一个或多个方法的参数，则应该使用标记接口。如果这个类不会被用做参数，那么应该使用标记注解。或者如果被标记的类是重度使用注解的框架，那么也应该使用注解。 如果标记注解是Element.TYPE类型（可以用在任何地方），那么应该花时间思考是否真的应该是一个标记注解，或者可以使用标记接口会更好。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://dengbojing.com/tags/java/"}],"keywords":[]},{"title":"Effective-java-第五章学习笔记","slug":"Effective-java-第五章学习笔记","date":"2021-07-08T06:52:12.000Z","updated":"2023-01-22T15:37:18.230Z","comments":true,"path":"2021/07/08/Effective-java-第五章学习笔记/","link":"","permalink":"http://dengbojing.com/2021/07/08/Effective-java-%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"第五章: 泛型使用注意事项","text":"第五章: 泛型使用注意事项 泛型术语 名称 写法 翻译 Parameterized type List 参数化类型 Actual type parameter String 实际类型参数 Generic type List 泛型 Formal type parameter E 形式类型参数 Unbounded wildcard type List&lt;?&gt; 无界通配符类型 Raw type List 原始类型 Bounded type parameter &lt;E extends Number&gt; 有界类型参数 Recursive type bound &lt;T extends Comparable&lt;T&gt;&gt; 递归类型限制 Bounded wildcard type List&lt;? extends Number&gt; 有界通配符类型 Generic method static static &lt;E&gt; List&lt;E&gt; asList(E[] a) 泛型方法 Type token String.class 类型标记 不要使用原始类型为什么不该使用每一个泛型类型定义都对应着原始类型,通俗来说就是不带泛型. 如: 12Collections stamps = ...; 如果使用这种集合,你可以添加任何类型的对象,看名字其实只是想添加Stamp类的实例,他是不报错的.ide 工具会给出警告. 123stamps.add(new Stamp()); //unchecked call add(e)stamps.add(new String()); // unchecked call add(E)stamps.add(new Integer(1)); // unchecked call add(E) 在遍历取出的时候,编译期间还是不会报错,只有运行时候才会抛出异常. 123for (Iterator i = stamps.iterator(); i.hasNext(); ) Stamp stamp = (Stamp) i.next(); // Throws ClassCastException stamp.cancel(); 编译期间发现不了问题就很可怕,如果这段代码一直没有执行,那么系统一直没有问题,知道有一天它执行了,boom!这段代码就是个定时炸弹,所以千万不要用泛型的原始类型.而且就修复来说,这种情况就很麻烦, 修复,重新编译, 测试, 发布. 替代原始类型的方式如果你想一个容器添加任意类型的参数,那么可以使用List&lt;Object&gt;这种形式,这种形式处于泛型系统之内,只是显示的告诉了编译器,我何以接受任何类型的参数.如果你使用原始类型的那么你将失类型安全,但是如果使用List&lt;Object&gt;并不会有这个问题. 123456List&lt;String&gt; strings = new ArrayList&lt;&gt;();unsafeAdd(Strings, Integer.valueOf(3));public void unsafeAdd(List list, Object obj)&#123; list.add(obj); // warning unchecked call to add()&#125; 如上代码,编译器并不会报错,只会给出警告,如果你不在意这些警告,那么,运行时就会报错.但是如果我们换成以下代码: 12345List&lt;String&gt; strings = new ArrayList&lt;&gt;();unsafeAdd(strings, Integer.valueOf(2)): //compiler errorpublic void unsafeAdd(List&lt;Object&gt; list, Object obj)&#123; list.add(obj):&#125; 这段代码会在编译期间就报错,有助于你提前发现问题,修复问题. 无界通配符 &lt;?&gt;如果你在写一个对外的api但是返回值不确定,可能是String,可能是自定义类型,这取决与需求是什么样的,那么这个时候该怎么写呢: 12345678public Response&lt;?&gt; api(String str)&#123; return Response.success(someService.doSth(str));&#125;public Response&lt;T&gt;&#123; public static &lt;T&gt; Response&lt;T&gt; success(@NotNull T t) &#123; return of(t, ResponseState.SUCCESS); &#125;&#125; 无界通配符不能用来的容器不能用来添加东西,null值例外,如: 12345public void toAdd(List&lt;?&gt; list)&#123; list.add(null); list.add(&quot;fda&quot;); //complier error&#125; 这个是编译器为了阻止改变参数的类型, 假设调用此方法传进来的参数是List&lt;Integer&gt;, 那么添加String 类型就会抛出异常, 所以编译器提前阻止了这种类型的改变. 只能使用原始类型的特殊情况 代表class字面量, 比如List.class 使用instanceof 消除unchecked警告手动消除警告使用@SuppressWarnings(&quot;unchecked&quot;) 消除警告.注意一下几点: 尽可能的缩小注解的作用范围. 需要在注解上注释描述为什么这么做 优先使用泛型集合,而不使用数组数组是协变的, 而泛型集合是不变的如果一个sub 是 sup的子类, 那么sub[] 也是 sup[]的子类型. 是兼容的.但是,List&lt;sub&gt;却不是List&lt;sup&gt;的子类行,两者是不兼容的. 1234567// Fails at runtime!Object[] objectArray = new Long[1];objectArray[0] = &quot;I don&#x27;t fit in&quot;; // Throws ArrayStoreException// Won&#x27;t compile!List&lt;Object&gt; ol = new ArrayList&lt;Long&gt;(); // Incompatible typesol.add(&quot;I don&#x27;t fit in&quot;); 以上代码可以看出第一段代码得等到运行时才会发现问题,如果代码得不到执行,那么程序就一直是正常运行,定时炸弹.而第二段代码在编译期间就指出了错误. 为什么不能显示的创建泛型数组数组是具体化的,数组不论是在编译期间还是运行期间都会强制要求数组中的元素类型一致.而泛型在编译期间强制要求元素类型,但是在运行期间会进行泛型擦除.这么做的目的是为了兼容 jdk5 之前的代码. 基于以上两点就很好解释为什么不能创建泛型数组了. 12345List&lt;String&gt;[] stringLists = new List&lt;String&gt;[1]; // (1)List&lt;Integer&gt; intList = List.of(42); // (2)Object[] objects = stringLists; // (3)objects[0] = intList; // (4)String s = stringLists[0].get(0); // (5) 如上代码, 假设(1)是可以编译通过, (3)由于数组的协变是正确的语法,因为所有类都是Object的子类, (4) 由于泛型的擦除在运行期间ListMString&gt;[] 被擦除为List[], List&lt;Integer&gt; 被擦除为List 因此不管编译还是运行都不会出错, (5)在运行期间会出现ClassCastException ,因为存进去的显然不是String; 因此在编译期间就阻止(1)编译通过.如上所说List&lt;E&gt;, List&lt;String&gt;, E这些参数化类型,被称为不可具体化的类型,因为他们在运行期间会被泛型擦除,无法表达容器在运行时所需要的元素类型. 只有一种情况例外就是&lt;?&gt;无界通配符: 1List&lt;?&gt;[] list = new ArrayList&lt;?&gt;[1]; 这种是可以编译通过的, 但是问题来了, 无界通配符容器是不允许被改变的, 这么做毫无意义. 使用 List 代替 泛型数组定义 E[]简单来讲就是你无法创建一个泛型数组, 但是可以通过Collection.toArray()获得一个泛型数组: 1E[] e = (E[]) someCollection.toArray(); //unchecked cast 这样我们就获得另一个泛型数组, 但是需要强转, 且这句话会出现警告, 因为在运行期间会出现泛型擦除, 所以编译器无法保证运行时类型转换正确, 所以会出现unchecked cast. 因此,我们需要稍微修改一下: 1List&lt;E&gt; lists = new ArrayList&lt;&gt;(someCollection); 虽然丧失了一些性能, 但是编译器能保证正确的类型转换. 偏好使用泛型通俗来说就是,如果你在写一个容器类, 里面所需要容纳的元素类型,最好使用泛型来代替. 书中举例: 1234567891011121314151617181920212223242526public class Stack &#123; private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() &#123; elements = new Object[DEFAULT_INITIAL_CAPACITY]; &#125; public void push(Object e) &#123; ensureCapacity(); elements[size++] = e; &#125; public Object pop() &#123; if (size == 0) throw new EmptyStackException(); Object result = elements[--size]; elements[size] = null; // Eliminate obsolete reference return result; &#125; public boolean isEmpty() &#123; return size == 0; &#125; private void ensureCapacity() &#123; if (elements.length == size) elements = Arrays.copyOf(elements, 2 * size + 1); &#125;&#125; 应该替换为: 1234567891011121314151617181920212223242526class Stack&lt;E&gt; &#123; private E[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() &#123; elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY]; &#125; public void push(E e) &#123; ensureCapacity(); elements[size++] = e; &#125; public Object pop() throws EmptyStackException &#123; if (size == 0) throw new EmptyStackException(); E result = elements[--size]; elements[size] = null; // Eliminate obsolete reference return result; &#125; public boolean isEmpty() &#123; return size == 0; &#125; private void ensureCapacity() &#123; if (elements.length == size) elements = Arrays.copyOf(elements, 2 * size + 1); &#125;&#125; 这条看上去是和上面一条有些冲突,上面一条说明优先使用泛型集合,而这里又使用泛型数组了;因为,这里实现的是Stack容器类,类似List容器类,所以使用泛型数组,而且List容器类的实现也是泛型数组实现. 偏好使用泛型方法简单来说,就是任何容器实例,都应该使用泛型化来使用, 比如: 12345...public static add(set o, set o2)&#123; o.addALL(o2);&#125;... 应该改为: 12345...public static &lt;E&gt; void add(Set&lt;E&gt; o, Set&lt;E&gt; o2)&#123; o.addAll(o2)&#125;... 在方法修饰符和返回值之间的&lt;E&gt;,被称为类型参数列表. 泛型单例工厂返回一个函数式对象可以包含不同的参数化类型,例如: Collections.reverseOrder()和Collections.emptySet(). 下面是书中给的恒等函数示例: 123456// Generic singleton factory patternprivate static UnaryOperator&lt;Object&gt; IDENTITY_FN = (t) -&gt; t;@SuppressWarnings(&quot;unchecked&quot;)public static &lt;T&gt; UnaryOperator&lt;T&gt; identityFunction() &#123; return (UnaryOperator&lt;T&gt;) IDENTITY_FN;&#125; 递归类型界限&lt;E extends Comparable&lt;E&gt;&gt;: 类型参数(E)被涉及到类型参数本身的表达式(&lt;Comparable&lt;E&gt;&gt;)限制.这种用法很少用到,一般是用在有些自我表达,自我操作的方法. 比如: 一个集合里面的排序, 最大值,最小值.(自我比较) 使用界限通配符增减API的灵活性为了使方法拥有最大的灵活性,可以在表示消费或者生产的方法的参数上使用通配符类型来代表 上界通配符 &lt;? extends E&gt; 下界通配符 &lt;? super E&gt; PECS – producers-extends and consumers-super. 代表生产时使用extends, 代表消费时使用super 12345678public static &lt;E&gt; void add1(List&lt;? super E&gt; list, E e)&#123; list.add(e);&#125;public static &lt;E&gt; E get(List&lt;? extends E&gt; list)&#123; return list.get(0);&#125; 如果在方法定义的时候类型参数只出现一次,那么应该使用通配符来代替(有界或者无界) 不要在返回值上使用通配符, 这将会迫使客户端也使用通配符. 如果一个用户使用这个方法要考虑通配符类型,那么这个api可是是错的,好的api应该是让用户感觉不到通配符的存在 谨慎的将可变参数和泛型结合在一起将值存进可变泛型数组是不安全的在’为什么不能显示的创建泛型数组’中已经演示过,泛型数组的危害,这里稍微改变一下上述代码: 123456static void dangerous(List&lt;String&gt;... stringLists) &#123; List&lt;Integer&gt; intList = List.of(42); Object[] objects = stringLists; objects[0] = intList; // Heap pollution String s = stringLists[0].get(0); // ClassCastException&#125; 这里其实就是将之前的代码中显示的创建泛型数组,改为可变参数泛型数组. 因为可变参数实际上编译完成之后,是将可变参数存进一个临时数组里面,所以上述代码实际上就等于隐式的创建了一个可变参数泛型数组,但是最终导致类型装换错误,原因之前已经分析过了. 结论1: 将值存入泛型数组是不安全的,泛型数组应该只是传递这些值,比如: Arrays.asList(T…t), 该方法只是将可变参数里面的值放到List里面然后返回该List结论2: 返回泛型数组引用也是不安全的, 比如下列代码: 123456789101112131415// UNSAFE - Exposes a reference to its generic parameter array!static &lt;T&gt; T[] toArray(T... args) &#123; return args;&#125;static &lt;T&gt; T[] pickTwo(T a, T b, T c) &#123; switch(ThreadLocalRandom.current().nextInt(3)) &#123; case 0: return toArray(a, b); case 1: return toArray(a, c); case 2: return toArray(b, c); &#125; throw new AssertionError(); // Can&#x27;t get here&#125;public static void main(String[] args) &#123; String[] attributes = pickTwo(&quot;Good&quot;, &quot;Fast&quot;, &quot;Cheap&quot;);&#125; toArray方法直接诶返回了泛型数组, 而main方法调用pickTwo方法编译器会推断出该方法返回string[]数组,所以在return toArray(x,x)处会出现一个隐式的转换转换为Object[]数组. 显然string[]数组不是object[]数组的超类. 所以出现ClassCastException, 由此可以看出返回一个泛型数组的引用是多么的不安全, 除非是受到控制的方法, 即不对外暴露的方法, 由api方法编写者确认这个使用是安全的, 并且使用@SafaVarargs注解. 类型安全的异构容器一个很有意思的写法: 123456789public class Favorites &#123; private Map&lt;Class&lt;?&gt;, Object&gt; favorites = new HashMap&lt;&gt;(); public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance) &#123; favorites.put(Objects.requireNonNull(type), instance); &#125; public &lt;T&gt; T getFavorite(Class&lt;T&gt; type) &#123; return type.cast(favorites.get(type)); &#125;&#125; 可以存入任意类型的Class(不能是原始类型), 然后获取对应的值.","categories":[],"tags":[{"name":"java,读书笔记","slug":"java-读书笔记","permalink":"http://dengbojing.com/tags/java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"keywords":[]},{"title":"学习笔记","slug":"学习笔记","date":"2021-06-25T07:18:05.000Z","updated":"2023-04-16T12:06:21.740Z","comments":true,"path":"2021/06/25/学习笔记/","link":"","permalink":"http://dengbojing.com/2021/06/25/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"GraalVM 尝试","text":"GraalVM 尝试 开始GraalVM 是一个更快的JAVA虚拟机,而且可以构建native image这个词的意思是,如果是windows系统就能构建一个exe执行程序,其他系统就对应其他系统的执行程序,quarkus通俗的来说,是基于该虚拟机的一个java web开放框架, 实现了标准的JAX-RS规范,并且顶层并没有采用传统的servlet, 而是使用了vert.x 这种react框架, 可以很好的实现react功能. 准备 下载GraalVM, 根据自己系统弄个需要下载. 配置PATH , JAVA_HOME等环境变量, 指向GraalVM所在的目录. 通过Quarksu网站配置一个项目或者使用mvn命令行创建项目, mvn io.quarkus:quarkus-maven-plugin:2.0.0.CR2:create &quot;-DprojectGroupId=com.sa&quot; &quot;-DprojectArtifactId=sa&quot; &quot;-DclassName=com.sa.GreetingResource&quot; &quot;-Dpath=/hello&quot;. 开发默认Qarkus是使用maven作为项目管理的.下载好项目,通过vscode 或者 idea打开,vscode会提示安装插件, 按照提示安装插件,idea自己搜索quarkus插件.运行, mvn:dev, 不到1s就启动好了, 可以访问默认的/helloquarkus 的maven插件提供了安装第三方jar的命令mvn quarkus:list-extensions 查看所有可以安装的第三方jarmvn quarkus:add-extension -Dextensions=&#39;quarkus-jsonp&#39; 安装第三方jar 或者mvn quarksu:add-extensions -Dextensions=&#39;xxx,xxx,x 批量安装第三方jar包,也可以使用通配符*安装. 运行mvn quarkus:dev 打包普通jar包: mvn packageexe本地可执行文件: 安装MSVC 2019 对应你的GraalVM版本应该是openjdk11版本, 安装windows sdk 安装Microsoft visual studio –和上一步合并安装命令choco install visualstudio2019-workload-vctools , 前提是电脑得有chocolatey这个windows包管理工具. 进入项目执行以下命令: call &quot;C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\BuildTools\\VC\\Auxiliary\\Build\\vcvars64.bat&quot; mvnw package -Pnative -DskipTests 碰见的问题由于电脑是洋垃圾cpu,所以cpu架构被识别为??而非arm的, 所以得在application.properties中添加quarkus.native.additional-build-args=-H:-CheckToolchain参数跳过检查. 结尾总的来说GraaalVM的速度还是很快的, Quarkus也带来了新的web开发体验, 上手难度比较小,只要你懂JAX-RS规范就行,而且还很好的和docker进行了集成,可以直接配置hibernate entity 而不进行任何数据库配置, quarkus在背后会自动寻找docker为你创建数据库,让开发人员专注与开发. 但是关于graalVM编译本地可执行文件来说,感觉有点鸡肋,虽然实现了,但是还是需要visual studio 这种庞大的工具.","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://dengbojing.com/tags/java/"},{"name":"quarkus","slug":"quarkus","permalink":"http://dengbojing.com/tags/quarkus/"},{"name":"graalvm","slug":"graalvm","permalink":"http://dengbojing.com/tags/graalvm/"}],"keywords":[]},{"title":"bug总结","slug":"bug总结","date":"2021-05-15T11:00:27.000Z","updated":"2023-01-22T15:37:18.225Z","comments":true,"path":"2021/05/15/bug总结/","link":"","permalink":"http://dengbojing.com/2021/05/15/bug%E6%80%BB%E7%BB%93/","excerpt":"日常开发中遇到的bug总结.","text":"日常开发中遇到的bug总结. 2021年5月0x01现象: JPA 中双向关联如果使用mappedBy会使foreignKey = @ForeignKey(ConstraintMode.NO_CONSTRAINT)失效, 如果不使用mappedBy 则会生层一张中间表.版本: hiernate 5.x临时解决方案: 使用已被废弃的注解@org.hiernate.annotations.ForeignKey注解使外键失效. 自行去除外键,并且jpa.hibernate.dll-auto设置为none. 去除mappedBy, 接受中间表. stackoverflow 地址: https://stackoverflow.com/questions/41729709/how-do-i-disable-hibernate-foreign-key-constraint-on-a-bidirectional-association 0x02现象: zipInputstream 或者 zip4j 无法解压7zip软件打包的的压缩包版本: 2.4.2解决方案: 无.issue: https://github.com/srikanth-lingala/zip4j/issues/45 0x03现象: junrar 无法解压rar5版本的压缩包,也就是新版本的winrar打包的压缩包是无法解压的版本: 2.4.2解决方案: 无issue: https://github.com/junrar/junrar/issues/23 0x04现象: 文件上传时,使用@RequestParam, swagger2无法生成对应的文件参数文档.版本: swagger2 3.x解决方法: 使用@RequsetPart 注解multipart参数 0x05现象: Spring data JPA 不支持hibernate中的@FetchMode,无法通过该注解直接实现join查询来避免N+1问题 版本: 2.4.2 解决方案: 使用@EntityGraph解决该问题,可以无限向下关联;或者使用原生sql查询;spring data jpa自带的一些方法无法做到多级join&#96;,即使使用的该注解,这个问题很奇怪.stackoverflow: https://stackoverflow.com/questions/30479748/jpa-how-to-define-namedentitygraph-for-3-levels 0x06现象: Hibernate或者jpa 实现多个实体类join, 如果是hibernate 则在使用@FetchMode.JOIN时候属性列指定为List会报错, 如果是 spring data jpa 多个属性列为List 则不能同时使用FetchType.EAGRE版本: 2.4.2解决方案: 使用Set作为属性的类型stackoverflow: https://stackoverflow.com/questions/4334970/hibernate-throws-multiplebagfetchexception-cannot-simultaneously-fetch-multipl 2021年6月0x01现象: JPA 对于非主键关联支持报错, Tester单向关联了Project类的c_project_number, 123456789@Column(name = &quot;c_tester_name&quot;, columnDefinition = &quot;VARCHAR(20) NOT NULL COMMENT &#x27;测试者姓名&#x27;&quot;)private String name;@Column(name = &quot;c_tester_phoneNum&quot;, columnDefinition = &quot;VARCHAR(20) NOT NULL COMMENT &#x27;测试者联系电话&#x27;&quot;)private String phoneNum;@ManyToOne@JoinColumn(name = &quot;c_project_num&quot;, referencedColumnName = &quot;c_project_number&quot;, nullable = false , foreignKey = @ForeignKey(ConstraintMode.NO_CONSTRAINT))private Project project; 在根据项目编号和电话号码查询Tester对向时,如果不存在Tester对象,无任何问题,存在Tester对象则报错,报错如下: com.xxx.entity.Project is in unnamed module of loader &#39;app&#39;; java.io.Serializable is in module java.base of loader &#39;bootstrap&#39; ,版本: 2.4.2解决方案: 初步判断为查找出Tester对象时,关联出Project对象, 此时被app这个classLoader加载, 导致问题,具体深层次原因未深究, 此处临时解决办法是不使用c_project_number字段关联, 使用Project类的主键进行关联.stackoverflow: ttps:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;61862202&#x2F;using-jpa-elementcollection-for-a-string-collection-from-a-join-table 2022年6月0x01现象JPA非主键关联，如果上级实体类和下级实体类同时包含另一个实体类，如下: Patient和Recheck都包含Department对象，同时Recheck又包含Patient对象， 1234Patient: @ManyToOne @JoinColumn(name = &quot;c_department_code&quot;, referencedColumnName = &quot;c_code&quot; ,nullable = false, foreignKey = @ForeignKey(ConstraintMode.NO_CONSTRAINT), columnDefinition = &quot;VARCHAR(20) COMMENT &#x27;部门code, 关联t_department表&#x27;&quot;) private Department department; 12345678910Recheck: @ManyToOne @JoinColumn(name = &quot;c_patient_id&quot;, columnDefinition = &quot;int comment &#x27;病患id&#x27;&quot;, foreignKey = @ForeignKey(ConstraintMode.NO_CONSTRAINT)) private Patient patient; @ManyToOne @JoinColumn(name = &quot;c_department_code&quot;, referencedColumnName = &quot;c_code&quot; ,nullable = false, foreignKey = @ForeignKey(ConstraintMode.NO_CONSTRAINT), columnDefinition = &quot;VARCHAR(20) COMMENT &#x27;部门code, 关联t_department表&#x27;&quot;) private Department department; 此时查询Recheck集合会出现多出查询问题，会单独出现一条语句，查询Recheck里面的Department对象，如果List&lt;Rechck&gt;都是同一个部门那么，只会查询一次Deparment对象，如果对应多个部门，则会查询多个部门.如果Department使用主键关联则不会出现这种问题.怀疑和非主键关联无法lazy加载有关，但是又不像.版本：spring-data-jpa 2.6.0, hibernate-core 5.6.3解决方案：EntityGraph去除patient查询，或者使用主键关联stackoverflow: https://stackoverflow.com/questions/30082281/manytoonefetch-fetchtype-lazy-doesnt-work-on-non-primary-key-referenced-co","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://dengbojing.com/tags/java/"},{"name":"bug","slug":"bug","permalink":"http://dengbojing.com/tags/bug/"}],"keywords":[]},{"title":"Effective-java-第四章学习笔记","slug":"Effective-java-第四章学习笔记","date":"2021-04-07T06:25:59.000Z","updated":"2021-05-12T12:34:01.210Z","comments":true,"path":"2021/04/07/Effective-java-第四章学习笔记/","link":"","permalink":"http://dengbojing.com/2021/04/07/Effective-java-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"第四章: 类和接口","text":"第四章: 类和接口 引言这章主要讲了类和接口的设计原则,如何设计除更健壮,更灵活的类和接口. 正文使类和成员的访问最小化以及在公有类中使用访问方法而非公有域前面两条实质上讲的是一件事,就是不要暴露类的内部成员,如果是公有类(一般情况我们写的都是public的类)一定不能暴露内部的成员,而是使用getter和setter.尽可能的降低内部成员的可访问性. 这么做的好处就是封装性比较强, 也灵活很多,如果将来想在类的成员上做限制,直接在getter或者setter上做改变就可以, 外部调用者完全感受不到变化. 如果编写一个不可变的类 不要提供任何会修改对象状态的方法–比如setter 保证类不会被扩展–使用final修饰符或者private的构造器. 将所有的域(类的成员)都设置成private final的. 确保任何可变组件的互斥访问–就是如果类的成员是一个对象引用, 则保证这个引用不会被外部获取到. functional: 不改变当前实例, 而是创建一个返回一个新的实例的方法. 这种方法被称为functional. 这种方法的方法名都使用介词. 不可变对象的优点: 不可变对象是线程安全的, 不要求同步. 不可变对象可以自由的共享, 甚至可以共享他们的内部信息. 不可变对象可以为其他对象提供构件. 不可变对象提供了原子性. 不可变对象的缺点每一个不同的值都需要一个对象, 如果创建不可变对象代价太高, 那么可能会导致程序性能下降. 一般不可变对象都提供一个对应的可变的配套类,比如String和StringBuilder. 组合(复合)优于继承 继承打破了封装性.子类依赖父类其中特定的功能细节,如果将来父类改变了,那么子类也会跟着发生相应的变化,往往这些变化不是子类自己能控制的. 除非父类是专门用来被继承的或者有很好的说明该如何继承该类, 否则最好使用组合. 如果A和B两者直接存在is-a的关系才应该使用继承, 在实现继承时候, 要反复的确定 B 在任何时候都是一个 A 类型. 如果不是, B 仅仅是使用了 A 的一个功能, 那么就应该使用组合模式. 要么设计继承并提供文档, 要么禁止继承这条其实是对于上面那条的补充说明, 上一条说如果继承了一个不是用来被继承的类,是一件很危险的事情, 可能导致封装性被破坏, 在设计一个被继承的类时, 要有良好的说明 该类必须有说明可以被重写的方法的自用性–即类必须在文档中说明,在哪些情况下它会调用被重写的方法. 对于为了继承而设计的类, 必须在发布之前先编写子类对其进行测试. 构造器不可以调用可以被重写的方法. clone和readObject 方法也不能调用可以被重写方法. 接口优于抽象类如果是对实现类的规范和约束则应该使用抽象类, 如果想实现多继承则应该使用接口. 接口的可扩展性要优于继承. 接口的使用 为后代设计接口. 接口只用于定义类型. 不要使用常量接口. 写在最后整章对于在写代码设计类的层次接口非常有用, 但是由于使用spring框架, 很多事情spring都帮你做了, 这些设计原则用到的机会不是非常多, 导致里面有很多东西看了似懂非懂, 所以以后还是要离开spring框架单独做一些非web项目, 这样才能有较深的感悟.","categories":[],"tags":[{"name":"java, 读书笔记","slug":"java-读书笔记","permalink":"http://dengbojing.com/tags/java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"keywords":[]},{"title":"Effective-java-第三章学习笔记","slug":"Effective-java-第三章学习笔记","date":"2021-03-08T12:01:55.000Z","updated":"2021-04-07T06:23:27.627Z","comments":true,"path":"2021/03/08/Effective-java-第三章学习笔记/","link":"","permalink":"http://dengbojing.com/2021/03/08/Effective-java-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"第三章: 重写Object类中的几个方法","text":"第三章: 重写Object类中的几个方法 引言这一章主要讲的是Object类中的几个方法该如何重写.实际上本章内容没有在开发实践中并不会出现,一般开发人员都用lombok或者其他工具类实现了Object中的方法,很少遇到自己重写的情况,而且在正常逻辑上也不会违背文中所说的注意点. 正文重写equals方法在一下3种情况不应该重写equals 该类不是一个值类,是代表活动实体的类,比如Thread. 该类没必要提供逻辑相等,比如单例类,只会产生一个实例,Object类提供的地址相等的equals方法已经足够;再比如一些工具类xxxUtil,xxxxBuilder等,实际上这些类有时候无法实例化,所以没必要重写equals方法 该类是私有的或者包级私有的,可以确保equals方法不会被调用.(这句才是重点) 重写equals时遵循的规范 自反性(reflexive): 对于任何非null的引用值x, x.equals(x)必须返回true. 对称性(symmetric): 对于任何非null的引用值x和y, 当且仅当y.equals(x)返回true, x.equals(y)必须返回true. 传递性(transitive): 对于任何非null的引用值x,y,z, 如果x.equals(y)返回true,y.equals(z)返回true, 那么x.equalis(z)也返回true 一致性(consistent): 对于任何非null的引用值x,y,只要对象中的信息没有被修改过,那么多次调用x.equals(y)的结果必然一致. 任何对象equals(null)必然返回false. 以上规范,看起来挺复杂,实际上属于一种自然而然的做法,在重写equals的时候,很自然的就做到了.最好的方法就是使用第三方库来重写equals省事,还不会出错,除非你有非常特别的理由要自己手动重写. 重写equals时注意事项 不要依赖不可靠资源,比如java.net.URL中主机ip地址的比较,可能会存在host不变但是ip变了. 优先比较最有可能不一致的字段,或者开销比较低的字段,最理想是二者兼备,有这些字段组成关键字段. 重写equals时总是重写hashCode方法. 不要让equals过于智能. 重写equals方法的步骤 使用==操作符检查对象引用是否相等. 如果是,那么是同一个对象,直接返回true. 使用instanceOf检查参数类型是否正确. 类型转换.(如果是jdk 14以上可以和上一步合并: if(o instanceof X x){}) 对该类型中的关键字段进行比较.如果是除浮点数之外的基本类型,直接用==判断,如果是对象递归使用equals,如果是浮点数(float,double)使用Float.compare(param1,param2), Double.compare(param1,param2),原因是float和double中存在Float.NaN,-0.0f 这样的常量. 总结: 总之不要轻易的自己重写equals方法,在多数情况下并不需要,如果需要请使用第三方,如果还不满足在自己动手写. 重写equals方法时重写hasCode方法特点 如果两个对象equals, 那么他们必然具有相同的hashCode. 为什么?因为在使用hashMap等集合时, 如果相等的对象具有不同的hashCode,可能会放在不同的bucket中,这样导致get逻辑上相等的对象时, 会出现获取不到对象.2. 如果两个对象不equals, 但是他们可能具有相同的hashCode, 但是最好不要, 因为这样HashMap等依赖hashCode方法的集合类会变的性能非常低下,最好是不同的对象具有不同的hashCode 重写步骤 定义一个result存储第一个关键字段的hashCode. 关键字段的hashCode的计算: a. 若果字段是基本类型,则调用对应的包装类型的hashCode(value)方法,如: Integer.hashCode(code). b. 如果字段是对象引用,并且equals中使用到这个字段时, 则同样的递归的调用该字段的hashCode方法. 如果需要更复杂的比较, 则可以为这个字段计算一个范式,然后针对这个范式计算hashCode. 如果该字段是null则返回0 c. 如果字段是一个数组,则逐个计算数组中的元素的hashCode,如果数组不重要,返回一个常量,但最好不是0. 根据前两步骤计算,合并除最后的hashCode 完整示例: 123456public int hashCode() &#123; int result = Short.hashCode(param); result = 31 * result + Integer.hashCode(param1); result = 31 * result + Double.hashCode(param2); return result;&#125; 使用乘法使得hashCode依赖字段顺序,设想一下如果不用乘法那么abc和bac将会拥有相同的hashCode,这显然是不对的.使用31这个数字书中给出的原因是: 因为它是一个奇素数,习惯上使用,可以使用移位和减法来优化乘法31 * i == (i &lt;&lt; 5) - i,而且虚拟机自动完成这一优化;如果想知道更多具体内容请参考stackoverflow上的回答 重写toString方法该条主要作用是在日志或者输出对象时候,比较容易的读懂对象中的信息,书上说的有点啰嗦,最简单的方法是使用三方json库将对象直接按json输出.不建议自己手写,字段多了容易遗漏外加出错. 重写clone方法通用约定(非必须) x.clone() != x; x.clone().getClass() == x.getClass(); x.clone().equals(x); 实现步骤 调用super.clone(), 然后转换类型. 如果该类包含数组引用类型的字段, 并且是非final的, 那么调用该字段的clone()方法. 如果该类包含引用类型中的字段还包含其他引用类型,那么递归调用,进行深拷贝. 使用构造拷贝器–一个接收自身类型为参数的构造函数. 或者使用构造器静态工厂方法. 总结: 实际生产过程中, 很少遇到需要调用clone方法来获取对象. 考虑实现comparable接口如果是在编写一个值类(value class)并且可能排序敏感,那么建议你实现comparable接口,这样当这个类的实例添加到集合里面的时候,便于搜索,分类,排序. 通用约定 sgn(x.compareTo(y)) == -sgn(y.compareTo(x)),其中sgn为signum函数,根据表达式的值,返回-1,0或者1. 如果x.compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0 则 x.compareTo(z) &gt; 0. 如果x.compareTo(y) == 9 那么有x.compareTo(z) == y.compareTo(z). 如果x.compareTo(y) == 0 那么他们最好是相等, 如果不等请注明. 实现实现该方法时,最好不要使用&lt;, &gt;符号. 1234567891011public int compareTo(PhoneNumber pn)&#123; int result = Short.compare(this.areaCode, pn.areaCode); if(result == 0)&#123; result = Short.compare(this.prefix, pn.prefix); if(result == 0)&#123; result = Short.compare(this.lineNum, pn.lineNum); &#125; ... &#125; return result;&#125; 或者使用java 8中Comparator中的函数式接口实现 123456public static final Comparator&lt;PhoneNumber&gt; COMPARATOR = comparingInt(pn -&gt; pn.araeCode) .thenComparingInt(pn -&gt; pn.prefix) .thenCOmparingInt(pn -&gt; pn.lineNum);public int compareTo(PhoneNumber pn)&#123; return this.COMPARATOR.compare(this, pn);&#125; 后记实际开发过程中很少用到该章节知识, equals, hasCode, toString等方法都是用第三方类库实现, comparable接口, 在流式处理集合的时候可以手动指定比较器. 总之, 该章节内容,理论大于实践, 只有在很少的情况用到, 自己有特殊的需求时才会用到.","categories":[{"name":"java","slug":"java","permalink":"http://dengbojing.com/categories/java/"}],"tags":[{"name":"java, 读书笔记","slug":"java-读书笔记","permalink":"http://dengbojing.com/tags/java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://dengbojing.com/categories/java/"}]},{"title":"Effective_java_第二章学习笔记","slug":"Effective-java-第二章学习笔记","date":"2021-03-03T06:27:01.000Z","updated":"2021-04-07T06:24:02.431Z","comments":true,"path":"2021/03/03/Effective-java-第二章学习笔记/","link":"","permalink":"http://dengbojing.com/2021/03/03/Effective-java-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"第二章: 创建和销毁对像","text":"第二章: 创建和销毁对像 引言第一章主要讲除了用构造函数之外,如何创建一个对象,以及他们之间的利弊 正文 使用静态工厂方法创建对象. 在对象方法内部,或者使用一个单独的工具类来维护一些静态的创建该类的对象的方法. 工具类(书中术语叫做伴生类)命名方式一般在该类的后面加s, 比如Collection 和 Collections , Collector 和 Collectors 工厂方法的命名方式一般有: from 类型转换方法, 从一个对象中获取我们想要的类的对象,通常只有一个参数. 如: 1NewsBody newsbody = NewsBody.from(news); of 聚合方法,将多个参数聚合在一起, 如: 1NewsBody newsbody = NewsBody.of(news.getTitle(),news.getAuthor(),news.getReleaseDate()); valueOf 功能和上面两个类似, 只是相对来说更加啰嗦, 如: 1NewsBody newsBody = NewsBody.valueOf(news); instance or getInstance 根据给定的参数(可选)来创建对象,但是不能保证该对象一定和参数所描述的对象一致, 如: 1NewsBody newsBody = NewsBody.instance(news); // 可能newsbody中的author字段或者其他字段与参数news中的不一致 create or newInstance 根据参数每次都返回一个新的对象, 如: 1NewsBody newsBody = NewsBody.create(news); getType 功能和getInstance相同,只是该方法处于工具类中, 如java nio2中: 1FileStore fs = Files.getFileStore(path); newsType 功能和newInstance相同, 只是该方法处于工具类中, 如: 1BufferedReader br = Files.newBufferedReader(path); 静态工厂的优点: 除了上述通用的命名方式之外, 可以起一个见名知意的方法, 书中举例为BigInteger中获取素数的方法. 第二个优点是可以控制返回的实例,可以在第一次创建时候缓存起来,以便之后使用,经典案例就是单例模式和享元模式(String采用的模式). 伪代码: 123456public class Elvis&#123; private static final Elvis INSTANCE = new Elvis(); private Elvis()&#123;&#125; public static Elvis getInstance()&#123;return INSTANCE;&#125; public String doSth()&#123;&#125;&#125; 由于INSTANCE是静态的, 所以在类加载时就会创建类的实例, 天然避免了多线程并发问题, 使用静态工厂方法获取该实例, 则每次都获取相同的实例. 第三个优点就是多态. 这个是面向对象三大特性中的重要特性. 使用静态工厂方法, 你可以返回任意一个子类的对象.书中讲述了Collections的由来, 但是在java 8之后, 接口是可以包含静态方法的,所以伴生类存在的理由就很薄弱. 第四个优点是可以根据参数的不同, 静态工厂方法返不同类型的对象.(这一点理解比较模糊,感觉和上一条重复). 第五个优点在编写静态工厂方法时候, 方法返回对象所属的类, 不一定存在. 还是利用多态的特性. 书中举例SPI(Service Provider Interface)机制, 在编写Driver.getConnection() 具体的Connection实现类不一定存在, 由各大数据库厂商自己提供实现. 静态工厂的缺点: 必须提供一个public或者protected的构造函数, 否则无法子类化. 第二个缺点是不好找到, 如果是在该类内部还好, 如果是工具类, 那么就不容易被发现. 扩展: SPI主要是使用ServiceLoader加载位于META-INF/services下面配置的具体的实现类来完成服务. 具体角色如下: Service Provider Interface 服务提供者接口, 通常一种约定, 约定了实现了该接口的类会提供哪种服务. Service Providers 服务的具体提供者, 实现了Service Provider Interface. 并将该类全限定名称写在META-INF/services目录下以服务提供者接口命名的文件中. ServiceLoader 用来加载META-INF/services下所有配置的服务具体提供者的类. 1ServiceLoader&lt;T&gt; serviceLoader = ServiceLoader.load(服务提供者.class); 遇见多参数构造函数时,考虑使用Builder模式. 如果参数过多可以使用重叠构造器, 即构造器套构造器这种, 或者使用javaBean, 即setXxx(), 这两种方式来创建对象. 第一种方法, 代码臃肿不好维护, 而且可读性也差, 如果参数多了就会不知道构造器里面参数是干什么的, 一般有思想的程序员都不会写出来这种代码. 第二种方法我们在编码过程中经常使用,如: news.setAuthor(&quot;dengbojing&quot;), news.setTitle(&quot;xxxx&quot;), news.setReleaseDate(new LocalDate()), news.setContent(&quot;xxxx&quot;) 等等, 该方法弊端就是会出现在构造过程中出现对象状态不一致, 因为构造过程分为几个步骤(分别设置所有属性). 此时使用Builder模式就很容易避免上述错误, 在jdk中其实有很多地方都是使用这种方法, 比如: 123456789101112var httpClient = HttpClient.newBuilder() .authenticator(Authenticator.getDefault()) .connectTimeout(Duration.ofSeconds(10)) .cookieHandler(CookieHandler.getDefault()) .executor(Executors.newFixedThreadPool(2)) .followRedirects(HttpClient.Redirect.NEVER) .priority(1) .proxy(ProxySelector.getDefault()) .sslContext(SSLContext.getDefault()) .sslParameters(new SSLParameters()) .version(HttpClient.Version.HTTP_2) .build(); 有现成lombok插件可以通过@Builder注解实现Builder模式, 方便快捷. 简而言之, 就是如果类里面有很多参数时候, 使用Builder 就是一个很不错的额选择. 用私有构造器或者枚举类型来强化单例模式 单例模式,老生常谈的话题, 具体衍生有饱汉模式, 饿汉模式(翻译过来), 双重检测等等专业名词, 总结一句话: 单元素的枚举类型经常成为单例模式的最佳实践. 通过private构造器来增强不可实例化的类 该条主要针对工具类,包含一些列静态参数或者方法,实例化这些类无意义,所以应该采用私有的构造函数. 使用依赖注入代替硬编码 依赖注入指的是在构造函数或者静态工厂方法中,传入参数来注入所需要的资源(如: this.resource = recource).其中需要注入的资源具有不可变特性. 需要引用底层资源的类不适合使用静态工具类和单例类来实现. 因为这两种方式都不能主动实例化对象, 每次获取的都是同一个底层资源, 所以不适合. 也不适合直接在这种类(需要依赖底层资源)中实例化需要的资源, 应该将这些资源或者资源工厂方法传递到构造函数或者静态工厂方法中, 通过这些来创建这种类 避免创建不需要的对象 String 对象, 这种频繁使用的对象, 则应该避免创建而是直接使用字符串池中的对象. 简而言之就是不要显示创建. 优先使用基本类型, 要避免自动拆箱装箱. 后记剩下几条不是很重要,消除过期引用, 这个在源码里面可以看到, 就是将对象引用等于null; 不使用finalizer方法,这个方法从来都没用过,只在面试题见过; 使用try-with-resource 一般都会使用这种方式.","categories":[{"name":"java,读书笔记","slug":"java-读书笔记","permalink":"http://dengbojing.com/categories/java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://dengbojing.com/tags/java/"}],"keywords":[{"name":"java,读书笔记","slug":"java-读书笔记","permalink":"http://dengbojing.com/categories/java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"java_11_new_http","slug":"java-11-new-http","date":"2020-12-10T01:21:53.000Z","updated":"2020-12-23T12:20:20.872Z","comments":true,"path":"2020/12/10/java-11-new-http/","link":"","permalink":"http://dengbojing.com/2020/12/10/java-11-new-http/","excerpt":"java.net.http模块使用","text":"java.net.http模块使用 引言写代码的时候难免会远程调用别人的api,之前用httpclient,在接着是okhttp,也都是跟着项目上用的,其实java 9就出现了一个http模块,只是当时是孵化版本,java 11正式推出了. 简介主要类和接口 类 java.net.http.HttpClient java.net.http.HttpHeaders java.net.http.HttpRequest java.net.http.HttpRequest.BodyPublishers java.net.http.HttpRequest.BodyHanler java.net.http.HttpRequest.BodySubscribers 接口 java.net.http.HttpClient.Builder java.net.http.HttpRequest.BodyPublisher java.net.http.HttpRequest.Builder java.net.http.HttpResponse&lt;T&gt; java.net.http.HttpResponse.BodyHandler&lt;T&gt; java.net.http.HttpResponse.BodySubscriber&lt;T&gt; java.net.http.HttpResponse.PushPromiseHandler&lt;T&gt; java.net.http.HttpResponse.ResponseInfo java.net.http.WebSocket java.net.http.WebSocket.Builder java.net.http.WebSocket.Listener 基本使用 jdk 9之后都是使用模块化组织代码,所以创建一个模块化的项目让后引入java.net.http模块. 123module com.dbj.httpClient&#123; requires java.net.http&#125; 创建httpClient 使用builder模式创建对象, 基本上该包下面所有的对象都使用builder模式创建对象, 这么做的好处参见effective java一书 12345678910111213var httpClient = HttpClient.newBuilder() .authenticator(new BasicAuthenticator(\"user\", \"password\")) //.authenticator(Authenticator.getDefault() .connectTimeout(Duration.ofSeconds(10)) .cookieHandler(CookieHandler.getDefault()) .executor(Executors.newFixedThreadPool(2)) .followRedirects(HttpClient.Redirect.NEVER) .priority(1) .proxy(ProxySelector.getDefault()) .sslContext(SSLContext.getDefault()) .sslParameters(new SSLParameters()) .version(HttpClient.Version.HTTP_2) .build(); or 1var httpClient = HttpClient.newHttpClient(); equivalent 1var httpCLient = HttpClient.newBuilder().build(); httpClient 类似String 设计模式是不变的,所以没有提供方法改变创建时候的参数. 如果使用http2创建链接,但是服务端不支持,那么会自动降级成为http1.1,如果没有指定,默认也是使用http2 excutor() 在使用异步请求时候使用,默认是使用线程池技术 connectionTimeout() 默认没有超时时间 priority() 优先级,范围[1-256],不在此范围会抛出异常 connectTimeout() 链接超时设置,在设定的时间内没有连接上则抛出HttpConnectTimeoutException executor() 用于异步任务执行,如果未指定,则会为每个HttpClient实例创建一个. followRedirects() 当服务器返回30x时,是否跳转,默认不跳转 authenticator() 验证参数,Authenticator.getDefault()获取当前验证规则,可以使用BasicAuthenticator来传递用户名密码,也可以继承Authenticator实现自己的验证规则. proxy() 是否使用代理. 创建HttpRequest 12345678var httpRequset = HttpRequest.newBuilder(URI.create(\"\")) .header(\"Content-Type\",\"application/json\") .header(\"token\",\"faeaafwefeawgaer\") .timeout(Duration.of(10, ChronoUnit.SECONDS)) .expectContinue(true) .POST(HttpRequest.BodyPublishers.ofString(\"\")) .version(HttpClient.Version.HTTP_2) .build(); uri() 可以在newBuidler() 中指定请求地址,也可以调用uri()方法指定请求地址.两者效果是一样的 header() 效果与setHeader()相同,另有headers()批量设置请求头, 请求头键值对必须严格按照RFC7230-section-3.2约定,否则抛出异常. timeout() 请求超时时间设置,超过设定时间未收到响应则抛出异常,如不限制会永远阻塞(等待) POST() GET() DELETE() PUT() 请求方法,或者使用mehtod()设置请求方法 使用前后端分离时候往往前端会发送一次options请求来判断后端是否支持跨域,此时就可以使用method(&quot;OPTIONS&quot;,BodyPublishers.noBody()) BodyPublishers 用于构建BodyPublisher的工具类,包含了一系列实用的构建请求体的方法,其中BodyPublishers 主要是调用RequestPublishers 来完成创建,RequestPublishers 中包含了很多BodyPublisher接口的实现 HttpResponse 同步请求 1var httpResponse = httpClient.send(requset,BodyHandlers.ofString()); 异步请求 1234567var httpResponse = httpClient.sendAsync(httpRequest, HttpResponse.BodyHandlers.ofString()) .thenApply(stringHttpResponse -&gt; &#123; System.out.println(stringHttpResponse.statusCode()); return stringHttpResponse; &#125;) .thenApply(HttpResponse::body) .thenAccept(System.out::println); or 批量请求接口 123456789101112131415 var client = HttpClient.newHttpClient();List&lt;HttpRequest&gt; requests = paths.stream() .map(path -&gt; \"https://localhost:8443\" + path) .map(URI::create) .map(uri -&gt; HttpRequest.newBuilder(uri).build()) .collect(Collectors.toList()); CompletableFuture&lt;?&gt;[] responses = requests.stream() .map(request -&gt; client.sendAsync(request, BodyHandlers.ofString()) .thenApply(HttpResponse::body) .exceptionally(e -&gt; \"Error: \" + e.getMessage()) .thenAccept(System.out::println)) .toArray(CompletableFuture&lt;?&gt;[]::new); 异步请求返回一个CompletableFuture&lt;HttpResponse&lt;T&gt;&gt;,当有响应返回时,该对象后续回调将会被调用.异步请求使用创建httpClient时指定的executor来执行异步请求. HttpResponse为一个接口, 不能直接创建, 所有实例都是httpClient请求返回, 接口提供方法如下: 返回值 方法 描述 T body() 返回响应体 HttpHeaders headers() 返回响应投 int statusCode() 返回的状态码 HttpRequset request() 返回对应的请求体 URI uri() 返回请求地址 HttpClient.Version version() 返回http请求协议版本 BodyHandlers 用于构建BodyHandler的工厂类. 进阶使用 JSON请求 发送请求时秩序指定Content-Type为application/json, 然后将对象转换为json字符串 12345var httpRequest = HttpRequest.newBuilder(URI.create(\"\")) .header(\"content-type\",\"application/json\") .GET() .build(); 接受响应时,自定义BodyHandler将返回的json字符串转换为对象 12345678910111213141516171819202122232425262728public class JsonHandler&lt;T&gt; implements HttpResponse.BodyHandler&lt;T&gt; &#123; private final Class&lt;T&gt; type; private final Gson gson; public JsonHandler(Class&lt;T&gt; type, Gson gson) &#123; this.type = type; this.gson = gson; &#125; @Override public HttpResponse.BodySubscriber&lt;T&gt; apply(HttpResponse.ResponseInfo responseInfo) &#123; return HttpResponse.BodySubscribers.mapping(HttpResponse.BodySubscribers.ofByteArray(),bytes -&gt; gson.fromJson(new String(bytes),this.type)); &#125; public static class JsonHandlers &#123; private JsonHandlers()&#123;&#125; public static &lt;T&gt; JsonHandler&lt;T&gt; ofType(Class&lt;T&gt; type)&#123; return of(new Gson(), type); &#125; public static &lt;T&gt; JsonHandler&lt;T&gt; of(Gson gson, Class&lt;T&gt; type)&#123; return new JsonHandler&lt;T&gt;( type,gson); &#125; &#125;&#125; 使用client发送请求,并接收响应. 123var client = HttpClient.newHttpClient(URI.create(\"Http://localhost:8080\"));var response = client.send(request, JsonHandler.JsonHandlers.ofType(UserBody.class));var userBody = response.body(); // or 使用异步响应 12345var task = client.sendAsync(request, JsonHandler.JsonHandlers.ofType(UserBody.class)) .thenApply(HttpResponse::body) .thenApply(UserBody::getName) .thenAccept(System.out::println);task.get();//测试方便输出结果. x-www-form-urlencoded 请求 这种请求类型是form表单的默认请求类型,另一种就是可以上传文件的form-data了,但是没有现成的类或者方法支持x-www-form-urlencoded请求,不过该请求投类型很好分析 将form表单里面的name和value用=链接,在把他们用&amp;符号链接起来,如果包含空格替换为+,如果有特殊符号,则转换为ASCII HEX值;如果包含中文字符,则转成ASCII HEX后在百分号编码. 百分号编码: 汉字在utf-8字符集里面是占3个字节的,所以转换成16进制字符串就是占6个字节,每两个字节前面加一个百分号,就变成9个字节传递. 如果是GET请求,那直接在url后?拼接. 如果是POST请求, 那就把拼接好的字符串放在body里面. 简单点就是用现成的库urlencoded, 这种库应该是大部分语言都自带的. 123456789101112public static HttpRequest.BodyPublisher ofXForm(Map&lt;Object,Object&gt; map)&#123; var builder = new StringBuilder(); map.forEach((key, value) -&gt; &#123; if (builder.length() &gt; 0) &#123; builder.append(\"&amp;\"); &#125; builder.append(URLEncoder.encode(key.toString(), StandardCharsets.UTF_8)); builder.append(\"=\"); builder.append(URLEncoder.encode(value.toString(), StandardCharsets.UTF_8)); &#125;); return HttpRequest.BodyPublishers.ofString(builder.toString());&#125; 文件上传下载 下载 下载很简单直接,有现成的方法可以使用. 1234var client = HttpClient.newHttpClient();var request = HttpRequest.newBuilder(URI.create(url)).build();var file = Paths.get(\"1.png\");var response = client.send(request,BodyHandlers.ofFile(file)); 该方法适合知道文件名称时使用.or 1234var client = HttpClient.newHttpClient();var request = HttpRequset.newBuilder(URI.create(url)).build();var file = Paths.get(\"/usr/local/file\");var response = client.send(requset,BodyHandlers.ofFileDownload(file)); ofFileDownload属于比较常见的下载方式. 上传 上传没有现成的方法,所以需要我们自定义一个BodyPublishers.ofFile()方法,然后请求头为mutipart/form-data发送请求 1234567891011121314151617181920212223public static HttpRequest.BodyPublisher ofFile(Map&lt;Object,Object&gt; data,String boundary) throws IOException &#123; var byteArrays = new ArrayList&lt;byte[]&gt;(); byte[] separator = (\"--\" + boundary + \"\\r\\nContent-Disposition: form-data; name=\") .getBytes(StandardCharsets.UTF_8); for (Map.Entry&lt;Object, Object&gt; entry : data.entrySet()) &#123; byteArrays.add(separator); if (entry.getValue() instanceof Path) &#123; var path = (Path) entry.getValue(); String mimeType = Files.probeContentType(path); byteArrays.add((\"\\\"\" + entry.getKey() + \"\\\"; filename=\\\"\" + path.getFileName() + \"\\\"\\r\\nContent-Type: \" + mimeType + \"\\r\\n\\r\\n\").getBytes(StandardCharsets.UTF_8)); byteArrays.add(Files.readAllBytes(path)); byteArrays.add(\"\\r\\n\".getBytes(StandardCharsets.UTF_8)); &#125; else &#123; byteArrays.add((\"\\\"\" + entry.getKey() + \"\\\"\\r\\n\\r\\n\" + entry.getValue() + \"\\r\\n\") .getBytes(StandardCharsets.UTF_8)); &#125; &#125; byteArrays.add((\"--\" + boundary + \"--\").getBytes(StandardCharsets.UTF_8)); return HttpRequest.BodyPublishers.ofByteArrays(byteArrays);&#125; 1234567891011Map&lt;Object,Object&gt; data = new HashMap&lt;&gt;();data.put(\"apikey\", virusTotalApiKey);data.put(\"file\", localFile);String boundary = new BigInteger(256, new Random()).toString();request = HttpRequest.newBuilder() .header(\"Content-Type\", \"multipart/form-data;boundary=\" + boundary) .POST(ofMimeMultipartData(data, boundary)) .uri(URI.create(url)) .build();HttpResponse&lt;String&gt; response = client.send(request, BodyHandlers.ofString()); 高阶使用 HTTP2 server push WebSocket 123456789101112131415161718192021222324252627282930WebSocket webSocket = HttpClient.newHttpClient().newWebSocketBuilder().buildAsync(new URI(\"ws://localhost:8081/platform/device/gps\"), new WebSocket.Listener() &#123; @Override public CompletionStage&lt;?&gt; onText(WebSocket webSocket, CharSequence data, boolean last) &#123; System.out.println(\"onText: \" + data); return WebSocket.Listener.super.onText(webSocket, data, last); &#125; @Override public void onOpen(WebSocket webSocket) &#123; System.out.println(\"onOpen\"); WebSocket.Listener.super.onOpen(webSocket); &#125; @Override public CompletionStage&lt;?&gt; onClose(WebSocket webSocket, int statusCode, String reason) &#123; System.out.println(\"onClose: \" + statusCode + \" \" + reason); return WebSocket.Listener.super.onClose(webSocket, statusCode, reason); &#125; &#125;).join(); Gson gson = new Gson(); Message message = new Message(); message.setFrom(\"dbj\"); message.setContent(\"client data send\"); message.setTo(\"some one\"); webSocket.sendText(gson.toJson(message),true); 其中super.OnXxxx()为固定句式, 其实就是调用websocket.requset(1).固定调用.","categories":[{"name":"java","slug":"java","permalink":"http://dengbojing.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://dengbojing.com/tags/java/"},{"name":"java11","slug":"java11","permalink":"http://dengbojing.com/tags/java11/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://dengbojing.com/categories/java/"}]},{"title":"微信图片转换","slug":"微信图片转换","date":"2020-10-22T11:37:07.000Z","updated":"2023-04-16T12:06:22.717Z","comments":true,"path":"2020/10/22/微信图片转换/","link":"","permalink":"http://dengbojing.com/2020/10/22/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E8%BD%AC%E6%8D%A2/","excerpt":"PC端微信图片转换","text":"PC端微信图片转换 引言最近孩子去上早教班,老师在早教群里发了很多孩子的图片,我就想着把这些图片存起来,但是老师发一张我存一张这种模式对程序员来说是一种侮辱,所以我就想是不是存在了微信文件夹下面,一看果不其然,只是格式不是jpg,png,gif等,是dat格式,经过一番百度(ps:微信是国内的东西,所以还是百多搜索比较靠谱)终于找到了解码方法.特此记录. 正文微信文件目录微信的图片文件地址这个不难找,具体目录为${wechatFilesDir}&#x2F;{your_wechat_id}&#x2F;FileStroage&#x2F;image,占位符代表微信文件存储目录(微信设置-&gt;文件管理)和自己微信的微信号. 所需图片知识 jpg&#x2F;jpeg标识头: 0xff 0xd8 png标识头: 0x89 0x50 gif标识头: 0x47 0x49 当然还有其他的图片格式可以自行谷歌. 微信.bat文件加密方式定义一个key值,将图片转换为二进制流,然后每一位与这个key值进行异或(xor),得到新的byte值,然后写入.所以我们反解就很明显了,假设图片为jpg,我们已知jpg图片前两位为0xff,0xd8,用16进制方式打开.bat文件,得到前两位为x,x1.只需x^0xff&#x3D;&#x3D;x^0xd8 成立(因为x=key^0xff,x1=key^0xd8),那么这个图片就是jpg. 代码示例仅仅是一个示例,实际开发应当更严谨处理异常以及分支. 123456789101112131415161718192021@Testpublic void test() throws IOException &#123; int base = 0xff; int next = 0xd8; int pngBase = 0x89; int pngNext = 0x50; byte[] bs = Files.readAllBytes(Paths.get(&quot;D:\\\\WebChat\\\\WeChat Files\\\\wxid_sxelod34kou321\\\\FileStorage\\\\Image\\\\2020-06\\\\0ce7898a35eb2a7ac9045480419e5902.dat&quot;)); int firstByte = bs[0] &amp; 0xff; int secondByte = bs[1] &amp; 0xff; int key = base ^ firstByte; String suffix = &quot;.jpg&quot;; if((pngBase ^ firstByte) == (pngNext ^ secondByte))&#123; key = pngBase ^ firstByte; suffix = &quot;.png&quot;; &#125; try(OutputStream os = Files.newOutputStream(Paths.get(&quot;D:\\\\123&quot;+suffix),StandardOpenOption.CREATE))&#123; for(byte b : bs)&#123; os.write(b ^ key); &#125; &#125;&#125; 后记通过对比发现一个问题,key值在我公司电脑和家里电脑完全相同.也就是说这个算key的过程应该是拿微信里面的一个固定信息算出来的.这个等在后面在研究一下具体是怎么算的.","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://dengbojing.com/tags/java/"}],"keywords":[]},{"title":"Naming Convention--命名规范","slug":"Naming-Convention-命名规范","date":"2020-09-21T13:38:30.000Z","updated":"2020-12-22T06:20:28.647Z","comments":true,"path":"2020/09/21/Naming-Convention-命名规范/","link":"","permalink":"http://dengbojing.com/2020/09/21/Naming-Convention-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/","excerpt":"译文: Clean Code (Best practice for naming) Part 1","text":"译文: Clean Code (Best practice for naming) Part 1 引言 在代码开发过程中好的变量命名习惯是非常重要的,如果是i,j,k,l的命名,我相信不用同组小伙伴打死你,几个月以后的自己都想打死自己.所以,一个好的命名规范尤为重要,不仅要让编译器看懂,阅读代码的人更要是见名知意. 译文 原文地址 在你写代码时候,你觉得你是为谁在写?第一想法是我写代码是为了编译器能编译.想法是对的,编译器应该能’看懂’你得代码并且能编译执行这些代码.那有没有其他的读者阅读你的代码呢?在专业的开发中,你开发代码并不是隔离式的,你处在一个团队里面,并且团队里面可能有很多其他成员,所以你写的代码应该能让这些团队成员看懂.大概率会发生你需要重新审视这些代码来了解这些代码是什么,怎么工作的,为什么会这么写.大概率会发生在将来你无法回答这些问题的时候正好有其他人需要你这段代码.四个不同的组,最后面的3个组有共同点是非常重要的.所以我们需要确保我们写出的代码能被人类读懂.这就是代码整洁之道.只有遵循这些准则,才能确保你写的代码能被将来阅读它的人看懂,或者你的同组小伙伴code review的时候看懂,或者你自己将来做bug fix是看懂,或者你得交接人能添加一个新的功能. 怎么样才是整洁的代码 代码能被机器编译以及能被人类看懂 代码名称简单易懂 格式一致,格式影响代码的可读性 容易改善,比凌乱的代码容易修复 能清晰的表达出其意图.写代码的人能明白这段代码是做什么的 如下代码,该方法名称不够整洁规范,以至于无法说明方法的意图,这种情况你就需要一行一行的阅读代码才能了解他是做是你么的: 1234567891011fun s(arr: IntArray) &#123; val n &#x3D; arr.size for(i in 0 until n-1) &#123; for (j in 0 until n-i-1) if (arr[j] &gt; arr[j+1] &#123; val temp &#x3D; arr[j] arr[j] &#x3D; arr[j+1] arr[j] &#x3D; temp &#125; &#125;&#125; 整洁规范的代码: 12345678910fun buuleSort(array: IntArray) &#123; for (index in 0 until arraySize - 1) &#123; for (pointerIndex in 0 until arraySize - index - 1) if (array[pointerIndex] &gt; array[pointerIndex + 1]) &#123; val temp &#x3D; array[pointerIndex] array[pointerIndex] &#x3D; array[pointerIndex + 1] array[pointerIndex + 1] &#x3D; temp &#125; &#125;&#125; 这样你能一眼就看出来这个方法的意图,对,就是冒泡排序. 类命名规范 类名应该使用名词. $#x1F47D 12class Performer&#123;&#125;class Performance&#123;&#125; 避免动词形式的类名. 123class Perform&#123;&#125;class Performed&#123;&#125;class Performing&#123;&#125; 使用形容词前缀表示时态. 123class ActivePerformance &#123;&#125;class PastPerformer &#123;&#125;` 类名不能仅使用形容词. 1234class Huge &#123;&#125;class Small&#123;&#125;class Fast &#123;&#125;class Slow &#123;&#125; 使用形容词前缀加名词作为类名. 12class SmallPerformance &#123;&#125;class PastPerformer &#123;&#125; 避免使用模糊前缀. 1234class MyPerformer &#123;&#125;class APerformer &#123;&#125;class ThePerformer &#123;&#125;class ThisPerformer &#123;&#125; 避免使用单个字母作为类名. 12class P &#123;&#125;class L &#123;&#125; 避免使用单字母前缀类名. 12class CPerformer() &#123;&#125;class TPerformer() &#123;&#125; 避免使用首字母缩写词大写. 1class HTTPAPIPerformer &#123;&#125; 在单词连接处首字母大写(驼峰命名). 12class HttpApiPerformer &#123;&#125;` 避免使用缩略词. 1class Perf &#123;&#125; 避免使用复数作为类名. 12class performers &#123;&#125;` 使用复数作为集合类的类名. 123456789class Currencies &#123;...// contain map of Currencies, and romat price for each currency val currencyMap = mapOf( Pair(RUSSIAN_RUBLE, \"\\u20BD\"), Pair(UNITED_STATES_DOLLAR, \"\\$\") )...&#125; 整洁规范的方法名称 使用一般现在时作为方法名称. 1234func open() &#123;&#125;func perform() &#123;&#125;func close() &#123;&#125;func validate() &#123;&#125; 避免使用动名词(现在进行时). 1234func performing() &#123;&#125;func validating() &#123;&#125;func opening() &#123;&#125;func closing() &#123;&#125; 避免使用一般过去时. 1234func performed() &#123;&#125;func opened() &#123;&#125;func closed() &#123;&#125;func validated() &#123;&#125; 使用is作为动名词前缀. 123func isRunning() &#123;&#125;func isClosing() &#123;&#125;func isServint() &#123;&#125; 使用has作为一般过去时前缀. 1234func hasPerformed() &#123;&#125;func hasOpened() &#123;&#125;func hasClosed() &#123;&#125;func hasValidated() &#123;&#125; 在应用系统中保持所有的命名标准和转换一致. 如果语言支持驼峰命名,则应该使用驼峰命名.驼峰命名的准确率比下划线命名准去率要高(高出51.5%的几率) 整洁规范的变量命名 使用单数名词作为原始类型和对象类型的变量名] 12int count = 0;User user = new User(); 使用复数名字作为数组和集合的变量名 12String[] names = new String[](\"Alex\", \"Ali\", \"Aesop\"&#125;;List&lt;String&gt; names = new ArrayList&lt;String&gt;(); 避免使用动词作为原始类型的变量名 12boolean create = false;int perform = 12; 使用名词作为原始类型的变量名 12int performanceCode = 12;boolean creationEnabled = false; 避免使用单个单词作为变量名 12int s = 12;int i = 8; 使用有意义的变量名 12int size = 10;int index = 9; 避免使用容易引起混淆的缩写和简写. 1String dbsqlSelAllNames = \"select * from names\"; 使用大写分割变量名,并将简写展开 1String dbSqlSelectAllNames = \"select * from names\"; 不要使用无用的复杂前缀,如匈牙利前缀 1String f_strFirstName = \"Jefferson\"; 避免使用数据类型最为变量名后缀 1String lastNameString = \"Amaya\"; 整洁规范的参数名 命名参数包含单个值时,使用单数名词 123public int add(int left, int right)&#123; return left + right;&#125; 命名参数包含多个值时,使用复数名词 123public int sum(List&lt;Integer&gt; values)&#123; return values.stream().collect(Collectors.summarizingInt(Integer::intValue)).getSum();&#125; 避免使用单个字母作为参数名称 123public int add(int i, int j) &#123; return i+j;&#125; 避免使用简写作为参数名 1public void open(String FSP)&#123;&#125; 参数首字母不应该大写 1public void random(int SeedGenerator)&#123;&#125; 避免使用难懂的前缀 1public void persistName(String sName)&#123;&#125; 整洁规范的常量名 常量名所有的字母都应该大写. 使用单数名词作为原始类型常量命名. 使用复数名词作为集合常量命名. 避免使用单字母和简写. 确保首字母缩写词之间的分割. 后记这些规范是根据语言来定,对于其他语言可能有所变化","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://dengbojing.com/tags/java/"}],"keywords":[]},{"title":"how_to_write_good_tests","slug":"how-to-write-good-tests","date":"2020-06-04T13:35:35.000Z","updated":"2020-06-09T15:02:43.098Z","comments":true,"path":"2020/06/04/how-to-write-good-tests/","link":"","permalink":"http://dengbojing.com/2020/06/04/how-to-write-good-tests/","excerpt":"译文: How to write good tests","text":"译文: How to write good tests 引言 代码测试是一件非常重要的工作,在之前的工作中总是找各种借口(时间不够,写起来太繁琐,有些场景无法测试)等等原因做的不够完善.有时甚至不做,无心之中发现一篇非常好的代码测试文章.花些时间来翻译一下,提高一下英文水平,顺便也学习一下正经的代码测试该是什么样的. 译文 原文地址 为我们的软件定制一个测试用例是件好事,但是实际上,一个好的的测试用例也是非常重要的. 遵循一些固有的原则来热爱测试代码 保持测试代码简洁和可读 要做到这一点,需要像对生产代码那样进行无情的重构.否则,让事情发展下去测试代码就会变成恐怖的祖传代码.如果测试代码不能轻松重构,那么意味着生产代码也不能重构,从而导致祖传代码.总是要勇于重构. 避免编码重复 例如, 测试代码与parser使用完全相同的正则表达式来生成内容. 通常来说人们不愿意重复测试与代码的逻辑,所以在测试中重复正则表达式或者其他代码是不可取的.设想以下测试情况,输入/输出结果(f(input)-&gt;(output)),例如,如果代码要处理模版,不要添加固定值,相反,应该根据计算结果添加值. 12345// useAssertions.assertThat(processTemplate(\"param1\", \"param2\")).isEqualTo(\"this is 'param1', and this is 'param2'\"));// instead ofAssertions.assertThat(processTemplate(\"param1\", \"param2\")).isEqualTo(String.format(\"this is '%s', and this is '%s'\", param1, param2)); 覆盖尽可能多的情况,来显示正向的用例,特别是错误的代码位置 通常使用测试驱动开发(TDD--Test Dirven Development)是最佳的实践方式. 使用TDD人们能在设计阶段就找出什么地方会被破坏. 不要认为为一个小的代码片段编写简单的测试不值得，你永远不知道什么时候、因为什么而修改这段代码. 可与使用PIT(突变检测系统)来对测试代码的有效性进行检测. 不要Mock一个你不拥有的类型 这并非一条硬性规定,但是如果不遵循该条规定会有影响(很可能会有). TDD的设计方面和测试方面同样重要.在模拟外部API时,无法使用测试来驱动设计,该API属于其他人;因此第三方也将可以更改API的方法签名和行为. 设想一下代码mocks了一个第三方库,在更新了第三方库之后,三方库的逻辑可能改变了一点,但是测试代码依然能够执行成功,因为他被mock了.所以在这之后,所有的事情看起来很美好,构建也成功了,但是软件部署到正式环境–爆炸! 这也可能导致当前的设计和第三方库不够松耦合. 另一个问是第三方库可能非常复杂需要mock许多东西才能运行,这就导致了大量的特定测试和复杂的测试装置, 而这本身就损害了简洁性和可读性的目标.或者由于模拟外部系统的复杂性而没有充分覆盖代码的测试. 相反,最常见的方式是创建一个第三方库的warpper来包装他们,不过应该注意抽象泄漏(什么是abstraction leakage?)的风险,因为太多的底层API,概念或者异常超过了warpper的边界.为了验证第三方提供API的可用性,请使用集成测试,并尽可能的是它们简洁可读. 下面是其他人在mock了非他所有的类型库遇到的痛苦和总结的经验: http://davesquared.net/2011/04/dont-mock-types-you-dont-own.html http://www.markhneedham.com/blog/2009/12/13/tdd-only-mock-types-you-own http://blog.8thlight.com/eric-smith/2011/10/27/thats-not-yours.html http://stackoverflow.com/questions/1906344/should-you-only-mock-types-you-own 反模式: Mock一切 如果所有的代码都mock了,那么我们怎么测试业务代码?不要害怕不使用Mock的方法. 不要Mock值对象 为什么会有人要这么做呢? 因为实例化一个对象非常痛苦? =&gt; 不是一个很好的理由 如果创建一个对象非常困难,那么这是代码需要严重重构的一个信号.一种可行的方法就是为你的值对象构造一个builder(构造者模式)–有很多工具可以使用比如IDE 插件,Lombok等等. 还可以在测试环境中创建有意义的工厂方法. 12345abstract class CustomerCreations &#123; public static Customer customer_with_a_single_item_in_the_basket() &#123; // long init sequence &#125;&#125; Mockito更加关注对象交互,这也是面向对象的重要要素. (原文)推荐阅读Growing Object Oriented Software Guided by Tests必读,这本书阐释了功能完整的应用程序在从无到有过程中, 开发的许多方面以及如何在项目生命周期的各个阶段实现测试. 如果遇到一些不理解不确定的事情,可以发邮件给作者.","categories":[],"tags":[{"name":"mockito","slug":"mockito","permalink":"http://dengbojing.com/tags/mockito/"}],"keywords":[]},{"title":"docker-network","slug":"docker-network","date":"2020-03-13T02:12:37.000Z","updated":"2020-08-04T12:36:28.596Z","comments":true,"path":"2020/03/13/docker-network/","link":"","permalink":"http://dengbojing.com/2020/03/13/docker-network/","excerpt":"docker-network学习","text":"docker-network学习 引言阶段性的记录一下docker学习,docker-network里面还有很多问题很搞明白,亟待解决. 以下操作都是基于docker desktop for windows的linux container模式下 介绍 docker 官方有5种网络模式,none,bridge,macvlan,host,overlay. 1.1 none 模式,参数 --network=none,无网络模式,这种模式一般很少用,官方说法是和自定义网络驱动时使用. 1.2 birdge 模式,参数 --network ${bridge_name}.该模式是默认模式,在安装docker会创建一个默认的docker0的linux网桥,如果启动容器时不指定网络,就会默认连接到docker0网桥 docker desktop for windows看不见docker0,这是因为,docker desktop for windows实际上是把Docker装在Hyper-v虚拟机上,打开Hyper-v虚拟机管理,可以看到DockerDesktopVM这个虚拟机,Docker实际是运行在这个里面,而docker0就在这个里面,但是你如果连接这个虚拟机,发现连接不上. 1.3 host 模式,参数--network=host,该模式下,容器和宿主机共用一个网络,在指定--privileged=true 时候,如果你不小心修改了网络参数,那么就会造成不必要的麻烦,所以一般不推荐这中做法,上面说到docker desktop for windows 无法查看虚拟机里面的docker0网桥,此时如果你以--network=host启动一个容器,此时你就可以执行ifconfig看到docker0网桥. 另一个查看方式docker run -it --rm --privileged --pid=host justincormack/nsenter1,启动之后,执行 ifconfig,指定 --pid=host 参数就是说,让当前启动的容器可以看到宿主机上所有的进程. 1.4 overlay 模式, 参数 network=container:${conatiner_id},该模式下,容器1和容器2共用一个网络. 1.5 macvlan 指定网络的mac地址. 实战bridge模式 docker network ls查看网络,可以看到上面讲到的3种类型的网络,至于overlay呢,是需要依赖别的容器,所以取决与别的容器的网络模式,主要学习一下桥接模式的内容. bridge 网桥模式的原理, 当创建一个容器的时候,Docker 会创建两个网络模块,一个是在容器里面叫eth0, 另一个则在宿主机里面,名字为vethxxxx,Docker 这个网络模块桥街道容器里面的eth0. 2.1 首先我们以bridge启动一个ubuntu 容器,执行: docker run -ti --rm ubuntu:14.04 bash, 启动一个一次性容器并进入 2.2 在容器中执行ifconfig, 看到如下图所示: lo: loopback 回环网络接口,也就是执行localhost或者127.0.0.1时候会走这个网络接口 eth0: 所有来自外部的流量都会通过这个网络接口 2.2 新开一个终端窗口,执行docker run -it --rm --privileged --pid=host justincormack/nsenter1 , 进入容器之后,执行ifconfig 可以看到如图所示: 其中一个vethxxx是桥接到上面ubuntu 容器的网络接口,另一个是当前这个容器的网络接口(因为当前网络没有指定网络模式,所以以默认桥接模式启动,所以也会给当前容器创建一个网络接口). 自定义网桥,之前使用docker-compose 创建了一个compose, 里面包含了一个gateway和一个zookeeper, 里面还定义了一个network ,让两个容器能够以容器名称相互访问, 了解了docker network之后,其实里面network 节点就是创建了一个bridge 网桥, 此时容器就可以通过名称相互访问, 官方名称叫 automatic service discovery 服务自动发现(瞎鸡巴翻译的). 3.1 执行docker network create -d bridge my-network创建一个bridge 类型网络, 执行docker inspect my-network 看一下里面都有什么, 如图: 可以看到,子网掩码是172,19.0.0/16,网关是172,19.0.1,可以使用--subnet=192.168.0.0/16 来指定子网掩码,另外还可以使用--gateway=192.168.0.1 指定网关, --ip-range=192.168.2.0/25指定ip范围 3.2 最好是指定子网掩码,免得网络冲突.如果不指定网关,会从地址范围内自动选择一个出来作为网关,目前测试结论默认是xxx.xxx.xxx.1. 使用docker run --network=my-network 来启动一个容器,执行ifconfig:可以看到此时ip地址为我们创建的桥接网络借口的ip地址范围 一个容器可以同时连接两个网络,使用docker network connect ${networkid|networkname} ${containerid|containername}, 如图:会有两个网络接口一个eth0,另一个eth1, 这样该容器就可以同时访问两个网路 docker network disconnect ${networkid|networkname} ${containerid|containername} 取消容器和网络的链接 --icc高级参数, 如果网络该参数为禁止,则两个容器之间是无法访问的. 后记网络这块真的是比较重要,也比较难的一块,还可以创建overlay类型的网络,有待研究.官方说法生产环境最好不要使用默认的docker0网桥,所以使用docker-compose管理容器还是一个比较好的方式.或者努力学习k8s吧. 积土成山,风雨兴焉;积水成,渊蛟龙生","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://dengbojing.com/tags/docker/"}],"keywords":[]},{"title":"docker-compose","slug":"docker-compose","date":"2020-02-11T09:36:28.000Z","updated":"2020-07-01T01:47:58.026Z","comments":true,"path":"2020/02/11/docker-compose/","link":"","permalink":"http://dengbojing.com/2020/02/11/docker-compose/","excerpt":"what? 扫把独立日?","text":"what? 扫把独立日? 引言使用gradle插件构建镜像和docker-compose连接容器 Talk is cheap, show me the code 准备打开docker远程访问端口,docker desktop for windows GUI 界面有一个expose daemon on tcp://localhost:2375, 只需要勾选,然后重启就行;当然这个是提供一个loopback的访问,实际上你并没有真正的暴露一个局域网或者广域网访问的端口,不过对于docker-gradle 使用已经足够,如果非要提供一个远程访问端口请参考微软文档.操作很简单就是在 C:\\ProgramData\\Docker\\config\\daemon.json 添加一行&quot;hosts&quot;: [&quot;tcp://0.0.0.0:2375&quot;](ps:需要关闭expose daemon on tcp://localhost:2375), 这里需要注意的就是你 docker desktop for windows 是以windows container启动的而不是linux container 方式启动, 不然不起作用, 如果非要以linux container方式启动并且提供外网访问, 也不是没有办法具体操作参考这个issue(ps:未实验) Gradle插件构建镜像 在 build.gradle 中添加 docker-plugin 插件,然后编写脚本具体文档参考这里, 最终 build.gradle 就是像下面这样: 12345678910111213141516plugins &#123; ... id &#39;com.bmuschko.docker-spring-boot-application&#39; version &#39;6.1.3&#39; ...&#125;dependencies&#123;...&#125;docker &#123; springBootApplication &#123; baseImage &#x3D; &#39;openjdk:11&#39; ports &#x3D; [8090] maintainer &#x3D; &#39;dengbojing@qq.com&#39; images &#x3D; [&#39;dengbojing&#x2F;gateway:v3&#39;] jvmArgs &#x3D; [&#39;-Dspring.profiles.active&#x3D;production&#39;, &#39;-Xmx2048m&#39;] mainClassName &#x3D; &#39;com.yichen.ServiceGatewayApplication&#39; &#125;&#125; baseImage 基于哪个基础镜像构建. ports 需要暴露的端口. maintainer 对应 dockerfile 中已经废弃的 maintainer 命令, 添加一些元信息. images 构建出来的额镜像名称. jvmArgs 对应 dockerfile ENTRYPOINT 命令中的启动参数. mainClassName 对应 dockerfile ENTRYPOINT 命令中的启动类. 执行 gradle dockerBuildImage, 该命令就会使用 docker -H tcp://127.0.0.1:2375 build 来构建镜像, 所以要先开启 2375端口;当然该插件也能提供远程构建,具体请看官方文档;如果使用开发工具可以在开发工具gradle插件里面找到对应的执行的task;然后会在 ${classpath}/build/docker 下面看到生成的 dockerfile,这里并不是打 jar 包的方式, 而是用完整的lib 和 classes 制作镜像,然后用java -cp 指定设置 classpath 然后启动脚本写的 mianClass;此时执行 docker images 就可以看到制作的镜像. 插件提供了4个 task, 分别是 dockerPushImage–推送镜像到镜像仓库,需要指定用户名密码,具体参看官方文档 , dockerBuildImage–构建镜像 , dockerCreateDockerfile–创建dockerfile , dockerSyncBuildContext–将代码同步到docker context , 前面的 task 总是依赖后面的 task. Docker-compose介绍 &amp; 简单使用 docker-compose 是官方提供的编排项目工具, 主要是应对单机多容器之间连接通信. 使用 docker-compose.yml 作为模版文件 模版文件开头使用 version 来指定 docker-compose 文件格式,目前最新版本为3.7,具体对照关系可以参考这里 一个简单的 docker-compose.yml 示例: 123456789101112131415version: '3'services: web: build: . image: dengbojing/gateway:v4 ports: - \"8090:8090\" networks: - gateway zookeeper: image: zookeeper networks: - gatewaynetworks: gateway: version: compose的版本号,具体对应关系可以查看文档services: 需要启动的服务,一个服务对应一个容器,也就是说在执行该文件之后,会多出两个容器web,zookeeper: 服务名称, 最终创建的容器名称会以启动时候指定的 ${project_name} 加上服务的名称为完整的容器名称build: 指定构建的 docker-context 和 dockerfile, 此处都在当前目录; 详细指定格式为: 12345...build: context: . dockfile: ./dockerfile... ps: 这里可以指定 docker-gradle生成的 dockerfile 作为构建脚本.image: 指定构建完成之后的镜像名称,也就说执行完该文件会多一个以 dengbojing/gateway:v4 为名称的镜像; 下面的image为以zookeeper镜像为基础创建一个容器;ports: 对外暴露的端口 networks: 定义一个网络, 然后在 services 中使用, 此时 web 服务容器就可以通过下面的服务名–zookeeper 来访问下面的服务容器, 例: 1234spring: cloud: zookeeper: connect-string: zookeeper:2181 ps: gateway 项目为spring-cloud-gateway 项目, 使用了 zookeeper 作为注册中心和配置中心, 所以需要访问 zookeeper. 写到这里,简单的使用 docker-compose 就完成了, 不难发现对于微服务来说这种方式是非常有用的, 我们可以把我们几个服务包装成一个 docker-compose 项目,然后进行部署,它还支持从一个镜像启动多个容器实例–毕竟容器实例就是类的对象,有对个对象当然是没问题的; 这样以来那么一个文件里面就可以包含多个相同功能的服务,一个注册中心,一个配置中心,完美实现了集群功能.当然在实际生产过程中,注册中心和配置中心肯定在不同的服务器上, 所以这种方式有一定的局限性. 后记简单的学习了一下 docker-compose , 其中有很多配置和命令之后实战的时候才会真的用到. 怎么说呢: 路漫漫其修远兮, 吾将上下而求索","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://dengbojing.com/tags/docker/"},{"name":"springboot","slug":"springboot","permalink":"http://dengbojing.com/tags/springboot/"},{"name":"gradle","slug":"gradle","permalink":"http://dengbojing.com/tags/gradle/"}],"keywords":[]},{"title":"dockerfile构建自己的应用","slug":"dockerfile","date":"2020-02-01T03:45:08.000Z","updated":"2020-08-10T08:52:37.786Z","comments":true,"path":"2020/02/01/dockerfile/","link":"","permalink":"http://dengbojing.com/2020/02/01/dockerfile/","excerpt":"使用docker构建自己的应用","text":"使用docker构建自己的应用 引言 自从docker入门以后,一发不可收拾,越学习越感觉有趣,本文记录一下在学习dockerfile构建自己应用遇到的坑以及学习心得 Talk is cheap, show me the code 环境 使用gradle+jdk11编译及打包springboot项目,然后使用docker制作镜像 项目 springboot,作为现在最流行的微服务基础框架,我相信大家已经非常非常熟悉了,即使没有使用过,肯定听说过.一般比较通用的创建方式是使用springboot官网提供的创建工具进行创建,如果你使用intellij idea那么也可以在创建的时候使用spring initializr,这个和使用官方提供的创建工具是一回事 命令 FROM该指令是dockerfile的起始命令,是必须的,而且必须是第一个,作用是以一个镜像为基础,在该镜像上进行定制. FROM [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]FROM [--platform=&lt;platform&gt;] &lt;image&gt; [AS &lt;name&gt;]FROM [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;] ARG该指令是声明一个变量: 1ARG &lt;name&gt;[&#x3D;&lt;default value&gt;] 如果想覆盖默认值,可以在执行 docker build 命令时候指定 --build-arg &lt;name&gt;=&lt;value&gt; ps:在FROM之前声明的ARG在构建阶段之外，因此，FROM之后的任何指令都不能使用它。要使用在第一个FROM之前声明的ARG的默认值，请使用ARG指令，且在构建阶段内部不带值 1234ARG VERSION&#x3D;latest FROM busybox:$VERSION ARG VERSION RUN echo $VERSION &gt; image_version LABEL该指令添加 metadata 到镜像之中,格式为键值对,如: LABEL maintainer=&quot;dengbojing@qq.com&quot; ps: 这里正好用 maintainer 字段来说明一下,官方已经将MAINTAINER 这个命令废弃,改用 LABEL 代替 RUN该指令有两种格式 shell格式, RUN &lt;command&gt; command将会在shell中执行,对于linux系统shell为/bin/bash, 对于windows系统shell为 cmd /S /D exec格式, RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] , 注意该指令不会进行shell处理,比如 RUN [&quot;echo&quot;, &quot;$home&quot;] 是不会对 $home 处理的,你需要自己指定shell,RUN [&quot;sh&quot;, &quot;-c&quot;, &quot;echo $home&quot;]. 该命令执行一次会产生一层layer,所以应该尽量合并 RUN 后面 command 比如: RUN &amp;&amp; apt-get update &amp;&amp; apt-get install -y $buildDeps CMD该指令主要作用是为容器提供一个默认的执行命令,三种格式: exec格式, CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] ,该格式是官方推荐首选格式,同样该格式也不会进行shell处理. 参数格式: CMD [&quot;param1&quot;,&quot;param2&quot;], 该格式需要指定 ENTRYPOINT ,作为 ENTRYPOINT 的参数 shell格式, CMD command param1 param2 ps: 该指令在文件中只有一个,如果有多个那么只有最后一个 CMD 才会起作用,如果在docker run 后面指定了其他命令或者参数会覆盖 CMD 后面的命令或者参数 ENTRYPOINT该指令主要作用是为容器提供一个每次都执行的命令,该命令有两种格式: exec格式: ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] ,官方推荐shell格式: ENTRYPOINT command param1 param2 ps: 同 CMD 指令如果有多个 ENTRYPOINT 也只有最有一个起作用,如果想覆盖默认的ENTRYPOINT 可以使用: docker run --entrypoint;不同点在于,该指令可以直接在 docker run 后面跟参数,而 CMD 指令不可以. COPY顾名思义,该指令主要作用就是–复制,两种格式: COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;] ps: 1. 该指令的 --chown 只有linux才有,windows和linux权限管理不一样;另外该指令还支持通配符 2. 该指令只会cp源目标下文件. 3. 如果目标目录没有/, 则会将目标地址当成一个文件 4. 如果目标目录不存在, 则会创建目标目录的所有层级的目录 EXPOSE该指令暴露一个容器内部端口到外部,格式为: EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...] ps: 该指令并非真正暴露一个端口供外部使用,只是一种说明,说明容器内部哪些端口可以被访问,在启动时候需要使用 docker run -p &lt;out port&gt;:&lt;expose port&gt; WORKDIR该指令指定工作目录,相当于shell命令里面的 cd,指定工作目录之后,后续的COPY, RUN, CMD, ENTRYPOINT 等命令都是在当前目录下完成 USAGE &amp; CONTEXT 当执行 docker build 的时候需要一个 Dockerfile 文件和一个 context, context 的涵义是指包含一些列文件的PATH或者URL,这里的 PATH 代表了文件系统的目录, URL 则代表了 Git 仓库地址. 这里文件系统的目录是包含下面的子目录以及子目录中的文件,也就是 whole directory 都会被作为上下文发送给 docker daemon. docker build 构建的时候不是在CLI(命令行界面)构建而是把 当前目录 作为 context 发送给 docker daemon, 也就是docker的守护进程,所以说不能发送过大的目录,特别是不要在根目录执行 docker build, 官方推荐是使用一个空目录作为 context 来存放 Dockerfile ,仅仅添加 Dockerfile 需要的文件. 这里遇到一些问题,执行 docker build 命令的时候会将当前目录作为 context 发送给守护进程, 但是 Dockerfile 不能直接使用这些文件,官方说明为: To use a file in the build context, the Dockerfile refers to the file specified in an instruction, for example, a COPY instruction 翻译过来就是–要使用 context 中使用某个文件, Dockerfile 指定一个命令来引用这个文件,例如: COPY 命令, 换句话说,就是这些文件发送给守护进程,但是不能直接使用,得通过命令来使用(后面会说明碰到的问题). 制作学习了dockerfile和指令之后,我想到应该有两种方式制作镜像 方法一: 使用gradle构建项目,然后在使用dockerfile把jar包制作成镜像: 这种方法简单,但是感觉没什么意义啊,不过随后我还真的在springboot官方指导下找到了这个方法. 第一步,执行gradle构建项目gradle build -x test 第二步,编写dockerfile 123456FROM openjdk:11LABEL maintainer&#x3D;&quot;dengbojing@qq.com&quot; ARG JAR_FILE&#x3D;build&#x2F;libs&#x2F;*.jarCOPY $&#123;JAR_FILE&#125; app.jarEXPOSE 8090ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;&#x2F;app.jar&quot;] docker build -t dengbojing/gateway . 点代表把当前目录作为context发送给dockerdeamon 方法二: 把方法一的第一步放在Dockerfile里面,这样就少执行一步命令, 进入项目目录,新建一个空白的 Dockerfile 文件,填写如下内容: 123456FROM openjdk:11 LABEL maintainer&#x3D;&quot;dengbojing@qq.com&quot; COPY . .RUN .&#x2F;gradlew build -x test EXPOSE 8090 ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;build&#x2F;libs&#x2F;service-gateway-0.0.1-SNAPSHOT.jar&quot;] ps: 第一次写命令时候不了解 Dockerfile 和 context 的工作原理,觉得将当前工作目录发送给docker daemon 就能直接使用了,没有写COPY . ., 结果就是怎么都运行不过去,找不到gradlew 文件.后面 Google 之,看到这种写法,一脸懵,后来请教群里大神,加上仔细阅读文档,最终解惑. 这种方法有一个弊端,就是构建之后的镜像会比较大,因为 gradle 构建项目阶段所需要的额外的文件最终也被添加到镜像中了, 所以官方提供了多阶段构建. 例: 12345678910FROM openjdk:11 AS build LABEL maintainer&#x3D;&quot;dengbojing@qq.com&quot; COPY . .RUN .&#x2F;gradlew build -x test FROM openjdk:11 AS finalWORKDIR &#x2F;appCOPY --from&#x3D;build build&#x2F;libs&#x2F;service-gateway-0.0.1-SNAPSHOT.jar app.jarEXPOSE 8090 ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;app.jar&quot;] 可以对比一下两种不同方式构建的镜像最后的大小, 如下图: 可以看到,v1是通过非多阶段构建的,构建之后有1.16g大小,而通过多阶段构建,抛弃了 gradle 文件,只留下需要的项目jar包, 只有652M,好处显而易见. ps: 如果还想那个精简,那么可以使用 jre 而非 jdk; 我这里是使用的自己的一个spring-cloud-gateway项目进行学习的. 方法三: 以上的方法,是我直观能想到的方法,但是通过学习,找到了更简便的方法,那就是 gradle插件 ,编写 gradle构建脚本 ,生成 docker 镜像, 具体文档, 点击这里 后记 目前方法三还处于理论阶段,文档是看懂了,但是没有实质性的操作过.而且在项目构建过程中涉及到网络通信, spring-cloud 所有的项目都应该在注册中心注册, 我采用的 zookeeper 作为注册中心和配置中心, 这就涉及到了两个容器之间相互通信, 目前还没有学会, 目前做法是在宿主机启动 zookeeper, 然后找到 docker 虚拟网卡, 找到宿主机相对于 docker 的 ip address , 将镜像里面的 zk 地址改为宿主机相对于容器的ip, 这种方法很不容器化, 所以接着学习, 学会很容器化的方式方法. 骐骥一跃,不能十步;驽马十驾,功在不舍.","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://dengbojing.com/tags/docker/"},{"name":"springboot","slug":"springboot","permalink":"http://dengbojing.com/tags/springboot/"},{"name":"gradle","slug":"gradle","permalink":"http://dengbojing.com/tags/gradle/"}],"keywords":[]},{"title":"docker入门学习","slug":"docker-new","date":"2020-01-25T13:12:50.000Z","updated":"2020-08-04T12:29:38.239Z","comments":true,"path":"2020/01/25/docker-new/","link":"","permalink":"http://dengbojing.com/2020/01/25/docker-new/","excerpt":"docker入门","text":"docker入门 引言 作于2020年春节大年初一晚,此时疫情真的是猛于虎,为了避免给我媳妇她们医院带来不必要的麻烦,老实在家呆着学学新知识,提升自我. Talk is cheap, show me the code 介绍 Docker 使用 Google 公司推出的 Go 语言 进行开发实现,基于 Linux 内核的 cgroup,namespace,以及 AUFS 类的 Union FS 等技术,对进程进行封装隔离,属于操作 系统层面的虚拟化技术 个人理解就是一种虚拟化技术,类似之前接触过的lvm(linux virtual machine),但是有很大的不同,lvm是有一套完整的系统,虚拟出一套硬件系统和操作系统,然后在该系统之上又有很多的应用;而容器技术里面的应用直接是运行在容器宿主的内核之上,也没有虚拟除一套硬件,一套操作系统;所以容器很轻便小巧. ps: 从以上描述可以看出,容器技术更适用于持续集成和devOps,有点 java--Complie Once,Run Anywhere 的意思,只需要打包一次,在任何地方,任何系统之上都能使用,不存在之前 各种环境 (开发环境,测试环境,灰度环境,正式环境)导致的[这段代码在我机器上好好的啊,怎么可能有问题] 安装 注册docker hub 账号 在docker官方文档上找到对应操作系统的ps: 文件还是有点大,建议使用迅雷等p2p工具下载. 本人使用windows专业版系统,选择docker desktop for windows按照官网提示下载,完成之后不着急安装,此时需要先启动hyper-v,docker desktop是依赖hyper-v的,开启hype-v之后需要重启电脑,重启之后安装docker desktop,安装过程省略,下一步下一步即可.ps: 如果你是windows 家庭版,请参考这篇文章 启动docker desktop,在系统托盘图标右键-&gt;setting,找到resources-&gt;file sharing,选择你要共享的盘符,因为docker desktop默认是使用hyper-v虚拟机,而hyper-v虚拟机默认的镜像地址都是在C盘,也就是系统盘,这会导致c盘不够用,可以直接在resources-&gt;advanced下面找到disak image location修改镜像位置,本人是没有修改,这里本人是开启了共享盘符,把之后镜像使用的存储空间映射到本地其他磁盘上,这样解决了大部分存储空间的问题,镜像存储就不管了 入门 打开power shell,这里最好是不要使用其他命令终端,本人之前学习时候使用cmd,使用cmd是有坑的,后面会讲到,输入docker login,按照提示输入之前在docker hub上注册的用户名,密码,第一次需要输入,后续可以不用,也可使用图像化界面登录,右键docker desktop系统托盘图标-&gt;login. 登录之后我们就可以是用docker search命令来搜索我们感兴趣的仓库了,比如我们安装一个mysql吧,docker search mysql,可以看到有很多的mysql镜像,还有star数和officialps: 根据是否是官方提供,可将镜像资源分为两类.一种是类似 mysql 这样的镜像,被称为基础镜像或根镜像.这些基础镜像由 Docker 公司创建、验证、支持、提供.这样的镜像往往使用单个单词作为名字.还有一种类型,比如 bitnami/mysql 镜像,它是由 Docker 的用户创建并维护的,往往带有用户名称前缀. 使用docker pull拉去镜像,具体命令如下 docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] 具体选项可以通过`docker pull --help` 来查看, - docker registry地址: 默认是docker hub,一般不需要指定 - 仓库名: 前文提到镜像名称分为两段,`&lt;username&gt;/&lt;soft name&gt;`如果不指定默认是library,即docker官方的镜像. - tag: 标签,如果不指定默认为latest,当然可以指定需要的版本,查询tag目前本人没有找到相应的命令,只能去[docker hub](https://hub.docker.com/)搜索镜像然后查看tag 综上所述,此时只需使用`docker pull mysql`就可以了 可以是用docker image ls或者docker images 查看本地镜像此时可以看到镜像的大小和在docker hub大小是不一样的,这是因为,在docker hub显示的是压缩大小,docker hub作为一个中央镜像仓库,关心的是流量大小,而不是体积大小,所以会尽可能的压缩镜像体积;而且在这里,显示的大小可能和实际占用磁盘空间大小还不一样,这是因为,镜像是有很多文件层组成,而文件层之间又存在继承,复用的关系,如果不同的镜像使用相同的基础层,那么只需要保存一份该基础层就可以了,不同镜像的其他层可以直接引用该基础层,可以使用docker system df -v来查看具体的占用情况,同时可以使用docker system prune来清理磁盘空间.docker image ls 支持通配符,如 docker images my* 可以将所有my开头的镜像都列出docker image ls -q 可以只显示镜像的 ID此外还支持 -f(--filter) 过滤模式, 比如: docker images -f since=mysql 会列出在 mysql之后的所有镜像,将 since 换成 before 可以列出之前的镜像 启动容器,每一个容器都是一个镜像实例,这个就像java里面的oop思想一样,一个镜像就是一个类,一个类的对象对应一个容器,java 里面使用new关键字实例化对象,这里我们使用docker run来启动一个容器,具体命令参数: docker run [OPTIONS] IMAGE [COMMAND] [ARG…] 此处常用的 options 有 -p 指定端口号, -P 指定端口号映射为本机随机端口号; -e 指定容器内部的环境变量;-d 指定为后台启动;-i 保持stdin标准的输入流打开状态,即使没有链接; -t 分配一个伪终端, -v 指定文件映射,即讲本地的一个目录或者文件映射到容器内部;具体启动命令: docker run -d -p 3305:3306 –privileged=true -e MYSQL_ROOT_PASSWORD=xxxx –name mysqltest -v /f/mysql/data:/var/lib/mysql -v /f/mysql/conf/my.cnf:/etc/mysql/my.cnf -v //f/mysql/mysql-files:/var/lib mysql-files/ mysql:latest –character-set-server=utf8mb4 –collation-server=utf8mb4_unicode_ci 解释一下,此时我们就把容器内部的3306端口映射为宿主机的3305端口,并且设置了mysql的配置,数据存储位置,并且进行了一系列的mysql参数设置,指定了 msyql root 的密码为xxx,–privileged是让容器内部的用户获取宿主机特殊权限,此处一定要把文件映射在你已经共享的盘符,不然会失败 查看容器状态, docker container ls -a 或 docker ps -a 可以看到容器的状态,映射端口,名字等;使用 docker stop &lt;container name\\id&gt; 停止容器, 使用 docker start &lt;container name\\id&gt; 再次启动容器,注意第一次启动容器使用 docker run 命令,该命令会创建并启动一个容器, 之后并不需要在run,只需要执行start就可以了,此外 docker run 执行时,如果指定镜像不存在,该命令会自动拉去默认仓库所匹配的镜像 删除镜像和容器删除镜像使用 docker image rm 或 docker rmi 加上镜像的 ID 来删除镜像删除容器使用 docker container rm 或 docker rm 加上容器 ID 删除容器,可以添加 -f 强制删除一个正在运行的容器;此外如果只是想清理未被容器使用的镜像可以使用 docker image prune同理,可以使用 docker container prune 清理未运行的容器如果需要删除的容器或者镜像太多,手动一个个输入就显得有点智障了,此时可以使用 docker image ls -q 来配合批量删除,比如:docker rmi $(docker image ls -q -f since=mysql)此时就会将mysql之前所有的镜像都删除ps: 此处有之前说的 cmd 的坑,使用 cmd 会报错,改用 power shell 就不会 后记基础入门就这些,后续根据自身所学内容,会陆陆续续的记录更多的东西,比如如何创建一个docker容器啊,导入导出镜像啊,私有仓库的搭建等等. 不积跬步，无以至千里；不积小流，无以成江海","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://dengbojing.com/tags/docker/"}],"keywords":[]},{"title":"使用hexo+github pages建立静态blog","slug":"first","date":"2020-01-14T11:32:51.000Z","updated":"2021-06-10T03:43:42.362Z","comments":true,"path":"2020/01/14/first/","link":"","permalink":"http://dengbojing.com/2020/01/14/first/","excerpt":"好记性不如烂笔头 记录一下使用hexo + github pages搭建博客的过程,以及过程中遇到的坑;同时也给阅读这篇文章,想要搭建博客的人一点帮助","text":"好记性不如烂笔头 记录一下使用hexo + github pages搭建博客的过程,以及过程中遇到的坑;同时也给阅读这篇文章,想要搭建博客的人一点帮助 使用gihub pages免费而且稳定,也无需域名,只需要你有github账号就能用&#96; Talk is cheap, show me the code Git git根据自己电脑下载相应版本,本人是win10电脑使用git bash. 安装完成打开git bash, 输入git --version测试是否安装成功 注册github账号(全球最大的同性交友网站,你值得拥有). 新建&lt;username&gt;.github.io仓库. node node根据自己电脑下载相应版本 安装完成之后,在之前的git bash输入node --version测试是否安装成功 Hexo 安装好 Node.js 后，通过 npm 安装 Hexo npm install hexo-cli -g ps: 可能安装失败,如果失败,安装cnpm,然后在安装hexo;或者挂代理,走梯子 npm install -g cnpm –registry&#x3D;https://registry.npm.taobao.org 安装 Hexo 完成后,执行 hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 执行完成之后目录会像 ├── _config.yml ├── node_modules │ ├── hexo │ ├── hexo-generator-archive │ ├── hexo-generator-category │ ├── hexo-generator-index │ ├── hexo-generator-tag │ ├── hexo-renderer-ejs │ ├── hexo-renderer-marked │ ├── hexo-renderer-stylus │ └── hexo-server ├── package.json ├── scaffolds │ ├── draft.md │ ├── page.md │ └── post.md ├── source │ └── _posts └── themes └── landscape ps: 简单说明一下目录作用 _config.yml 配置文件,网站的标题,作者,主题配置等 node_modules hexo的模块,较少关心 package.json 项目描述文件,不用关心 scaffolds 模版配置,较少关心 source–&gt;_post 主要存放我们写的文章 themes hexo主题,文件夹名称对应为主题名称 配置_config.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# Sitetitle: Hexo #标题subtitle: #副标题description: #描述author: #你的名字language: zh #网站使用的语言,注意使用主题下面的语言(themes--&gt;&lt;要使用的主题&gt;--&gt;languages)不然会出现未知结果timezone: Asia/Shanghai #网站时区 # URLurl: https://dengbojing.com #地址(如果未申请域名则不需要填写)root: / #根目录permalink: :year/:month/:day/:title/ #文章的永久链接格式permalink_defaults: # trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks# Directorysource_dir: source #资源文件夹public_dir: public #由资源文件夹生成而来tag_dir: tags #标签文件夹,默认是没有的需要使用hexo new page tags 自行创建archive_dir: archives #归档文件夹category_dir: categories #分类文件夹,默认是没有的需要使用hexo new page tags 自行创建code_dir: downloads/code #Include code 文件夹i18n_dir: :lang #国际化（i18n）文件夹skip_render: #跳过指定文件的解析# Writingnew_post_name: title.md # 新文章的文件名称default_layout: post #预设布局titlecase: false # 把标题转换为单词首字母大写external_link: enable: true # 在新标签中打开链接 field: site exclude: &#x27;&#x27; #排除文件filename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写render_drafts: false #显示草稿post_asset_folder: false #启动 Asset 文件夹，为 true 时，每次建立文件时，Hexo 会自动建立一个与文章同名的文件夹relative_link: false #把链接改为与根目录的相对位址future: true #显示未来的文章highlight: #代码块高亮,很多主题要求此项为false enable: true line_number: true auto_detect: true tab_replace:# Category &amp; Tagdefault_category: uncategorized #默认分类category_map: #分类别名tag_map: #标签别名# Date / Time formatdate_format: YYYY-MM-DD #日期格式time_format: HH:mm:ss #时间格式# Paginationper_page: 10 #每页显示的文章量 (0关闭分页功能)pagination_dir: page #分页目录# Extensionstheme: next #当前主题名称(本人使用的非默认主题)# Deploymentdeploy: #部署 type: git repo: https://github.com/username/username.github.io.git #仓库地址 branch: master #分支名称 打开看看, 在git bash中使用 hexo g 命令生成文章,hexo s命令启动服务,下面提示访问localhost:4000,访问一下看到使用默认主题的网站 写文章 使用hexo new post &lt;filename&gt; 创建自己的第一篇文章 找到source–&gt;_post,打开&lt;filename&gt;.md 更多写作用法 123456---title: 使用hexo+github pages建立静态blogdate: 2020-01-14 19:32:51tags: [git,hexo]categories: hexo--- 在date下面添加分类和标签,可选 在—下面写正文内容,可以使用&lt;!--more--&gt;分割 比如: 简介 &lt;!--more--&gt; 正文 本地预览hexo g生成hexo s启动打开浏览器,输入localhost:4000看看吧 部署到服务器 安装一键部署 npm install hexo-deployer-git –save 执行 hexo clean(可选,正常情况不需要) hexo d 部署到&lt;username&gt;.github.io 后记 使用过程中遇到很多问题,目前都没有解决, 比如有些主题莫名看不到tags和categories仓库,最后选来选去只能使用next主题 还有写modules(比如七牛云)安装之后即使你不启用你也得写配置","categories":[{"name":"hexo","slug":"hexo","permalink":"http://dengbojing.com/categories/hexo/"}],"tags":[{"name":"git","slug":"git","permalink":"http://dengbojing.com/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"http://dengbojing.com/tags/hexo/"}],"keywords":[{"name":"hexo","slug":"hexo","permalink":"http://dengbojing.com/categories/hexo/"}]}]}