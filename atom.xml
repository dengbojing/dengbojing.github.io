<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>生活不易,砥砺前行</title>
  
  <subtitle>Keep farmed and carry hard</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://denbgojing.com/"/>
  <updated>2020-03-06T08:13:49.304Z</updated>
  <id>http://denbgojing.com/</id>
  
  <author>
    <name>Dengbojing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>docker-compose</title>
    <link href="http://denbgojing.com/2020/02/11/docker-compose/"/>
    <id>http://denbgojing.com/2020/02/11/docker-compose/</id>
    <published>2020-02-11T09:36:28.000Z</published>
    <updated>2020-03-06T08:13:49.304Z</updated>
    
    <content type="html"><![CDATA[<p>what? 扫把独立日? </p><a id="more"></a><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>使用gradle插件构建镜像和docker-compose连接容器</p><blockquote><h1 id="Talk-is-cheap-show-me-the-code"><a href="#Talk-is-cheap-show-me-the-code" class="headerlink" title="Talk is cheap, show me the code"></a>Talk is cheap, show me the code</h1></blockquote><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>打开docker远程访问端口,<code>docker desktop for windows</code> GUI 界面有一个<code>expose daemon on tcp://localhost:2375</code>, 只需要勾选,然后重启就行;当然这个是提供一个loopback的访问,实际上你并没有真正的暴露一个局域网或者广域网访问的端口,不过对于<code>docker-gradle</code> 使用已经足够,如果非要提供一个远程访问端口请参考<a href="https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-docker/configure-docker-daemon" target="_blank" rel="noopener">微软文档</a>.<br>操作很简单就是在 <code>C:\ProgramData\Docker\config\daemon.json</code> 添加一行<code>&quot;hosts&quot;: [&quot;tcp://0.0.0.0:2375&quot;]</code>, 这里需要注意的就是你 <code>docker desktop for windows</code> 是以windows container启动的而不是linux container 方式启动, 不然不起作用, 至于网上其他方法不做评价, 我只相信官方的说法.  </p><h1 id="Gradle插件构建镜像"><a href="#Gradle插件构建镜像" class="headerlink" title="Gradle插件构建镜像"></a>Gradle插件构建镜像</h1><ol><li><p>在 <code>build.gradle</code> 中添加 <code>docker-plugin</code> 插件,然后编写脚本具体文档参考<a href="https://bmuschko.github.io/gradle-docker-plugin/#remote_api_plugin" target="_blank" rel="noopener">这里</a>, 最终 <code>build.gradle</code> 就是像下面这样:  </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    ...</span><br><span class="line">    id &#39;com.bmuschko.docker-spring-boot-application&#39; version &#39;6.1.3&#39;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">dependencies&#123;...&#125;</span><br><span class="line">docker &#123;</span><br><span class="line">    springBootApplication &#123;</span><br><span class="line">        baseImage &#x3D; &#39;openjdk:11&#39;</span><br><span class="line">        ports &#x3D; [8090]</span><br><span class="line">        maintainer &#x3D; &#39;dengbojing@qq.com&#39;</span><br><span class="line">        images &#x3D; [&#39;dengbojing&#x2F;gateway:v3&#39;]</span><br><span class="line">        jvmArgs &#x3D; [&#39;-Dspring.profiles.active&#x3D;production&#39;, &#39;-Xmx2048m&#39;]</span><br><span class="line">        mainClassName &#x3D; &#39;com.yichen.ServiceGatewayApplication&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>baseImage</code> 基于哪个基础镜像构建.<br> <code>ports</code> 需要暴露的端口.<br> <code>maintainer</code> 对应 <code>dockerfile</code> 中已经飞起的 <code>maintainer</code> 命令, 添加一些元信息.<br> <code>images</code>  构建出来的额镜像名称.<br> <code>jvmArgs</code> 对应 <code>dockerfile</code> <code>ENTRYPOINT</code> 命令中的启动参数.<br> <code>mainClassName</code>  对应 <code>dockerfile</code> <code>ENTRYPOINT</code> 命令中的启动类.    </p></li><li><p>执行 <code>gradle dockerBuildImage</code>, 该命令就会使用 <code>docker -H tcp://127.0.0.1:2375 build</code> 来构建镜像, 所以要先开启 <code>2375端口</code>;<br>当然该插件也能提供远程构建,具体请看<a href="https://bmuschko.github.io/gradle-docker-plugin/#remote_api_plugin" target="_blank" rel="noopener">官方文档</a>;<br>如果使用开发工具可以在开发工具<code>gradle</code>插件里面找到对应的执行的<code>task</code>;<br>然后会在 <code>${classpath}/build/docker</code> 下面看到生成的 <code>dockerfile</code>,这里并不是打 <code>jar</code> 包的方式, 而是用完整的<code>lib</code> 和 <code>classes</code> 制作镜像,然后用<code>java -cp</code> 指定设置 <code>classpath</code> 然后启动脚本写的 <code>mianClass</code>;<br>此时执行 <code>docker images</code> 就可以看到制作的镜像.  </p></li><li><p>插件提供了4个 <code>task</code>, 分别是 <code>dockerPushImage</code>–推送镜像到镜像仓库,需要指定用户名密码,具体参看<a href="https://bmuschko.github.io/gradle-docker-plugin/#remote_api_plugin" target="_blank" rel="noopener">官方文档</a> , <code>dockerBuildImage</code>–构建镜像 , <code>dockerCreateDockerfile</code>–创建<code>dockerfile</code> , <code>dockerSyncBuildContext</code>–将代码同步到<code>docker context</code> , 前面的 <code>task</code> 总是依赖后面的 <code>task</code>.</p></li></ol><h1 id="Docker-compose介绍-amp-简单使用"><a href="#Docker-compose介绍-amp-简单使用" class="headerlink" title="Docker-compose介绍 &amp; 简单使用"></a>Docker-compose介绍 &amp; 简单使用</h1><ol><li><p><code>docker-compose</code> 是官方提供的编排项目工具, 主要是应对<strong><em>单机</em></strong>多容器之间连接通信.</p></li><li><p>使用 <code>docker-compose.yml</code> 作为模版文件  </p></li><li><p>模版文件开头使用 <code>version</code> 来指定 <code>docker-compose</code> 文件格式,目前最新版本为3.7,具体对照关系可以参考<a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener">这里</a>  </p></li><li><p>一个简单的 <code>docker-compose.yml</code> 示例:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span> </span><br><span class="line">    <span class="attr">web:</span> </span><br><span class="line">        <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">dengbojing/gateway:v4</span></span><br><span class="line">        <span class="attr">ports:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">"8090:8090"</span></span><br><span class="line">        <span class="attr">networks:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">gateway</span></span><br><span class="line">    <span class="attr">zookeeper:</span> </span><br><span class="line">        <span class="attr">image:</span> <span class="string">zookeeper</span></span><br><span class="line">        <span class="attr">networks:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">gateway</span></span><br><span class="line"><span class="attr">networks:</span> </span><br><span class="line">    <span class="attr">gateway:</span></span><br></pre></td></tr></table></figure><p><code>version</code>: compose的版本号,具体对应关系可以查看<a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener">文档</a><br><code>services</code>: 需要启动的服务,一个服务对应一个容器,也就是说在执行该文件之后,会多出两个容器<br><code>web</code>,<code>zookeeper</code>: 服务名称, 最终创建的容器名称会以启动时候指定的 <code>${project_name}</code> 加上服务的名称为完整的容器名称<br><code>build</code>: 指定构建的 <code>docker-context</code> 和 <code>dockerfile</code>, 此处都在当前目录; 详细指定格式为:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">build:</span> </span><br><span class="line">    <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">dockfile:</span> <span class="string">./dockerfile</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>ps: 这里可以指定 <code>docker-gradle</code>生成的 <code>dockerfile</code> 作为构建脚本.<br><code>image:</code> 指定构建完成之后的镜像名称,也就说执行完该文件会多一个以 <code>dengbojing/gateway:v4</code> 为名称的镜像; 下面的<code>image</code>为以<code>zookeeper</code>镜像为基础创建一个容器;<br><code>ports</code>: 对外暴露的端口  </p></li><li><p><code>networks</code>: 定义一个网络, 然后在 <code>services</code> 中使用, 此时 <code>web</code> 服务容器就可以通过下面的服务名–<code>zookeeper</code> 来访问下面的服务容器, 例:  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">zookeeper:</span></span><br><span class="line">      <span class="attr">connect-string:</span> <span class="string">zookeeper:2181</span></span><br></pre></td></tr></table></figure><p>ps: <code>gateway</code> 项目为<code>spring-cloud-gateway</code> 项目, 使用了 <code>zookeeper</code> 作为注册中心和配置中心, 所以需要访问 <code>zookeeper</code>.  </p></li><li><p>写到这里,简单的使用 <code>docker-compose</code> 就完成了, 不难发现对于微服务来说这种方式是非常有用的, 我们可以把我们几个服务包装成一个 <code>docker-compose</code> 项目,然后进行部署,它还支持从一个镜像启动多个容器实例–毕竟容器实例就是类的对象,有对个对象当然是没问题的; 这样以来那么一个文件里面就可以包含多个相同功能的服务,一个注册中心,一个配置中心,完美实现了集群功能.<br>当然在实际生产过程中,注册中心和配置中心肯定在不同的服务器上, 所以这种方式有一定的局限性.</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>简单的学习了一下 <code>docker-compose</code> , 其中有很多配置和命令之后实战的时候才会真的用到. 怎么说呢:    </p><blockquote><p>路漫漫其修远兮, 吾将上下而求索</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;what? 扫把独立日? &lt;/p&gt;
    
    </summary>
    
    
    
      <category term="docker" scheme="http://denbgojing.com/tags/docker/"/>
    
      <category term="springboot" scheme="http://denbgojing.com/tags/springboot/"/>
    
      <category term="gradle" scheme="http://denbgojing.com/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>dockerfile构建自己的应用</title>
    <link href="http://denbgojing.com/2020/02/01/dockerfile/"/>
    <id>http://denbgojing.com/2020/02/01/dockerfile/</id>
    <published>2020-02-01T03:45:08.000Z</published>
    <updated>2020-02-02T08:33:29.825Z</updated>
    
    <content type="html"><![CDATA[<p>使用docker构建自己的应用</p><a id="more"></a><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>  自从docker入门以后,一发不可收拾,越学习越感觉有趣,本文记录一下在学习dockerfile构建自己应用遇到的坑以及学习心得  </p><blockquote><h1 id="Talk-is-cheap-show-me-the-code"><a href="#Talk-is-cheap-show-me-the-code" class="headerlink" title="Talk is cheap, show me the code"></a>Talk is cheap, show me the code</h1></blockquote><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>  使用gradle+jdk11编译及打包springboot项目,然后使用docker制作镜像  </p><h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><p>  springboot,作为现在最流行的微服务基础框架,我相信大家已经非常非常熟悉了,即使没有使用过,肯定听说过.一般比较通用的创建方式是使用springboot官网提供的<a href="https://start.spring.io/" target="_blank" rel="noopener">创建工具</a>进行创建,如果你使用intellij idea那么也可以在创建的时候使用spring initializr,这个和使用官方提供的创建工具是一回事  </p><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><ol><li><p>FROM<br>该指令是dockerfile的起始命令,是必须的,而且必须是第一个,作用是以一个镜像为基础,在该镜像上进行定制.  </p><blockquote><p><code>FROM [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</code><br><code>FROM [--platform=&lt;platform&gt;] &lt;image&gt; [AS &lt;name&gt;]</code><br><code>FROM [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]</code>  </p></blockquote></li><li><p>ARG<br>该指令是声明一个变量: </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARG &lt;name&gt;[&#x3D;&lt;default value&gt;]</span><br></pre></td></tr></table></figure><p> 如果想覆盖默认值,可以在执行 <code>docker build</code> 命令时候指定 <code>--build-arg &lt;name&gt;=&lt;value&gt;</code></p></li></ol><pre><code>ps:在FROM之前声明的ARG在构建阶段之外，因此，FROM之后的任何指令都不能使用它。要使用在第一个FROM之前声明的ARG的默认值，请使用ARG指令，且在构建阶段内部不带值    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ARG VERSION&#x3D;latest  </span><br><span class="line">FROM busybox:$VERSION  </span><br><span class="line">ARG VERSION  </span><br><span class="line">RUN echo $VERSION &gt; image_version</span><br></pre></td></tr></table></figure></code></pre><ol start="3"><li><p>LABEL<br>该指令添加 <code>metadata</code> 到镜像之中,格式为键值对,如: </p><blockquote><p><code>LABEL maintainer=&quot;dengbojing@qq.com&quot;</code></p></blockquote><p>   ps: 这里正好用 <code>maintainer</code> 字段来说明一下,官方已经将<code>MAINTAINER</code> 这个命令废弃,改用 <code>LABEL</code> 代替   </p></li><li><p>RUN<br>该指令有两种格式  </p><ul><li><p>shell格式, <code>RUN &lt;command&gt;</code> command将会在shell中执行,对于linux系统shell为/bin/bash, 对于windows系统shell为 cmd /S /D   </p></li><li><p>exec格式, <code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> , 注意该指令不会进行shell处理,比如 <code>RUN [&quot;echo&quot;, &quot;$home&quot;]</code> 是不会对 <code>$home</code> 处理的,你需要自己指定shell,<code>RUN [&quot;sh&quot;, &quot;-c&quot;, &quot;echo $home&quot;]</code>.   </p><p>该命令执行一次会产生一层layer,所以应该尽量合并 <code>RUN</code> 后面 <code>command</code> 比如:  </p><blockquote><p>RUN &amp;&amp; apt-get update <br>  &amp;&amp; apt-get install -y $buildDeps  </p></blockquote></li></ul></li><li><p>CMD<br>该指令主要作用是为容器提供一个默认的执行命令,三种格式:  </p><ul><li><p>exec格式, <code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code> ,该格式是官方推荐首选格式,同样该格式也不会进行shell处理.  </p></li><li><p>参数格式: <code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code>, 该格式需要指定 <code>ENTRYPOINT</code> ,作为 <code>ENTRYPOINT</code> 的参数  </p></li><li><p>shell格式, <code>CMD command param1 param2</code>   </p><p>ps: 该指令在文件中只有一个,如果有多个那么只有最后一个 <code>CMD</code> 才会起作用,如果在<code>docker run</code> 后面指定了其他命令或者参数会覆盖 <code>CMD</code> 后面的命令或者参数</p></li></ul></li><li><p>ENTRYPOINT<br>该指令主要作用是为容器提供一个每次都执行的命令,该命令有两种格式:  </p><blockquote><p>exec格式: <code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> ,官方推荐<br>shell格式: <code>ENTRYPOINT command param1 param2</code>  </p></blockquote><p> ps: 同 <code>CMD</code> 指令如果有多个 <code>ENTRYPOINT</code> 也只有最有一个起作用,如果想覆盖默认的<code>ENTRYPOINT</code> 可以使用: <code>docker run --entrypoint</code>;不同点在于,该指令可以直接在 <code>docker run</code> 后面跟参数,而 <code>CMD</code> 指令不可以.  </p></li><li><p>COPY<br>顾名思义,该指令主要作用就是–复制,两种格式:  </p><blockquote><p><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code><br><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</code>  </p></blockquote><p>   ps: 该指令的 <code>--chown</code> 只有linux才有,windows和linux权限管理不一样;另外该指令还支持通配符  </p></li><li><p>EXPOSE<br>该指令暴露一个容器内部端口到外部,格式为:  </p><blockquote><p><code>EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</code><br>   ps: 该指令并非真正暴露一个端口供外部使用,只是一种说明,说明容器内部哪些端口可以被访问,在启动时候需要使用 <code>docker run -p &lt;out port&gt;:&lt;expose port&gt;</code>   </p></blockquote></li></ol><ol start="9"><li>WORKDIR<br>该指令指定工作目录,相当于<code>shell</code>命令里面的 <code>cd</code>,指定工作目录之后,后续的<code>COPY</code>,  <code>RUN</code>, <code>CMD</code>, <code>ENTRYPOINT</code> 等命令都是在当前目录下完成  </li></ol><h1 id="USAGE-amp-CONTEXT"><a href="#USAGE-amp-CONTEXT" class="headerlink" title="USAGE  &amp;  CONTEXT"></a>USAGE  &amp;  CONTEXT</h1><p>  当执行 <code>docker build</code> 的时候需要一个 <code>Dockerfile</code> 文件和一个 <code>context</code>, <code>context</code> 的涵义是指包含一些列文件的<code>PATH</code>或者<code>URL</code>,这里的 <code>PATH</code> 代表了文件系统的目录, <code>URL</code> 则代表了 <code>Git</code> 仓库地址.  </p><p>  这里文件系统的目录是包含下面的子目录以及子目录中的文件,也就是 <code>whole directory</code> 都会被作为上下文发送给 <code>docker daemon</code>.  </p><p>  <code>docker build</code> 构建的时候不是在CLI(命令行界面)构建而是把 <code>当前目录</code> 作为 <code>context</code> 发送给 <code>docker daemon</code>, 也就是docker的守护进程,所以说不能发送过大的目录,特别是不要在根目录执行 <code>docker build</code>, 官方推荐是使用一个空目录作为 <code>context</code> 来存放 <code>Dockerfile</code> ,仅仅添加 <code>Dockerfile</code> 需要的文件.  </p><p>  这里遇到一些问题,执行 <code>docker build</code> 命令的时候会将当前目录作为 <code>context</code> 发送给守护进程, 但是 <code>Dockerfile</code> 不能直接使用这些文件,官方说明为:  </p><blockquote><p>To use a file in the build context, the Dockerfile refers to the file specified in an instruction, for example, a COPY instruction  </p></blockquote><p>  翻译过来就是–<code>要在构建的 context 中使用某个文件, Dockerfile 指定一个命令来引用这个文件,例如: COPY 命令</code>, 换句话说,就是这些文件发送给守护进程,但是不能直接使用,得通过命令来使用(后面会说明碰到的问题).  </p><h1 id="制作"><a href="#制作" class="headerlink" title="制作"></a>制作</h1><h2 id="学习了dockerfile和指令之后-我想到应该有两种方式制作镜像"><a href="#学习了dockerfile和指令之后-我想到应该有两种方式制作镜像" class="headerlink" title="学习了dockerfile和指令之后,我想到应该有两种方式制作镜像"></a>学习了dockerfile和指令之后,我想到应该有两种方式制作镜像</h2><ul><li><p>方法一: 使用gradle构建项目,然后在使用dockerfile把jar包制作成镜像: 这种方法简单,但是感觉没什么意义啊,不过随后我还真的在<a href="https://spring.io/guides/gs/spring-boot-docker/" target="_blank" rel="noopener">springboot官方指导</a>下找到了这个方法.  </p><ol><li><p>第一步,执行gradle构建项目gradle build -x test  </p></li><li><p>第二步,编写dockerfile  </p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:11</span><br><span class="line">LABEL maintainer&#x3D;&quot;dengbojing@qq.com&quot;  </span><br><span class="line">ARG JAR_FILE&#x3D;build&#x2F;libs&#x2F;*.jar</span><br><span class="line">COPY $&#123;JAR_FILE&#125; app.jar</span><br><span class="line">EXPOSE 8090</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;&#x2F;app.jar&quot;]</span><br></pre></td></tr></table></figure></li><li><p>docker build -t dengbojing/gateway  </p></li></ol></li><li><p>方法二: 把方法一的第一步放在Dockerfile里面,这样就少执行一步命令,</p><ol><li><p>进入项目目录,新建一个空白的 <code>Dockerfile</code> 文件,填写如下内容:  </p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:11  </span><br><span class="line">LABEL maintainer&#x3D;&quot;dengbojing@qq.com&quot;  </span><br><span class="line">COPY . .</span><br><span class="line">RUN .&#x2F;gradlew build -x test  </span><br><span class="line">EXPOSE 8090  </span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;build&#x2F;libs&#x2F;service-gateway-0.0.1-SNAPSHOT.jar&quot;]</span><br></pre></td></tr></table></figure><p>   ps: 第一次写命令时候不了解 <code>Dockerfile</code> 和 <code>context</code> 的工作原理,觉得将当前工作目录发送给<code>docker daemon</code> 就能直接使用了,没有写<code>COPY . .</code>, 结果就是怎么都运行不过去,找不到<code>gradlew</code> 文件.后面 <code>Google</code> 之,看到这种写法,一脸懵,后来请假群里大神,加上仔细阅读文档,最终解惑.  </p></li><li><p>这种方法有一个弊端,就是构建之后的镜像会比较大,因为 <code>gradle</code> 构建项目阶段所需要的额外的文件最终也被添加到镜像中了, 所以官方提供了多阶段构建. 例: </p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:11 AS build  </span><br><span class="line">LABEL maintainer&#x3D;&quot;dengbojing@qq.com&quot;  </span><br><span class="line">COPY . .</span><br><span class="line">RUN .&#x2F;gradlew build -x test  </span><br><span class="line"></span><br><span class="line">FROM openjdk:11 AS final</span><br><span class="line">WORKDIR &#x2F;app</span><br><span class="line">COPY --from&#x3D;build build&#x2F;libs&#x2F;service-gateway-0.0.1-SNAPSHOT.jar app.jar</span><br><span class="line">EXPOSE 8090  </span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;app.jar&quot;]</span><br></pre></td></tr></table></figure><p>   可以对比一下两种不同方式构建的镜像最后的大小, 如下图: <img src="https://i.ibb.co/87P6vRx/compare-v1-v2.png" alt="compare-v1:v2"><br>   可以看到,v1是通过非多阶段构建的,构建之后有1.16g大小,而通过多阶段构建,抛弃了 <code>gradle</code> 文件,只留下需要的项目jar包, 只有652M,好处显而易见.<br>   ps: 如果还想那个精简,那么可以使用 <code>jre</code> 而非 <code>jdk</code>; 我这里是使用的自己的一个<code>spring-cloud-gateway</code>项目进行学习的.  </p></li></ol></li><li><p>方法三: 以上的方法,是我直观能想到的方法,但是通过学习,找到了更简便的方法,那就是 <code>gradle插件</code> ,编写 <code>gradle构建脚本</code> ,生成 <code>docker</code> 镜像, 具体文档, 点击<a href="https://bmuschko.github.io/gradle-docker-plugin/#spring_boot_application_plugin" target="_blank" rel="noopener">这里</a>  </p></li></ul><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>  目前方法三还处于理论阶段,文档是看懂了,但是没有实质性的操作过.而且在项目构建过程中涉及到网络通信, <code>spring-cloud</code> 所有的项目都应该在注册中心注册, 我采用的 <code>zookeeper</code> 作为注册中心和配置中心, 这就涉及到了两个容器之间相互通信, 目前还没有学会, 目前做法是在宿主机启动 <code>zookeeper</code>, 然后找到 <code>docker</code> 虚拟网卡, 找到宿主机相对于 <code>docker</code> 的 <code>ip address</code> , 将镜像里面的 zk 地址改为宿主机相对于容器的ip, 这种方法很不容器化, 所以接着学习, 学会很容器化的方式方法.  </p><blockquote><p>骐骥一跃,不能十步;驽马十驾,功在不舍.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用docker构建自己的应用&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="docker" scheme="http://denbgojing.com/tags/docker/"/>
    
      <category term="springboot" scheme="http://denbgojing.com/tags/springboot/"/>
    
      <category term="gradle" scheme="http://denbgojing.com/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>docker入门学习</title>
    <link href="http://denbgojing.com/2020/01/25/docker-new/"/>
    <id>http://denbgojing.com/2020/01/25/docker-new/</id>
    <published>2020-01-25T13:12:50.000Z</published>
    <updated>2020-02-01T03:57:17.636Z</updated>
    
    <content type="html"><![CDATA[<p>docker入门</p><a id="more"></a><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>  作于2020年春节大年初一晚,此时疫情真的是猛于虎,为了避免给我媳妇她们医院带来不必要的麻烦,老实在家呆着学学新知识,提升自我.  </p><blockquote><h1 id="Talk-is-cheap-show-me-the-code"><a href="#Talk-is-cheap-show-me-the-code" class="headerlink" title="Talk is cheap, show me the code"></a>Talk is cheap, show me the code</h1></blockquote><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><blockquote><p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现,基于 Linux 内核的<br>   cgroup,namespace,以及 AUFS 类的 Union FS 等技术,对进程进行封装隔离,属于操作<br>   系统层面的虚拟化技术  </p></blockquote><p>   个人理解就是一种虚拟化技术,类似之前接触过的lvm(linux virtual machine),但是有很大的不同,lvm是有一套完整的系统,虚拟出一套硬件系统和操作系统,然后在该系统之上又有很多的应用;而容器技术里面的应用直接是运行在容器宿主的内核之上,也没有虚拟除一套硬件,一套操作系统;所以容器很轻便小巧.<br>   ps: 从以上描述可以看出,容器技术更适用于持续集成和devOps,有点 <code>java--Complie Once,Run Anywhere</code> 的意思,只需要打包一次,在任何地方,任何系统之上都能使用,不存在之前 <code>各种环境</code> (开发环境,测试环境,灰度环境,正式环境)导致的[这段代码在我机器上好好的啊,怎么可能有问题]</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol><li><p>注册docker hub 账号  </p></li><li><p>在<a href="https://docs.docker.com/" target="_blank" rel="noopener">docker</a>官方文档上找到对应操作系统的下载地址<img src="https://i.ibb.co/jw20qkm/docker-com.png" alt=""><br>ps: 文件还是有点大,建议使用迅雷等p2p工具下载.  </p></li><li><p>本人使用<code>windows专业版系统</code>,选择<code>docker desktop for windows</code>按照官网提示下载,完成之后不着急安装,此时需要先启动<code>hyper-v</code>,<code>docker desktop</code>是依赖<code>hyper-v</code>的,开启<code>hype-v</code>之后需要重启电脑,重启之后安装<code>docker desktop</code>,安装过程省略,下一步下一步即可.<br>ps: 如果你是<code>windows 家庭版</code>,请参考<a href="https://www.jianshu.com/p/1329954aa329/" target="_blank" rel="noopener">这篇文章</a>  </p></li><li><p>启动<code>docker desktop</code>,在系统托盘图标<code>右键-&gt;setting</code>,找到<code>resources-&gt;file sharing</code>,选择你要共享的盘符,因为<code>docker desktop</code>默认是使用<code>hyper-v</code>虚拟机,而<code>hyper-v</code>虚拟机默认的镜像地址都是在<code>C盘</code>,也就是系统盘,这会导致<code>c盘</code>不够用,可以直接在<code>resources-&gt;advanced</code>下面找到<code>disak image location</code>修改镜像位置,本人是没有修改,这里本人是开启了共享盘符,把之后镜像使用的存储空间映射到本地其他磁盘上,这样解决了大部分存储空间的问题,镜像存储就不管了    </p></li></ol><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><ol><li><p>打开<code>power shell</code>,这里最好是不要使用其他命令终端,本人之前学习时候使用cmd,使用cmd是有坑的,后面会讲到,输入<code>docker login</code>,按照提示输入之前在<code>docker hub</code>上注册的用户名,密码,第一次需要输入,后续可以不用,也可使用图像化界面登录,右键<code>docker desktop</code>系统托盘图标-&gt;login.  </p></li><li><p>登录之后我们就可以是用<code>docker search</code>命令来搜索我们感兴趣的仓库了,比如我们安装一个mysql吧,<code>docker search mysql</code>,可以看到有很多的<code>mysql</code>镜像,还有<code>star数</code>和<code>official</code><br>ps: 根据是否是官方提供,可将镜像资源分为两类.一种是类似 <code>mysql</code> 这样的镜像,被称为基础镜像或根镜像.这些基础镜像由 Docker 公司创建、验证、支持、提供.这样的镜像往往使用单个单词作为名字.还有一种类型,比如 <code>bitnami/mysql</code> 镜像,它是由 Docker 的用户创建并维护的,往往带有用户名称前缀.  </p></li><li><p>使用<code>docker pull</code>拉去镜像,具体命令如下  </p><blockquote><p>docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]   </p></blockquote></li></ol><pre><code>具体选项可以通过`docker pull --help` 来查看,  - docker registry地址: 默认是docker hub,一般不需要指定- 仓库名: 前文提到镜像名称分为两段,`&lt;username&gt;/&lt;soft name&gt;`如果不指定默认是library,即docker官方的镜像.- tag: 标签,如果不指定默认为latest,当然可以指定需要的版本,查询tag目前本人没有找到相应的命令,只能去[docker hub](https://hub.docker.com/)搜索镜像然后查看tag    综上所述,此时只需使用`docker pull mysql`就可以了  </code></pre><ol start="4"><li><p>可以是用<code>docker image ls</code>或者<code>docker images</code> 查看本地镜像<img src="https://i.ibb.co/myY1D6q/docker-images.png" alt=""><br>此时可以看到镜像的大小和在<code>docker hub</code>大小是不一样的,这是因为,在<code>docker hub</code>显示的是压缩大小,<code>docker hub</code>作为一个中央镜像仓库,关心的是流量大小,而不是体积大小,所以会尽可能的压缩镜像体积;而且在这里,显示的大小可能和实际占用磁盘空间大小还不一样,这是因为,镜像是有很多文件层组成,而文件层之间又存在继承,复用的关系,如果不同的镜像使用相同的基础层,那么只需要保存一份该基础层就可以了,不同镜像的其他层可以直接引用该基础层,可以使用<code>docker system df -v</code>来查看具体的占用情况,同时可以使用<code>docker system prune</code>来清理磁盘空间.<br><code>docker image ls</code> 支持通配符,如 <code>docker images my*</code> 可以将所有my开头的镜像都列出<br><code>docker image ls -q</code> 可以只显示镜像的 <code>ID</code><br>此外还支持 <code>-f(--filter)</code> 过滤模式, 比如: <code>docker images -f since=mysql</code> 会列出在 <code>mysql</code>之后的所有镜像,将 <code>since</code> 换成 <code>before</code> 可以列出之前的镜像  </p></li><li><p>启动容器,每一个容器都是一个镜像实例,这个就像<code>java里面的oop思想</code>一样,一个镜像就是一个类,一个类的对象对应一个容器,java 里面使用<code>new</code>关键字实例化对象,这里我们使用<code>docker run</code>来启动一个容器,具体命令参数:  </p><blockquote><p>docker run [OPTIONS] IMAGE [COMMAND] [ARG…]   </p></blockquote><p>此处常用的 <code>options</code> 有 <code>-p</code> 指定端口号, <code>-P</code> 指定端口号映射为本机随机端口号; <code>-e</code> 指定容器内部的环境变量;<code>-d</code> 指定为后台启动;<code>-i</code> 保持stdin标准的输入流打开状态,即使没有链接; <code>-t</code> 分配一个伪终端, <code>-v</code> 指定文件映射,即讲本地的一个目录或者文件映射到容器内部;具体启动命令:  </p><blockquote><p>docker run -d -p 3305:3306 –privileged=true -e MYSQL_ROOT_PASSWORD=xxxx –name   mysqltest -v /f/mysql/data:/var/lib/mysql -v /f/mysql/conf/my.cnf:/etc/mysql/my.cnf </p></blockquote></li></ol><p>   -v //f/mysql/mysql-files:/var/lib/mysql-files/ mysql:latest –character-set-server=utf8mb4 –collation-server=utf8mb4_unicode_ci  </p><pre><code>解释一下,此时我们就把容器内部的3306端口映射为宿主机的3305端口,并且设置了mysql的配置,数据存储位置,并且进行了一系列的mysql参数设置,指定了 `msyql root` 的密码为xxx,--privileged是让容器内部的用户获取宿主机特殊权限,此处一定要把文件映射在你已经共享的盘符,不然会失败  </code></pre><ol start="6"><li>查看容器状态, <code>docker container ls -a</code> 或 <code>docker ps -a</code> 可以看到容器的状态,映射端口,名字等;<br>使用 <code>docker stop &lt;container name\id&gt;</code> 停止容器, 使用 <code>docker start &lt;container name\id&gt;</code> 再次启动容器,注意第一次启动容器使用 <code>docker  run</code> 命令,该命令会创建并启动一个容器, 之后并不需要在run,只需要执行start就可以了,此外 <code>docker run</code> 执行时,如果指定镜像不存在,该命令会自动拉去默认仓库所匹配的镜像  </li></ol><ol start="7"><li>删除镜像和容器<br>删除镜像使用 <code>docker image rm</code> 或 <code>docker rmi</code> 加上镜像的 <code>ID</code> 来删除镜像<br>删除容器使用 <code>docker container rm</code> 或 <code>docker rm</code> 加上容器 <code>ID</code> 删除容器,可以添加 <code>-f</code> 强制删除一个正在运行的容器;<br>此外如果只是想清理未被容器使用的镜像可以使用 <code>docker image prune</code><br>同理,可以使用  <code>docker container prune</code> 清理未运行的容器<br>如果需要删除的容器或者镜像太多,手动一个个输入就显得有点智障了,此时可以使用 <code>docker image ls -q</code> 来配合批量删除,比如:<br><code>docker rmi $(docker image ls -q -f since=mysql)</code><br>此时就会将mysql之前所有的镜像都删除<br>ps: 此处有之前说的 <code>cmd</code> 的坑,使用 <code>cmd</code> 会报错,改用 <code>power shell</code> 就不会</li></ol><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>基础入门就这些,后续根据自身所学内容,会陆陆续续的记录更多的东西,比如如何创建一个docker容器啊,导入导出镜像啊,私有仓库的搭建等等.  </p><blockquote><p>不积跬步，无以至千里；不积小流，无以成江海</p></blockquote><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker入门&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="docker" scheme="http://denbgojing.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo+github pages建立静态blog</title>
    <link href="http://denbgojing.com/2020/01/14/first/"/>
    <id>http://denbgojing.com/2020/01/14/first/</id>
    <published>2020-01-14T11:32:51.000Z</published>
    <updated>2020-01-16T01:56:33.076Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>好记性不如烂笔头</p></blockquote><p>记录一下使用hexo + github pages搭建博客的过程,以及过程中遇到的坑;同时也给阅读这篇文章,想要搭建博客的人一点帮助</p><a id="more"></a><h1 id="为什么搞独立blog"><a href="#为什么搞独立blog" class="headerlink" title="为什么搞独立blog"></a>为什么搞独立blog</h1><p><code>市面上blog service多如牛毛为啥非要搞自己的,因为独立的才是自己的</code></p><h1 id="为什么使用gihub-pages"><a href="#为什么使用gihub-pages" class="headerlink" title="为什么使用gihub pages"></a>为什么使用gihub pages</h1><p><code>因为不用买服务器,免费而且稳定,也无需域名,只需要你有github账号就能用</code></p><blockquote><h1 id="Talk-is-cheap-show-me-the-code"><a href="#Talk-is-cheap-show-me-the-code" class="headerlink" title="Talk is cheap, show me the code"></a>Talk is cheap, show me the code</h1></blockquote><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><ol><li><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">git</a>根据自己电脑下载相应版本,本人是win10电脑使用git bash.</li><li>安装完成打开<code>git bash</code>, 输入<code>git --version</code>测试是否安装成功</li><li>注册<a href="https://github.com/" target="_blank" rel="noopener">github</a>账号(全球最大的同性交友网站,你值得拥有).</li><li>新建<code>&lt;username&gt;.github.io</code>仓库.</li></ol><h1 id="node"><a href="#node" class="headerlink" title="node"></a>node</h1><ol><li><a href="http://nodejs.cn/download/]" target="_blank" rel="noopener">node</a>根据自己电脑下载相应版本</li><li>安装完成之后,在之前的<code>git bash</code>输入<code>node --version</code>测试是否安装成功</li></ol><h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><ol><li><p>安装好 Node.js 后，通过 npm 安装 Hexo</p><blockquote><p>npm install hexo-cli -g</p></blockquote><p> ps: 可能安装失败,如果失败,安装cnpm,然后在安装hexo;或者挂代理,走梯子</p><blockquote><p>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p></blockquote></li><li><p>安装 Hexo 完成后,执行</p><blockquote><p>hexo init &lt;folder&gt;<br>cd &lt;folder&gt;<br>npm install  </p></blockquote><p> 执行完成之后目录会像</p><blockquote><p>├── _config.yml<br> ├── node_modules<br> │   ├── hexo<br> │   ├── hexo-generator-archive<br> │   ├── hexo-generator-category<br> │   ├── hexo-generator-index<br> │   ├── hexo-generator-tag<br> │   ├── hexo-renderer-ejs<br> │   ├── hexo-renderer-marked<br> │   ├── hexo-renderer-stylus<br> │   └── hexo-server<br> ├── package.json<br> ├── scaffolds<br> │   ├── draft.md<br> │   ├── page.md<br> │   └── post.md<br> ├── source<br> │   └── _posts<br> └── themes  </p><pre><code>└── landscape  </code></pre></blockquote><p> ps: 简单说明一下目录作用   </p><blockquote><p> _config.yml  配置文件,网站的标题,作者,主题配置等<br> node_modules hexo的模块,较少关心<br> package.json 项目描述文件,不用关心<br> scaffolds  模版配置,较少关心<br> source–&gt;_post  主要存放我们写的文章<br> themes  <a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo主题</a>,文件夹名称对应为主题名称  </p></blockquote></li><li><p>配置_config.yml</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: Hexo #标题</span><br><span class="line">subtitle: #副标题</span><br><span class="line">description: #描述</span><br><span class="line">author: #你的名字</span><br><span class="line">language: zh #网站使用的语言,注意使用主题下面的语言(themes--&gt;&lt;要使用的主题&gt;--&gt;languages)不然会出现未知结果</span><br><span class="line">timezone: Asia&#x2F;Shanghai #网站时区 </span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">url: https:&#x2F;&#x2F;dengbojing.com #地址(如果未申请域名则不需要填写)</span><br><span class="line">root: &#x2F; #根目录</span><br><span class="line">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F; #文章的永久链接格式</span><br><span class="line">permalink_defaults: #</span><br><span class="line">    trailing_index: true # Set to false to remove trailing &#39;index.html&#39; from permalinks</span><br><span class="line">    trailing_html: true # Set to false to remove trailing &#39;.html&#39; from permalinks</span><br><span class="line"></span><br><span class="line"># Directory</span><br><span class="line">source_dir: source #资源文件夹</span><br><span class="line">public_dir: public #由资源文件夹生成而来</span><br><span class="line">tag_dir: tags #标签文件夹,默认是没有的需要使用hexo new page tags 自行创建</span><br><span class="line">archive_dir: archives #归档文件夹</span><br><span class="line">category_dir: categories #分类文件夹,默认是没有的需要使用hexo new page tags 自行创建</span><br><span class="line">code_dir: downloads&#x2F;code #Include code 文件夹</span><br><span class="line">i18n_dir: :lang #国际化（i18n）文件夹</span><br><span class="line">skip_render: #跳过指定文件的解析</span><br><span class="line"></span><br><span class="line"># Writing</span><br><span class="line">new_post_name: title.md # 新文章的文件名称</span><br><span class="line">default_layout: post #预设布局</span><br><span class="line">titlecase: false # 把标题转换为单词首字母大写</span><br><span class="line">external_link: </span><br><span class="line">    enable: true # 在新标签中打开链接</span><br><span class="line">    field: site</span><br><span class="line">    exclude: &#39;&#39; #排除文件</span><br><span class="line">filename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写</span><br><span class="line">render_drafts: false #显示草稿</span><br><span class="line">post_asset_folder: false #启动 Asset 文件夹，为 true 时，每次建立文件时，Hexo 会自动建立一个与文章同名的文件夹</span><br><span class="line">relative_link: false #把链接改为与根目录的相对位址</span><br><span class="line">future: true #显示未来的文章</span><br><span class="line">highlight: #代码块高亮,很多主题要求此项为false</span><br><span class="line">    enable: true</span><br><span class="line">    line_number: true</span><br><span class="line">    auto_detect: true</span><br><span class="line">    tab_replace:</span><br><span class="line"></span><br><span class="line"># Category &amp; Tag</span><br><span class="line">default_category: uncategorized #默认分类</span><br><span class="line">category_map: #分类别名</span><br><span class="line">tag_map: #标签别名</span><br><span class="line"></span><br><span class="line"># Date &#x2F; Time format</span><br><span class="line">date_format: YYYY-MM-DD #日期格式</span><br><span class="line">time_format: HH:mm:ss #时间格式</span><br><span class="line"></span><br><span class="line"># Pagination</span><br><span class="line">per_page: 10 #每页显示的文章量 (0关闭分页功能)</span><br><span class="line">pagination_dir: page #分页目录</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">theme: next #当前主题名称(本人使用的非默认主题)</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">deploy: #部署</span><br><span class="line">    type: git</span><br><span class="line">    repo: https:&#x2F;&#x2F;github.com&#x2F;username&#x2F;username.github.io.git #仓库地址</span><br><span class="line">    branch: master #分支名称</span><br></pre></td></tr></table></figure></li><li><p>打开看看, 在<code>git bash</code>中使用 <code>hexo g</code> 命令生成文章,<code>hexo s</code>命令启动服务,下面提示访问<a href="http://localhost:4000" target="_blank" rel="noopener">localhost:4000</a>,访问一下看到使用默认主题的网站  </p></li></ol><h1 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h1><p>  使用<code>hexo new post &lt;filename&gt;</code> 创建自己的第一篇文章<br>  找到source–&gt;_post,打开<code>&lt;filename&gt;.md</code><br>  <strong><em>更多<a href="https://hexo.io/zh-cn/docs/writing" target="_blank" rel="noopener">写作</a>用法</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 使用hexo+github pages建立静态blog</span><br><span class="line">date: 2020-01-14 19:32:51</span><br><span class="line">tags: [git,hexo]</span><br><span class="line">categories: hexo</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>  在date下面添加分类和标签,可选<br>  在—下面写正文内容,可以使用<code>&lt;!--more--&gt;</code>分割  </p><blockquote><p>比如:   </p></blockquote><pre><code>简介  &lt;!--more--&gt;正文  </code></pre><h1 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h1><p>hexo g生成<br>hexo s启动<br>打开浏览器,输入<a href="localhost:4000">localhost:4000</a>看看吧  </p><h1 id="部署到服务器"><a href="#部署到服务器" class="headerlink" title="部署到服务器"></a>部署到服务器</h1><p>  安装一键部署</p><blockquote><p>npm install hexo-deployer-git –save  </p></blockquote><p>  执行 <code>hexo clean</code>(可选,正常情况不需要)<br>  <code>hexo d</code> 部署到<code>&lt;username&gt;.github.io</code></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>  使用过程中遇到很多问题,目前都没有解决,<br>  比如有些主题莫名看不到tegs和categories仓库,最后选来选去只能使用next主题<br>  还有写modules(比如七牛云)安装之后即使你不启用你也得写配置  </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;好记性不如烂笔头&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;记录一下使用hexo + github pages搭建博客的过程,以及过程中遇到的坑;同时也给阅读这篇文章,想要搭建博客的人一点帮助&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://denbgojing.com/categories/hexo/"/>
    
    
      <category term="git" scheme="http://denbgojing.com/tags/git/"/>
    
      <category term="hexo" scheme="http://denbgojing.com/tags/hexo/"/>
    
  </entry>
  
</feed>
